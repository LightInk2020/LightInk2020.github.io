<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法基础题——刷题01</title>
      <link href="2021/04/17/algorithm01/"/>
      <url>2021/04/17/algorithm01/</url>
      
        <content type="html"><![CDATA[<h2 id="算法基础题——刷题01"><a href="#算法基础题——刷题01" class="headerlink" title="算法基础题——刷题01"></a>算法基础题——刷题01</h2><blockquote><p>题目来源：<a href>Leetcode</a>       <a href>PAT</a>      <a href>codeup</a></p><p>题目解析参考：个人理解+题目解析+网络解析</p></blockquote><h3 id="刷题策略"><a href="#刷题策略" class="headerlink" title="刷题策略"></a>刷题策略</h3><ul><li>选取合适题目</li><li>坚持每天适量刷题</li></ul><blockquote><p>强调英文注释</p></blockquote><ul><li><p>每道题回顾：</p><span id="more"></span><ul><li><p>思路回溯并简单记录（最好英文）</p></li><li><p>参考其他人的好的解题思路并简要记录</p></li><li><p>知识点学习和总结</p><blockquote><p>对于解法涉及到的不会的知识点进行学习和总结，包括视频、文章学习核心知识点，新的常用函数，代码规范等</p></blockquote></li></ul></li><li><p>如果题目不会：</p><ul><li><p>抄答案</p><blockquote><p>按正确答案进行敲代码（绝不能复制），然后加上自己的注释来理清思路</p></blockquote></li><li><p>总结思路</p></li><li><p>学习相应知识点</p></li></ul></li></ul><hr><blockquote><p>2021/4/17 18:27</p></blockquote><ul><li><strong>题目：</strong></li></ul><ul><li><p><strong>知识点学习</strong></p><ul><li><p>sort()</p><ul><li><p>使用sort()排序</p><p>sort()函数可以高效的对数据进行排序。</p><p>sort()函数的使用必须加上头文件”#include&lt;algorithm&gt;”和”using namespace std;”，使用方式如下：</p><p><code>sort(首元素地址（必填）,尾元素地址的下一个地址（必填）,比较函数（非必填）);</code></p><p>如果不写比较函数，则默认对前面给出的函数进行递归排序。元素排序后将返回赋值到原来数据的地址。</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> PAT </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-传输层</title>
      <link href="2021/04/16/jsjwl03/"/>
      <url>2021/04/16/jsjwl03/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-传输层"><a href="#计算机网络-传输层" class="headerlink" title="计算机网络-传输层"></a>计算机网络-传输层</h2><ul><li><p>目标：</p><ul><li><p>理解传输层的工作原理</p><ul><li>多路复用/解复用</li><li>可靠数据传输 RDT</li></ul><blockquote><p>TCP是可靠的，但是它的下层IP服务是不可靠的，那么TCP应该以什么方式实现可靠传输。</p></blockquote><ul><li>流量控制</li><li>拥塞控制</li></ul><span id="more"></span></li><li><p>学习Internet的传输层协议</p><ul><li>UDP：无连接传输</li><li>TCP：面向连接的可靠传输</li><li>TCP的拥塞控制</li></ul></li></ul></li></ul><h3 id="1-概述和传输层服务"><a href="#1-概述和传输层服务" class="headerlink" title="1 概述和传输层服务"></a>1 概述和传输层服务</h3><ul><li><p>传输服务和协议</p><ul><li><p>为运行在不同主机上的应用<strong>进程</strong>以报文段为单位提供<strong>逻辑通信</strong></p></li><li><p>传输协议运行在端系统</p><ul><li>发送方：将应用层的报文分成报文段，然后传递给网络层</li></ul><blockquote><p>如果报文比较长，传输层会将报文分成若干报文段</p></blockquote><ul><li>接收方：将报文段重组成报文，然后传递给应用层</li></ul><blockquote><p>将报文段的段头去掉，然后按顺序将报文段结合起来成报文，然后以字节流方式上传</p></blockquote></li><li><p>有多个传输层协议可供应用选择</p><ul><li>Internet: TCP和UDP</li></ul><blockquote><p>向下，网络层就都是IP提供服务</p></blockquote></li></ul><p><img src="/2021/04/16/jsjwl03/image-20210416225619983.png" alt="传输层服务"></p></li><li><p>传输层 vs. 网络层</p><ul><li><p>网络层服务：<strong>主机之间</strong>的逻辑通信</p></li><li><p>传输层服务：<strong>进程间</strong>的逻辑通信</p><blockquote><p>通过增加16位端口号的机制，实现了主机到进程的细化</p></blockquote><ul><li>依赖于网络层的服务<ul><li>延时、带宽</li></ul></li><li>并对网络层的服务进行增强<ul><li>对数据丢失、顺序混乱等处理-可靠性</li></ul></li><li>对数据进行加密-安全性<ul><li>复用/解复用</li></ul></li></ul></li></ul><blockquote><p>有些服务是可以加强的：不可靠 → 可靠；安全</p><p>但有些服务是不可以被加强的：带宽，延迟</p></blockquote><ul><li>传输层提供了复用/解复用的功能</li></ul><blockquote><p>类比：东西2个家庭的通信</p><p>Ann家的12个小孩给另Bill家的12个小孩发信共144封，分开传输代价太大，所以Ann打包到一封信一起给邮政公司传输（复用），然后到Bill家Bill再分开按照信的标识分别分发（解复用）给12个孩子</p><ul><li><p>主机 = 家庭   进程 = 小孩</p></li><li><p>应用层报文 = 信封中的信件</p></li><li><p>传输协议 = Ann和Bill</p><ul><li>为家庭小孩提供复用、解复用服务</li></ul></li><li><p>网络层协议 = 邮政服务</p><ul><li>家庭-家庭的邮包传输服务</li></ul></li></ul></blockquote></li><li><p>Internet传输层协议</p><ul><li>可靠的、保序的传输：TCP<ul><li>多路复用、解复用</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li><li>向上层应用层提供的是字节流的服务</li></ul></li><li>不可靠、不保序的传输：UDP<ul><li>多路复用、解复用</li><li>没有为尽力而为的IP服务添加更多的其它额外服务</li><li>向上层应用层提供的是数据报的服务</li></ul></li><li>都不提供的服务：<ul><li>延时保证</li><li>带宽保证</li></ul></li></ul></li></ul><h3 id="2-多路复用与解复用"><a href="#2-多路复用与解复用" class="headerlink" title="2 多路复用与解复用"></a>2 多路复用与解复用</h3><p><img src="/2021/04/16/jsjwl03/image-20210417144104306.png" alt="多路复用/解复用"></p><blockquote><p>主要根据网络层封装的IP地址寻找目标主机，然后在目标主机传输层解封装，根据传输层的头中的端口号解复用给对应目标进程</p></blockquote><p><img src="/2021/04/16/jsjwl03/image-20210417145437105.png" alt="传输过程"></p><ul><li><p>多路解复用工作原理</p><ul><li>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确 的进程</li><li>主机收到IP数据报<ul><li>每个数据报有源IP地址和目标IP地址</li><li>每个数据报承载一个传输层报文段</li><li>每个报文段有一个源端口号和目标端口号 (特定应用有著名的端口号) </li></ul></li><li>主机联合使用IP地址和端口号将报文段发送给合适的套接字</li><li>TCP和UDP不同</li></ul></li><li><p>无连接（UDP）多路解复用</p><ul><li>创建套接字： </li></ul><p>服务器端： </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocket=socket(PF_INET,  SOCK_DGRAM,<span class="number">0</span>); </span><br><span class="line">bind(serverSocket, &amp;sad, <span class="keyword">sizeof</span>(sad));</span><br></pre></td></tr></table></figure><blockquote><p>serverSocket和Sad指定的端口号捆绑 </p></blockquote><p>客户端： </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClientSocket=socket(PF_INET,  SOCK_DGRAM,<span class="number">0</span>); </span><br></pre></td></tr></table></figure><blockquote><p> 没有Bind，ClientSocket和OS为之分配的某个端口号隐式捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）</p></blockquote><ul><li><p>在接收端，UDP套接字用二元组标识 (目标IP地址、目标端口号即本地server的IP和端口号) </p></li><li><p>当主机收到UDP报文段： </p><ul><li>检查报文段的目标端口号</li><li>用该端口号将报文段定位给套接字</li></ul></li><li><p>如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</p></li></ul><p><img src="/2021/04/16/jsjwl03/image-20210417151731561.png" alt="UDPsocket表"></p><p><img src="/2021/04/16/jsjwl03/image-20210417153511155.png" alt="无连接多路复用"></p><blockquote><p><font color="red">疑问：这里来自不同主机和复用/解复用有什么关系？特别是复用？</font></p></blockquote></li><li><p>面向连接（TCP）的多路复用</p><ul><li>TCP套接字:四元组本地标识：<ul><li>源IP地址 </li><li>源端口号 </li><li>目的IP地址 </li><li>目的端口号</li></ul></li><li>解复用：接收主机用这四个值来将数据报定位到合适的套接字</li><li>服务器能够在一个TCP端口上同时支持多个 TCP套接字：<ul><li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li></ul></li><li>Web服务器对每个连接客户端有不同的套接字 <ul><li>非持久对每个请求有不同的套接字</li></ul></li></ul></li></ul><h3 id="3-无连接传输：UDP（User-Datagram-Protocol）"><a href="#3-无连接传输：UDP（User-Datagram-Protocol）" class="headerlink" title="3 无连接传输：UDP（User Datagram Protocol）"></a>3 无连接传输：UDP（User Datagram Protocol）</h3><ul><li><p>网络层的IP服务是主机到主机的尽力而为的传输，UDP在其基础上增加端口号实现了进程到进程，但是没有增加其他额外的功能</p></li><li><p>“no frills,”“bare bones”Internet传输协议</p></li><li><p>“尽力而为”的服务，报文段可能丢失或者送到应用进程的报文段乱序 </p></li><li><p>无连接： </p><ul><li>UDP发送端和接收端之间没有握手 </li><li>每个UDP报文段都被独立地处理</li></ul></li><li><p>UDP 被用于: </p><ul><li>流媒体（丢失不敏感，速率敏感、应用可控制传输速率）</li><li>DNS</li><li>SNMP</li></ul></li><li><p>在UDP上可行可靠传输：</p><ul><li>在应用层增加可靠性</li><li>应用特定的差错恢复</li></ul></li><li><p>UDP报文段格式</p><p><img src="/2021/04/16/jsjwl03/image-20210417155905728.png" alt="UDP报文段格式"></p><ul><li>包括头部和载荷（sdu）</li><li>头部：8字节<ul><li>源端口号2字节    目的端口号2字节   </li><li>长度：报文段整个长度   包括头部</li><li>校验和<ul><li>EDC 差错校验码，判断包括头部、载荷在传输过程是否出错，如果出错则将报文丢失</li></ul></li></ul></li></ul></li><li><p>为什么要有UDP？</p><ul><li>不建立连接 （会增加延时）</li><li>简单：在发送端和接收端没有连接状态</li><li>报文段的头部head很小（cost开销小） 只有8个字节</li><li>无拥塞控制和流量控制，UDP可以尽可能快的发送报文段<ul><li>应用数据从应用层向下层传递的传输的速率近似等于主机到主机的网络传递的速率，来多快，传多快</li></ul></li></ul></li><li><p>UDP校验和</p><ul><li><p>目标： 检测在被传输报文段中的差错 (如比特反转)</p></li><li><p>发送方： </p><ul><li>将报文段的内容视为16比特的整数</li><li>校验和：报文段的加法和 （1的补运算） </li><li>发送方将校验和放在UDP的校验和字段</li></ul></li><li><p>接收方：</p><ul><li><p>计算接收到的报文段的校验和 </p></li><li><p>检查计算出的校验和与校验和字段的内容是否相等：</p><ul><li><p>不相等––检测到差错</p></li><li><p>相等––没有检测到差错，但也许还是有差错 </p><ul><li><p>残存错误</p><blockquote><p>例如，发送方UDP报文段包括：校验和EDC+其他数据D（头部其它内容+载荷+伪头部等），而接收方UDP报文段包括：校验和EDC’+其他数据D’（头部其它内容+载荷+伪头部等），巧合情况：D’计算出的校验和与校验和EDC’字段的内容相等</p></blockquote></li></ul></li></ul></li></ul></li></ul></li><li><p>Internet校验和的例子</p><ul><li><p>当数字相加时，在最高位的进位要回卷，再加到结果上 </p><p><img src="/2021/04/16/jsjwl03/image-20210417162713542.png" alt="校验和示例"></p></li><li><p>Internet校验和，就是将D（头部其它内容+载荷+伪头部等）分为一个个16bit，然后进行一一相加、进位回滚、反码求出校验和。</p><p>然后目标端将收到的D’进行一一相加、进位回滚，然后加上校验和EDC’，如果结果等于1111111111111111则通过校验，否则没有通过校验</p><p>注：求和时，必须将进位回卷到结果</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统-基础学习路线</title>
      <link href="2021/04/16/sjk/"/>
      <url>2021/04/16/sjk/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li>《MySQL必知必会》 - Ben forta </li><li>《高性能MySQL（第3版）》 - Baron Schwartz </li></ul><h3 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h3><ul><li><a href="http://db.lcs.mit.edu/6.830/index.php">麻省理工学院 MIT 6.830</a></li><li><a href="http://www.icourse163.org/course/HIT-1001516002">哈尔滨工业大学 数据库系统</a></li></ul><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计-基础学习路线</title>
      <link href="2021/04/16/gl/"/>
      <url>2021/04/16/gl/</url>
      
        <content type="html"><![CDATA[<h2 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li><p>《Probability and Statistics》 -Morris H.Degroot</p></li><li><p>《概率论与数理统计》 -陈希孺</p></li></ul><h3 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1Zy4y1J7vM?p=2">概率数学基础 - 台湾大学叶丙成</a></li><li><a href="https://www.bilibili.com/video/BV1ot411y7mU?from=search&seid=5596277735640438059">《概率论与数理统计》教学视频全集（宋浩）</a></li></ul><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-基础学习路线</title>
      <link href="2021/04/16/os/"/>
      <url>2021/04/16/os/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li>《现代操作系统》 - Andrew S. Tanenbaum</li><li>《深入理解计算机系统》</li><li>《操作系统导论》- Remzi，H. </li></ul><h3 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=9067503727200252128">操作系统（哈工大李治军老师）32讲</a></li><li><a href="https://www.lanqiao.cn/courses/115">操作系统（哈工大李治军老师）32讲 -配套实验课</a></li><li><a href="https://www.bilibili.com/video/BV1iW411d7hd?from=search&seid=13353650717207742800d?from=search&seid=13353650717207742800">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统</a></li></ul><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><ul><li><a href="https://github.com/Exely/CSAPP-Labs">CSAPP-Labs</a></li></ul><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-基础学习路线</title>
      <link href="2021/04/16/jsjwl/"/>
      <url>2021/04/16/jsjwl/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li>《计算机网络：自顶向下方法》（James F.Kurose、Keith W.Ross)</li></ul><h3 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=8">中科大郑烇老师全套《计算机网络》</a></li><li><a href="https://www.bilibili.com/video/BV1Up411Z7hC?p=1&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1598544022&unique_k=eeA2CI">哈尔滨工业大学 计算机网络</a></li><li><a href="https://www.bilibili.com/video/av64605483/">计算机网络微课堂</a></li></ul><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><ul><li><p><a href="https://blog.csdn.net/qq_39326472/article/details/88089747?utm_source=app&app_version=4.5.4">计算机网络（自顶向下方法）学习笔记(头秃的女程序员)</a></p></li><li><p><a href="https://www.yuque.com/nepjnq/ntyr7v">劝退宝典</a></p><span id="more"></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语单词</title>
      <link href="2021/04/12/English01/"/>
      <url>2021/04/12/English01/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>主要参考：<ul><li><a href="https://www.bilibili.com/video/BV12E411B7A5/?spm_id_from=333.788.recommend_more_video.0">朱伟考研英语-恋词序列一：题源7000词</a></li></ul></li></ul></blockquote><h2 id="Unit-One"><a href="#Unit-One" class="headerlink" title="Unit One"></a>Unit One</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ol><li>v. 声称，宣称</li><li>n. 政府  国家  <strong>州</strong> ；<strong>状况，情况</strong></li><li>adj. 国家的 国有的</li></ol><span id="more"></span><blockquote><p>例句  He stated that “all hell will break loose, politically and morally, all over the world. “</p><p>hell 地狱</p><p>break loose 松开</p><p>politically 政治地</p><p>morally  道德地</p></blockquote><blockquote><p>考点  to seek permission from state regulators</p><p>permission  n.允许   permit  v.允许</p><p>a state of mind  思想状况    a state of affairs  事情状况</p></blockquote><p>派生：statement   n.  评论，宣称、声明</p><ul><li><p>拓展词汇：</p><p>understate   v. 轻描淡写地表述；淡化（某事的严重性）</p><p>overstate v. 夸大，夸张（=exaggerate）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="2021/04/12/python01/"/>
      <url>2021/04/12/python01/</url>
      
        <content type="html"><![CDATA[<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li>python是一门完全开源的高级编程语言，拥有优雅的语法和丰富的第三方库。</li><li>编程语言，是一种用于编写计算机程序的语言，用于控制计算机的行为。</li><li>按照语言在执行之前是否需要编译区分，可以将编程语言分为需要编译的编译型语言和不需要编译的解释型语言。</li></ul><p><img src="/2021/04/12/python01/image-20210413224609458.png" alt="编程语言"></p><blockquote><p> 解释型语言运行要比编译型语言慢。</p></blockquote><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统绪论</title>
      <link href="2021/04/12/os01/"/>
      <url>2021/04/12/os01/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统绪论"><a href="#操作系统绪论" class="headerlink" title="操作系统绪论"></a>操作系统绪论</h2><blockquote><ul><li>主要参考书籍：<ul><li>《操作系统导论》（Remzi H. Arpaci-Dusseau、Andrea C. Arpaci-Dusseau)</li><li>《操作系统概念》（Abraham Silberschatz、Peter Bear  Galvin、Greg  Gagne）</li></ul></li><li>主要参考视频：<ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=9067503727200252128">操作系统（哈工大李治军老师）32讲（全）超清</a></li></ul></li></ul></blockquote><span id="more"></span><h3 id="1-操作系统介绍"><a href="#1-操作系统介绍" class="headerlink" title="1 操作系统介绍"></a>1 操作系统介绍</h3><ul><li><p>程序运行时会发生什么？</p><p>一个正在运行的程序会做一件非常简单的事：执行指令。</p><p>处理器从内存中获取（fetch）一条指令，对其进行解码（decode）（弄清楚这是哪一条指令），然后执行</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-应用层</title>
      <link href="2021/04/10/jsjwl02/"/>
      <url>2021/04/10/jsjwl02/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-应用层"><a href="#计算机网络-应用层" class="headerlink" title="计算机网络-应用层"></a>计算机网络-应用层</h2><ul><li><p>学习目标：</p><ul><li><p>网络应用的原理：网络应用协议的概念和实现方面</p><ul><li>网络应用的体系结构：<ul><li>客户-服务器模式     对等模式（peer-to-peer）     混合结构</li></ul></li><li>网络应用的服务需求：<ul><li>可靠性     带宽     时延</li></ul></li></ul><span id="more"></span></li><li><p>传输层提供的服务模型</p><ul><li>TCP、UDP 如何为应用层提供的支持？</li></ul></li><li><p>内容分发网络</p></li><li><p>网络应用的实例：互联网流行的应用层协议</p><ul><li>web应用–HTTP协议</li><li>文件传输应用–FTP协议</li><li>email应用–SMTP、POP3、IMAP协议</li><li>实现网络核心应用功能的DNS</li></ul></li><li><p>编程：如何开发网络应用程序？</p><ul><li>Socket API</li></ul></li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/20190324183705231.png" alt="应用层知识点框图"></p><h3 id="1-网络应用体系结构"><a href="#1-网络应用体系结构" class="headerlink" title="1 网络应用体系结构"></a>1 网络应用体系结构</h3><p>​    网络应用在不同的端系统上运行。网络应用通过网络基础设施提供的服务，应用进程彼此之间通信。例如web应用，web服务器软件和浏览器软件通信。</p><p>​    在网络核心中没有应用层软件，网络核心中没有应用层功能，网络应用只在端系统上存在，更方便网络应用的开发和部署。</p><p><img src="/2021/04/10/jsjwl02/image-20210410165338821.png" alt="网络应用开发和部署"></p><h4 id="1-1-客户机-服务器结构（Client-Server，C-S）"><a href="#1-1-客户机-服务器结构（Client-Server，C-S）" class="headerlink" title="1.1 客户机/服务器结构（Client-Server，C/S）"></a>1.1 客户机/服务器结构（Client-Server，C/S）</h4><p><img src="/2021/04/10/jsjwl02/image-20210410165429573.png" alt="C/S"></p><ul><li><p>服务器</p><ul><li>一直运行</li><li>永久性访问地址/域名</li><li>利用大量服务器实现可拓展性，服务器场，数据中心进行扩展</li></ul></li><li><p>客户机</p><ul><li>主动与服务器通信，使用服务器提供的服务</li><li>间接性接入网络</li><li>可能是动态IP地址</li><li>不会与其他客户机直接通信</li></ul></li><li><p>缺点：</p><ul><li>可拓展性差，服务器有限的服务能力，链路带宽限制；</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210401180447699.png" alt="C/S拓展性差"></p><ul><li>可靠性差，依赖于服务器</li></ul></li></ul><blockquote><p>通常，如果仅有一台服务器处理所有的请求，那么服务器系统将很快变得不堪重负，为此，配备大量主机的数据中心常被用于创建强大的虚拟的服务器，一个数据中心可以有数十万台服务器，它们需要供电和维护，同时服务提供商还需要支付不断出现的互联和带宽费用，以及发送和接收到达/来自数据中心的数据。</p></blockquote><ul><li>应用例子：Web、FTP、Telnet和电子邮件</li></ul><h4 id="1-2-P2P结构"><a href="#1-2-P2P结构" class="headerlink" title="1.2 P2P结构"></a>1.2 P2P结构</h4><p><img src="/2021/04/10/jsjwl02/image-20210410165453140.png" alt="P2P"></p><ul><li><p>（几乎）无永远在线的服务器</p></li><li><p>任意端系统/节点之间可以直接通讯</p></li><li><p>每一节点既是客户端又是服务器</p><ul><li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li></ul><blockquote><p>比如在文件共享应用中，对等方可能通过向文件的原始拥有者发出请求而产生工作量，但是对等方也有可能通过为其他对等方传送文件而为原始拥有者分担压力。</p></blockquote></li><li><p>节点间接性接入网络且可能改变IP地址</p></li><li><p>优点：高度可拓展性</p></li><li><p>缺点：</p><ul><li>ISP友好。大多数住宅ISP受制于非对称带宽应用，也就是下载比上传要多得多。但是P2P视频和文件分发应用改变了从服务器到住宅ISP的上传流量，因而给ISP带来压力；</li><li>安全性。因为其高度的分布和开放式，P2P应用也可能给安全带来挑战；</li><li>激励。如何说服用户资源向应用提供带宽、存储和计算资源？这是一个问题；</li></ul></li><li><p>应用例子：目前，流量密集型应用都是P2P体系结构的。这些应用包括文件共享（例如BitTorrent）、协助下载（例如迅雷）、因特网电话（例如Skype）和IPTV(例如迅雷看看)。</p></li></ul><h4 id="1-3-混合结构"><a href="#1-3-混合结构" class="headerlink" title="1.3 混合结构"></a>1.3 混合结构</h4><ul><li><p>Napster</p><ul><li><p>文件传输使用P2P结构</p><ul><li>任意Peer节点之间</li></ul></li><li><p>文件的搜索采用C/S结构–集中式</p><ul><li>每个结点向中央服务器登记自己的资源信息</li><li>每个结点向中央服务器提交查询请求，查找相应资源</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210331234531220.png" alt="Napster"></p></li></ul></li><li><p>例：即时通信</p><ul><li>在线检测：集中<ul><li>当用户上线时，向中心服务器注册其IP地址</li><li>用户与中心服务器联系，以找到其在线好友的位置</li></ul></li><li>两个用户之间聊天：P2P</li></ul></li></ul><h3 id="2-网络应用的进程间通信"><a href="#2-网络应用的进程间通信" class="headerlink" title="2 网络应用的进程间通信"></a>2 网络应用的进程间通信</h3><p>在操作系统中，实际进行通信的是进程而不是应用程序。<br>当进程运行在同一个端系统上时，它们使用进程间通信机制相互通信；而进程间通信的规则是由端系统上的操作系统确定的。<br>当进程运行在不同的端系统上时，它们通过跨越计算机网络的报文相互通信；发送进程产生报文并且向网络中发送，接收进程接收报文并对此作出响应（不响应也是一种响应）。</p><h4 id="2-1-进程间通信基本概念"><a href="#2-1-进程间通信基本概念" class="headerlink" title="2.1 进程间通信基本概念"></a>2.1 进程间通信基本概念</h4><ul><li><p>网络应用的基础：进程间通信</p></li><li><p>进程：主机上运行的程序</p></li><li><p>同一主机上运行的进程之间如何通信？</p><ul><li>进程间通信控制（由操作系统提供）</li></ul></li><li><p>不同主机上运行的进程间如何通信？</p><ul><li><p>按照网络应用协议进行消息交换（例如报文交换）</p><ul><li>借助传输层提供的服务</li></ul></li><li><p>同时使用OS提供的通信服务</p></li></ul></li><li><p>客户机进程/服务器进程</p><ul><li>客户机进程：发起通信的进程</li><li>服务器进程：等待通信请求的进程</li></ul><blockquote><p> 在P2P架构的应用中也存在客户机进程、服务器进程这样进程关系。在某些P2P应用中，一个进程可能既是客户也是服务器，因为在一个文件共享应用中，一个进程的确既能请求文件也能发送文件。所以从进程所扮演的角色来区分是客户进程还是服务器进程不够精确，所以我们从发起通信的顺序来定义它们：<strong>在给定的一对进程之间，首先发起通信的进程被标记为客户进程，在会话开始时等待联系的进程被称为服务器进程。</strong></p></blockquote></li></ul><h4 id="2-2-分布式进程间通信实现机制"><a href="#2-2-分布式进程间通信实现机制" class="headerlink" title="2.2 分布式进程间通信实现机制"></a>2.2 分布式进程间通信实现机制</h4><p><img src="/2021/04/10/jsjwl02/image-20210410172627902.png" alt="分布式进程间通信"></p><ul><li><p>分布式进程间通信需要解决的问题：</p><ul><li><p>问题1：进程标示和寻址问题（服务用户） </p><ul><li>对进程进行编址：进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）<ul><li>主机：唯一的32位IP地址<ul><li>仅仅有IP地址不能够唯一标识一个进程：在一台端系统上有很多进程在运行</li></ul></li><li>端口号（Port Numbers）（16bit）：确定是哪一个进程</li><li>所采用的传输层协议：TCP or UDP<ul><li>常见端口号例子：<ul><li>HTTP：TCP 80</li><li>Mail：TCP 25</li><li>FTP：TCP 2</li></ul></li></ul></li></ul></li><li>一个进程：用IP+port标示 端节点(end-point)</li><li>本质上，一对主机进程之间的通信由2个端结点构成</li></ul></li><li><p>问题2：传输层-应用层提供服务是如何（服务） </p><ul><li>传输层提供的服务-应用层与传输层层间接口必须要传递的信息：<ul><li>要传输的报文（对本层来说：SDU）</li><li>谁传的：对方的应用进程的标示：IP+TCP（UDP）端口号</li><li>传给谁：对方的应用进程的标示：对方的IP+TCP（UDP）端口号</li></ul></li><li>传输层实体（TCP或者UDP实体）根据应用层传输的信息进行TCP报文段（或者UDP报文段）的封装<ul><li>源端口号，目标端口号等封装为报文段头部，数据等封装到报文段负载</li><li>并将IP地址（源IP，目标IP）往下交给IP实体，用于封装IP数据报</li></ul></li></ul><p>​    如果每次两个主机的两个特定应用程序一段时间内多次进行信息传递或者进行信息传递比较频繁，每次传递信息都需要传递自己的和对方的IP+端口号，都携带如此多信息，太繁琐易错，不便于管理。</p><p>​    所以在应用层和传输层之间引入了Socket，用一个本地代号来标识通信的双方（TCP）或者单方（UDP）。就像是OS打开文件返回的句柄一样，对句柄的操作，就是对文件的操作，而不用再使用这个文件的目录名、文件名。</p><ul><li><p><strong>TCP socket：</strong></p><p>TCP服务，两个进程之间的通信需要通信之前就建立连接<font color="#A9A9A9">(两个进程通信会持续一端时间，通信关系稳定)</font>。可以用一个整数即Socket（类似句柄）来在本地对两个应用实体之间的通信关系进行标示。这样两个应用实体之间通信时，穿过层间接口的信息就只需要包含所需传递的消息数据。</p><p>对于使用面向连接服务（TCP）的应用而言，TCP socket是4元组的一个具有<strong>本地意义</strong><font color="#A9A9A9">(只有本地的应用层和传输层知道)</font>的标示。4元组：源IP，源端口，目标IP，目标端口</p><blockquote><p>TCP socket唯一的指定了一个会话（两个进程之间的会话关系）</p><p>应用使用这个标示与远程的应用进程进行通信，不必在每个报文的发送都指定这4元组。</p><p>简单，便于管理；同时减少穿过层间的数据</p></blockquote></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411094526831.png" alt="TCP socket"></p><ul><li><strong>UDP socket：</strong></li></ul><p>UDP服务，两个进程之间的通信之前无需建立连接<font color="#A9A9A9">（每个报文都是独立传输的，前后报文可能给不同的分布式进程）</font>。因此只能用一个整数表示本应用实体的标示。</p><p>UDP socket是2元组（源IP，源端口）的一个具有本地意义的标示。UDP套接字指定了应用所在的一个端结点（end-point）。</p><p>在发送数据报时，采用创建好的本地套接字（标示ID），就不必再发送每个报文中自己的ip和port。但是传输报文时，必须提供目的IP和目的端口号。接受报文的时候，传输层同样需要上传对方的IP和端口号。</p><p><img src="/2021/04/10/jsjwl02/image-20210411100319390.png" alt="UDP socket"></p><ul><li><p>套接字（Socket）</p><ul><li>进程向套接字发送报文或者从套接字接受报文</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411100617644.png" alt="套接字"></p></li><li><p>传输层-应用层提供服务的：</p><p>位置：层间界面的SAP （TCP/IP ：socket） </p><p>形式：应用程序接口API （TCP/IP ：socket API）</p></li></ul></li><li><p>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）</p><ul><li><p>定义应用层协议，协议定义了运行在不同端系统上的应用进程如何相互交换报文</p><ul><li>交换报文类型：请求和应答报文</li><li>各种报文类型的语法：报文中的各字段及其描述</li><li>字段的语义：即字段取值的含义</li><li>进程何时、如何发送报文及对报文进行响应的规则</li></ul><blockquote><p>应用协议仅是应用的一个组成部分。例如：web应用包含了HTTP协议，web客户端，web服务器，HTML等</p></blockquote><blockquote><p>实体：仅仅和网络交互有关的、遵守协议的且是运行中的软件模块和硬件模块被称为实体。</p></blockquote><blockquote><p>公开协议：</p><p>​    由RFC文档定义</p><p>​    允许互操作</p><p>​    如HTTP，SMTP</p><p>专用（私有）协议：</p><p>​    协议不公开，如：Skype</p></blockquote></li><li><p>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等；</p><ul><li>传输基础设施向进程提供API<ul><li>传输协议的选择</li><li>参数的设置</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="3-Internet传输层服务模型"><a href="#3-Internet传输层服务模型" class="headerlink" title="3 Internet传输层服务模型"></a>3 Internet传输层服务模型</h3><ul><li><p>问题4：应用需要传输层提供什么样的服务？如何描述传输层的服务？</p><h4 id="3-1-描述传输层指标"><a href="#3-1-描述传输层指标" class="headerlink" title="3.1 描述传输层指标"></a>3.1 描述传输层指标</h4><ul><li>数据丢失率<ul><li>有些应用（如音频）能容忍一定比例以下的数据丢失</li><li>有些应用则要求100%的可靠数据传输（如文件）</li></ul></li><li>延迟<ul><li>一些应用出于有效性的考虑，对数据传输有严格的时间限制<ul><li>Internet电话、交互式游戏</li></ul></li></ul></li><li>吞吐<ul><li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li></ul></li><li>一些应用能充分利用可供使用的吞吐（弹性应用）</li><li>安全性</li><li>机密性   完整性   可认证性（鉴别）</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411102836028.png" alt="常见应用对传输服务的要求"></p><h4 id="3-2-Internet传输层提供什么样的服务？"><a href="#3-2-Internet传输层提供什么样的服务？" class="headerlink" title="3.2 Internet传输层提供什么样的服务？"></a>3.2 Internet传输层提供什么样的服务？</h4><ul><li>TCP服务：<ul><li>可靠的传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐保证和安全保证</li><li>面向连接：要求通信前在客户端进程和服务器进程之间建立连接。（仅在端系统实现连接，而不对网络核心提供服务和维护）</li></ul></li><li>UDP服务<ul><li>不可靠数据传输</li><li><strong>不</strong>提供的服务：可靠，流量控制，拥塞控制，时间，带宽保障，建立连接</li><li>为什么要有UDP？（UDP存在的必要性）<ul><li>能够区分不同的进程，而IP服务不能</li><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li><li>无需建立连接，省去了建立连接时间，适合事务性的应用</li><li>不做可靠性的工作，例如检错重发，适合那些对实时 性要求比较高而对正确性要求不高的应用<ul><li> 因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发等）</li></ul></li><li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据 <ul><li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li></ul></li></ul></li></ul><img src="/2021/04/10/jsjwl02/image-20210411103950494.png" alt="Internet应用及其应用层协议和传输协议"></li><li>安全TCP<blockquote><p>TCP和UDP都没有加密，明文通过互联网传输信息，甚至密码，安全性很低</p></blockquote><ul><li>SSL<pre><code>在TCP之上实现，提供加密的TCP连接。保证私密性。数据完整性以及端到端的鉴别。SSL在应用层中：应用采用SSL库形式与应用一起运行，然后SSL库使用TCP通信SSL socket API：应用通过API将明文交给socket，SSL将其加密后在互联网传输</code></pre><blockquote><p>例如https，HTTP协议运行在SSL之上，SSL运行在TCP协议之上，实现了web应用的安全可靠传输。</p></blockquote></li></ul><img src="/2021/04/10/jsjwl02/image-20210411132650541.png" alt="进程、SSL与TCP关系"></li></ul></li></ul><h3 id="4-特定网络应用以及协议"><a href="#4-特定网络应用以及协议" class="headerlink" title="4 特定网络应用以及协议"></a>4 特定网络应用以及协议</h3><h4 id="4-1-Web与HTTP"><a href="#4-1-Web与HTTP" class="headerlink" title="4.1 Web与HTTP"></a>4.1 Web与HTTP</h4><ul><li><p>一些术语：</p><ul><li>web页：由一些对象组成</li></ul><blockquote><p>web页含有一个基本的HTML文件，该基本HTML文件本身就是一个对象，其中还包含其他对象的引用（以链接URL的形式）</p></blockquote><ul><li><p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p></li><li><p>通过URL对每个对象进行引用</p><ul><li><p>每个对象都有唯一的URL进行标识</p></li><li><p>访问协议：用户名、口令字、端口等</p></li><li><p>URL格式：<img src="/2021/04/10/jsjwl02/image-20210411112003845.png" alt="URL格式"></p><ul><li><p>协议名：以什么协议来访问对象（HTTP/FTP等）</p></li><li><p>用户:口令：访问对象用什么用户:口令访问</p><blockquote><p>有的网站支持匿名访问，无需提供用户:口令</p></blockquote></li><li><p>端口：如果未指定端口，会采用协议的默认端口号（如HTTP的默认端口80）</p></li></ul></li></ul></li></ul></li></ul><h5 id="4-1-1-HTTP概况"><a href="#4-1-1-HTTP概况" class="headerlink" title="4.1.1 HTTP概况"></a>4.1.1 HTTP概况</h5><ul><li><p>HTTP ：超文本传输协议</p><ul><li>Web的应用层协议</li><li>客户/服务器模式<ul><li>客户：请求、接受和显示Web对象的浏览器</li><li>服务器：对请求进行响应，发送对象的Web服务器</li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411131620123.png" alt="HTTP协议"></p><ul><li><p>HTTP 1.0 ：RFC 1945</p><p>HTTP 1.1 ：RFC 2068</p></li><li><p>使用TCP</p><ol><li>客户发起一个与服务器的TCP连接（建立socket），端口号为80</li><li>服务器接受客户的TCP连接</li><li>在浏览器（HTTP客户端）与Web服务器（HTTP服务器server）交换HTTP报文（应用层协议报文）</li><li>TCP连接关闭</li></ol><p><img src="/2021/04/10/jsjwl02/image-20210411134148359.png" alt="HTTP建立连接示意图"></p></li><li><p>HTTP是无状态的</p><ul><li>服务器并不维护关于客户的任何信息，即交换过HTTP报文以后就断开TCP连接，不会存储客户信息，客户之后对报文更改与服务器无关</li><li>优点：简单；无状态的服务器能够支持更多的客户端</li></ul><blockquote><p>维护状态的协议很复杂！</p><ul><li>必须维护历史信息（状态）</li><li>如果服务器/客户端死机，它们的状态信息可能不一致，而必须维护成信息一致的</li></ul></blockquote></li></ul></li></ul><h5 id="4-1-2-HTTP连接"><a href="#4-1-2-HTTP连接" class="headerlink" title="4.1.2 HTTP连接"></a>4.1.2 HTTP连接</h5><ul><li><p>非持久HTTP</p><ul><li>每个TCP连接在服务器最多发送一个对象后就会关闭，也就是每个TCP只传送一个请求报文和响应报文</li><li>下载多个对象需要多个TCP连接</li><li>HTTP/1.0使用非持久连接</li></ul><p>假设用户输入URL:<a href="http://www.someschool.edu/someDept/home.index">www.someSchool.edu/someDept/home.index</a>  (假设这个web中包含文本和10个jpeg图像的引用)</p><p><img src="/2021/04/10/jsjwl02/image-20210411140316400.png" alt="非持久HTTP"></p><ul><li><p>响应时间模型</p><ul><li>往返时间RTT（round-trip-time）</li></ul><p>一个小的分组从客户端到服务器，再回到客户端的时间（RTT包括分组的传播时延、排队时延、处理时延（因为是短分组，所以其传输时延可不计））</p><ul><li>响应时间：<ul><li>一个RTT用来发起TCP连接</li><li>一个RTT用来HTTP请求并等待HTTP响应</li><li>文件传输时间</li><li>共2RTT+传输时间</li></ul></li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411140846744.png" alt="响应时间模型"></p><ul><li>非持久HTTP的缺点：<ul><li>每个对象传输要2个RTT+传输时间</li><li>操作系统必须为每个TCP连接分配资源</li><li>但浏览器通常打开并行TCP连接，以获取引用对象</li></ul></li></ul></li><li><p>持久HTTP</p><ul><li>服务器在发送响应后，仍保持TCP连接；在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li><li>多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</li><li>HTTP/1.1默认使用持久连接</li><li>持久HTTP分为非流水方式的持久HTTP和流水方式的持久HTTP<ul><li>非流水方式（no-pipeline）的持久HTTP<ul><li>客户端只能在收到前一个响应后才能发出新的请求</li><li>每个引用对象花费一个RTT</li></ul></li><li>流水方式（pipeline）的持久HTTP、<ul><li>HTTP/1.1的默认方式</li><li>客户端遇到一个引用对象就立即产生一个请求</li><li>所以引用（小）对象只花费一个RTT是可能的</li></ul></li></ul></li></ul></li></ul><h5 id="4-1-3-HTTP报文格式：请求报文和响应报文"><a href="#4-1-3-HTTP报文格式：请求报文和响应报文" class="headerlink" title="4.1.3 HTTP报文格式：请求报文和响应报文"></a>4.1.3 HTTP报文格式：请求报文和响应报文</h5><ul><li><p>两种类型的HTTP报文：请求、响应</p></li><li><p>HTTP请求报文：</p><ul><li><p>ASCII    -具有可读性</p><p><img src="/2021/04/10/jsjwl02/image-20210411143216745.png" alt="HTTP请求报文"></p><ul><li><p>一个请求报文具有至少一行的内容。请求报文的第一行称为请求行，其后继的各行被称为首部行。</p></li><li><p>请求行包含三个内容：方法字段、URL字段、HTTP版本；其中方法字段可为：GET、POST、PUT、DELETE、HEAD等。URL字段里可以传递请求对象的标志。</p></li><li><p>首部行包含是否在发送完响应报文后关闭TCP连接的Connection、请求的主机地址（该头部信息被Web高速缓存所要求）Host、客户端用户代理（浏览器）版本User-agent、可接受的语言Accept-language等头部信息；</p></li><li><p>在首部行之后一个空行，之后便是请求的“实体体”。</p><blockquote><p>该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等。</p><p>值得注意的是，表单也不一定必须使用POST方法。</p><ul><li>方法类型：</li></ul><p>HTTP/1.0 : GET、POST、HEAD</p><p>HTTP/1.1 : GET、POST、HEAD、PUT、DELETE</p><p>get，实体主体为空，上载内容会显示在URL的参数中。服务器将会用一个HTTP响应报文进行响应，报文中包含请求的对象。</p><p>Head类似于get方法，服务器将会用一个HTTP报文进行响应，但是不返回请求对象，经常用作调试跟踪。</p><p>put方法允许用户上传对象到URL指定的Web服务器上指定的路径。</p><p>Delete方法允许用户或应用程序删除URL指定的Web服务器上的对象。</p></blockquote></li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411144156506.png" alt="请求报文格式"></p><ul><li>HTTP请求报文也可向服务器提交内容，提交表单输入有如下两种方式：<ul><li>Post方式<ul><li>网页通常包括表单输入</li><li>提交的内容包含在实体体（entity body）中，然后被提交到服务器</li></ul></li><li>URL方式<ul><li>方法：GET</li><li>表单输入通过请求行的URL字段上载</li><li>例如：<a href="http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3%E9%80%9A%E8%BF%87URL%E4%B8%AD%E7%9A%84">http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3通过URL中的</a> 参数：wd，cl 参数值：XX+YY+zzz，3 形式信息</li></ul></li></ul></li></ul></li><li><p>HTTP响应报文</p><ul><li><p>ASCII    -具有可读性</p><p><img src="/2021/04/10/jsjwl02/image-20210411145603153.png" alt="HTTP响应报文"></p><ul><li><p>响应报文总体上也分三个部分，第一部分是状态行，包含HTTP版本、状态以及状态信息等内容；第二部分是首部行，包含发送日期、服务器类型、上一次修改请求资源的时间、内容的长度和内容的类型等内容。第三部分是实体主体。实体主体包含请求对象本身。</p></li><li><p>首部行中的内容的长度是用于描述HTTP消息实体的传输长度，为了让应用层区分报文的边界</p><blockquote><p>因为TCP向上层应用层传递的是字节流，是不区分边界的，因此应用层要通过Content-Length来维护报文的界限</p></blockquote></li><li><p>首部行的Date是从文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。</p></li><li><p>HTTP响应状态码：位于服务器→客户端的响应报文中的首行</p></li></ul><blockquote><p>一些状态码的例子：</p><p>200 OK </p><p>&emsp;请求成功，请求对象包含在响应报文的后续部分 </p><p>301 Moved Permanently </p><p>&emsp;请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定</p><p>&emsp;客户端软件自动用新的URL去获取对象 </p><p>400 Bad Request </p><p>&emsp;一个通用的差错代码，表示该请求不能被服务器解读 </p><p>404 Not Found</p><p>&emsp;请求的文档在该服务上没有找到 </p><p>505 HTTP Version Not Supported</p></blockquote></li></ul></li></ul><h5 id="4-1-4-用户与服务器的交互：Cookie"><a href="#4-1-4-用户与服务器的交互：Cookie" class="headerlink" title="4.1.4 用户与服务器的交互：Cookie"></a>4.1.4 用户与服务器的交互：Cookie</h5><ul><li><p>HTTP是无状态协议，但是Web站点为了识别用户身份或者限制用户访问的时间或者将用户访问的内容同用户身份相关联，Web站点可以使用Cookie技术实现用户信息存储。</p></li><li><p>Cookie技术包含4个组成部分</p><ol><li>HTTP响应报文里增加一个关于Cookie的首部行；</li><li>HTTP请求报文里增加一个关于Cookie的首部行；</li><li>用户端系统中保留一个Cookie文件，由用户的浏览器维护和管理；</li><li>在Web站点后端数据库建立Cookie和用户身份的关联；</li></ol><p><img src="/2021/04/10/jsjwl02/image-20210411161744290.png" alt="Cookies:维护状态"></p><blockquote><p>用户首次访问web服务器时，HTTP请求报文中无Cookie，在访问时，服务器会为用户建立Cookie，然后响应报文中首部行会有Cookie标示内容，用户收到响应报文后，用户浏览器会将cookie保存在本地cookies文件中，然后之后用户再次HTTP请求报文都会携带有cookie。</p></blockquote></li><li><p>Cookies能带来功能：</p><ul><li>用户验证</li><li>购物车</li><li>推荐</li><li>用户状态（Web e-mail）等</li></ul></li><li><p>如何维护状态：</p><ul><li>协议端节点：在多个事物上，发送端和接收端维持状态</li><li>cookies：HTTP报文携带状态信息</li></ul></li><li><p>Cookies的隐私泄露问题：</p><ul><li>Cookies允许站点知道许多关于用户的信息，站点可能将它知道的东西卖给第三方</li><li>使用重定向和cookie的搜索引擎还能知道用户更多的信息<ul><li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li></ul></li><li>广告公司从站点获得信息</li></ul></li></ul><h5 id="4-1-5-Web缓存（代理服务器）"><a href="#4-1-5-Web缓存（代理服务器）" class="headerlink" title="4.1.5 Web缓存（代理服务器）"></a>4.1.5 Web缓存（代理服务器）</h5><p>Web缓存器也被称为代理服务器，它代表初始web服务器来满足HTTP请求。它具有自己的存储空间，并在存储空间里保持有最近请求过的对象的副本；可以通过配置浏览器，将所有指向初始服务器的请求首先指向代理服务器。</p><p>当代理服务器收到一个HTTP请求后，它将检查本地是否缓存过该对象，如果缓存过该对象，将检查是否过期，如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p><ul><li>目标：不访问原始服务器，就满足客户的请求</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411163153908.png" alt="代理服务器示意图"></p><ul><li><p>Web缓存既是客户端又是服务器</p></li><li><p>通常缓存是由ISP安装（大学、公司、居民区ISP）</p></li><li><p>Web缓存优点：</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internet接入链路上的流量，减少原始服务器负担</li><li>互联网大量使用了缓存，可以使较弱的ICP也能够有效提供内容</li></ul></li><li><p>缓存示例：</p></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411163746751.png" alt="正常情况"></p><blockquote><p>接入链路流量强度接近于1，所以排队延迟（d<sub>queue</sub> = (I/(1-I))*(L/R)）将会很大，用户访问的时间因此而很大。</p></blockquote><p><img src="/2021/04/10/jsjwl02/image-20210411163945732.png" alt="更快的接入链路"></p><p><img src="/2021/04/10/jsjwl02/image-20210411163959897.png" alt="安装本地缓存1"></p><p><img src="/2021/04/10/jsjwl02/image-20210411164018449.png" alt="安装本地缓存2"></p><h5 id="4-1-6-条件GET方法"><a href="#4-1-6-条件GET方法" class="headerlink" title="4.1.6 条件GET方法"></a>4.1.6 条件GET方法</h5><p>高速缓存器的使用，带来很多好处，但是有一个问题就是代理服务器对缓存对象的管理：如何确保所请求的对象是最新的？</p><p>其实HTTP提供了一种机制，允许缓存器证实其使用的对象是最新的，这种机制就是条件GET方法。</p><p>使用条件GET方法只需在使用GET方法的时候，增加一个If-Modified-Since首部行，其对应的内容是一个时间，如果所请求的资源在指定日期后(与Last-Modified比较)被修改了，那么服务器将返回新的对象，否则服务器将返回一个包含空实体主体的报文。这样代理服务器就可以确认缓存是否过期了。</p><ul><li>目标：即时更新缓存中的对象拷贝。<ul><li>如果缓存拷贝需要更新，返回 HTTP/1.0  200  OK，实体主体中包含对象</li><li>如果缓存拷贝不需要更新，则返回HTTP/1.0  304  Not Modified，且实体主体中不包含对象</li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411165916546.png" alt="条件Get方法"></p><h4 id="4-2-FTP：文件传输协议"><a href="#4-2-FTP：文件传输协议" class="headerlink" title="4.2 FTP：文件传输协议"></a>4.2 FTP：文件传输协议</h4><p><img src="/2021/04/10/jsjwl02/image-20210411194534840.png" alt="FTP"></p><ul><li>FTP应用包括FTP用户接口、FTP客户端、本地文件系统、界面等。而FTP服务器有服务器的文件系统，守候在21号端口，等待连接。</li><li>FTP协议中，用户通过FTP客户端可以向远程主机上传输文件或从远程主机接受文件</li><li>客户/服务器模式<ul><li>客户端：发起传输的一方</li><li>服务器：远程主机</li></ul></li><li>FTP：RFC 959</li><li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议<ul><li>客户端通过控制连接获得身份确认</li><li>客户端通过控制连接发送命令浏览远程目录</li></ul></li><li>但是，当服务器收到一个文件传输命令时，服务器打开第二个TCP数据连接（服务器20号端口到客户端的数据连接）来传输文件。</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411202825985.png" alt="FTP端口连接"></p><ul><li><p>控制连接：带外（out of band）传送</p></li><li><p>FTP带内是传输数据的（20号端口），带外是传送控制信号（21号端口）</p></li><li><p>FTP是有状态的协议</p><ul><li>FTP服务器维护用户的状态信息：当前路径、用户账户与控制连接对应</li></ul></li><li><p>FTP命令、响应都是ASCII文本形式</p><ul><li>FTP命令：在控制连接上以ASCII文本方式传送</li></ul><blockquote><p>USER username</p><p>PASS password </p><p>LIST：请服务器返回远程主机当前目录的文件列表 </p><p>RETR filename：从远程主机的当前目录检索文件 (gets) </p><p>STOR filename：向远程主机的当前目录存放文件(puts)</p></blockquote><blockquote><p>注：</p><p>上载：客户端向服务器发数据</p><p>下载：服务器向客户端发数据</p></blockquote><ul><li>返回码：</li></ul><blockquote><p>状态码和状态信息（同HTTP）</p><p>331 Username OK,  password required </p><p>125 data connection  already open;  transfer starting </p><p>425 Can’t open data  connection </p><p>452 Error writing  file</p></blockquote></li></ul><h4 id="4-3-EMail"><a href="#4-3-EMail" class="headerlink" title="4.3 EMail"></a>4.3 EMail</h4><ul><li><p>email的3个主要组成部分：</p><ul><li><p>用户代理</p><ul><li>又名“邮件阅读器”</li><li>撰写、编辑和阅读邮件，如Outlook、Foxmail等</li><li>输出和输入邮件保存在服务器上</li></ul></li><li><p>邮件服务器</p><ul><li>邮件服务器中输出报文队列保存并依此发送待发送邮件报文</li><li>邮箱中管理和维护发送给用户的邮件</li><li>邮件服务器之间的SMTP协议：发送Email报文<ul><li>客户端：发送方邮件服务器</li><li>服务器：接受方邮件服务器</li></ul></li></ul><blockquote><p>一封邮件发送过程：<br>用户通过用户代理撰写邮件，然后通过用户代理经SMTP协议发送邮件到邮件服务器中的输出邮件队列中。该服务器作为发送方邮件服务器，通过SMTP协议找到并将邮件接收方邮件服务器。接受方服务器将接受到的邮件放到服务器中相应用户邮箱中，目标用户再经用户代理通过拉取邮件的协议（POP3等）拉取邮箱中自己收到的邮件。</p></blockquote><blockquote><p>用户代理向服务器发邮件，用户是client，邮件服务器是sever。</p><p>发送方邮件服务器向接收方邮件服务器发邮件，发送方邮件服务器是client，接收方邮件服务器是sever。</p></blockquote><blockquote><p>发送方的邮件服务器必须能处理接收方服务器的故障，如果发送方的服务器不能将邮件交付给接收方的服务器，发送方将在一个报文队列中保持该邮件并之后再尝试发送报文，如果一直失败，服务器就会删除该邮件，并以邮件方式通知发送用户。</p></blockquote></li><li><p>简单邮件传输协议：SMTP</p><ul><li><p>SMTP使用TCP在客户端和服务器之间传送报文，端口号为25</p></li><li><p>SMTP为直接传输：从发送方服务器到接收方服务器，邮件并不在中间的某个服务器停留</p></li><li><p>传输的3个阶段：</p><ul><li>握手</li><li>持续传输报文</li><li>关闭</li></ul><blockquote><p>SMTP是持续连接：如果发送邮件服务器有多个邮件，它可以通过同一TCP连接连续发送这些邮件。</p></blockquote><blockquote><p>所以邮件有时是先存储在发送队列的，等到多个邮件一起传递，以此来减少服务器耗能等。</p></blockquote></li><li><p>命令/响应交互</p></li><li><p>命令：ASCII文本</p></li></ul></li><li><p>响应：ASCII   状态码和状态信息</p></li><li><p>SMTP要求报文（首部和主体）必须为7位ASCII码</p></li></ul><blockquote><p>命令、响应和邮件本身的内容的组成字符必须是在7位ASCII码字符集描述的范围之内的。超过7位ASCII码字符集表示的范围的数据不能通过SMTP传输。</p></blockquote><blockquote><p>这将限制SMTP的数据传输，即在SMTP传输邮件之前，需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应ASCII码邮件解码还原成多媒体数据。HTTP传输不需要将多媒体数据编码成ASCII码。</p></blockquote><ul><li>SMTP服务器使用CRLF.CRLF决定报文的尾部<img src="/2021/04/10/jsjwl02/image-20210411205241273.png" alt="EMail原理"></li><li>SMTP与HTTP比较：<ul><li>HTTP：拉（pull） SMTP：推（push）</li><li>两者都是ASCII形式的命令、响应交互、状态码</li></ul><blockquote><p>但是传输的内容，HTTP可以不一定是用ASCII码，而SMTP只能用ASCII码字符。</p></blockquote><ul><li>HTTP：每个对象封装在各自的响应报文中，一个响应报文只能有一个对象</li><li>SMTP：多个对象包含在一个报文中</li></ul><blockquote><p>解释：</p><p>例如一个web页面对象，其中有多个对象（图片等）的引用，HTTP的一个响应报文中只有这一个web页面对象的数据，其他对象需要通过引用再去经过各自的响应报文传递过来。</p><p>而如果是一个邮件，其中有图片、音频等多个对象，SMTP将会将这个邮件的所有内容包含到同一个报文中，一次传递过来。</p></blockquote><ul><li><p>SMTP：交换Email报文的协议     </p></li><li><p>RFC 822：邮件内容文本报文的标准：</p><ul><li><p>首部行：包含</p><ul><li>To:           发送给谁<ul><li>From:      来自谁</li></ul></li><li>Subject:   主题</li><li>还有 cc  （抄送）等</li></ul></li><li><p>主体</p><ul><li>报文，只能是ASCII码字符</li></ul></li></ul></li></ul><blockquote><p>这个是邮件报文内容的格式，与SMTP命令格式不同</p></blockquote><ul><li>多媒体拓展的报文格式<ul><li>MIME：多媒体邮件扩展（multimedia mail extension）   RFC  2045，2056</li></ul><blockquote><p>用来拓展SMTP传输内容，使得SMTP能够传输ASCII码字符之外的字符。</p></blockquote><ul><li>在报文首部用额外的行声明MIME内容类型</li></ul>  <img src="/2021/04/10/jsjwl02/image-20210412145320300.png" alt="MIME"><blockquote><p>将不在ASCII码值的内容用规定的格式（如base64）编码为较长的7位ASCII码值，然后通过SMTP传送。接受端受到该数据后再经过解码，获得原来的数据，以此实现拓展ASCII码传输内容。</p></blockquote></li></ul></li></ul></li><li><p>EMail协议</p><p><img src="/2021/04/10/jsjwl02/image-20210412145541524.png" alt="Email协议"></p><ul><li><p>发送的协议：简单邮件传输协议：SMTP</p><blockquote><p>用户代理到发送方邮件服务器</p><p>发送方邮件服务器传送到接受方的邮件服务器</p></blockquote></li><li><p>拉取的协议：POP3，IMAP，HTTP   </p><blockquote><p>用于邮件访问</p></blockquote></li></ul></li><li><p>邮件访问协议</p><ul><li>邮件访问协议：从服务器访问邮件<ul><li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul><li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li></ul><blockquote><p>POP3是一个非常简单的协议，因为简单，所以功能有限；POP3使用端口110来建立TCP连接（SMTP使用端口25）；POP3按照三个阶段进行工作：特许、事务处理和更新；在特许阶段，用户代理发送密码和用户名，进行身份鉴别；第二阶段，用户代理取回报文，同时还可以做删除、取消删除等标记或者统计邮件信息；第三个阶段是在用户退出后，POP3结束会话，删除被标记的邮件。</p></blockquote></li><li>IMAP：Internet邮件访问协议（Internet Mail Access  Protocol）[RFC 1730] <ul><li><p>与POP3类似作用，但是多了更多特性 (更复杂) </p><blockquote><p>POP3协议无法为用户提供邮件分类管理的功能，虽然用户可以通过将邮件下载到本地，然后由用户代理程序做分类管理，但是处理的结果是无法同步到其他查看设备上的。为了解决这一问题，IMAP诞生了。IMAP是一个邮件访问协议，比POP3要复杂的多。</p><p>（远程）IMAP将每一份邮件和一个一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX相关联。收件人可以将邮件移到新创建的文件夹，阅读邮件，删除邮件等。IMAP允许用户在不同文件夹里移动邮件并且查询邮件。</p><p>值得注意的是，IMAP服务器维护了IMAP会话的用户状态信息（目录名、报文ID与目录名之间映射等状态信息），但是POP3并不在会话时维护状态信息。</p><p>IMAP协议还允许用户代理获取报文组件而不是报文整体。</p></blockquote></li><li><p>在服务器上处理存储的报文</p></li></ul></li><li>HTTP：Hotmail , Yahoo! Mail等 <ul><li>方便</li></ul><blockquote><p>这种方式主要是指，用户使用HTTP协议和邮件服务器通信。用户代理就是普通的浏览器，但是，邮件服务器之间还是使用SMTP协议的</p></blockquote></li></ul></li><li>POP3协议<ul><li><p>用户确认阶段 </p><ul><li>客户端可发出命令： <ul><li>user: 申明用户名</li><li>pass: 口令 </li></ul></li><li>服务器响应 <ul><li>+OK</li><li>-ERR </li></ul></li></ul></li><li><p>事物处理阶段, </p><ul><li>客户端可以发送以下命令： <ul><li><p>list: 报文号列表 </p></li><li><p>retr: 根据报文号检索报文 </p></li><li><p>dele: 删除 </p><blockquote><p>一个需要注意的是，POP3用户代理可以使用两种事务处理模式：一种是下载并删除，另一种是下载保留；POP3代理发出的命令和其工作模式相关；下载并删除的方法存在的问题是，如果用户在一台设备上查看了邮件（下载了邮件）后，邮件将被删除，那么在其他设备上将无法查看邮件；这给用户带来一定的不便。使用下载保存方式，则用户下载邮件后，邮件还在服务器上。</p></blockquote></li><li><p>quit</p></li></ul></li></ul></li><li><p>POP3在会话中是无状态的</p><blockquote><p>POP3只是维护用户谁登录了，需要获取哪些邮件，而不会维护用户对邮件目录等操作的状态。</p></blockquote><blockquote><p>在用户代理与邮箱服务器之间的POP3会话期间，该POP3服务器保留了一些状态信息，特别是标记了哪些用户报文被标记为删除了。但是POP3服务器并不在POP3会话过程中去携带和实现状态信息，大大简化了POP3的服务。</p></blockquote></li></ul></li></ul></li></ul><h4 id="4-4-DNS（Domain-Name-System）"><a href="#4-4-DNS（Domain-Name-System）" class="headerlink" title="4.4 DNS（Domain Name System）"></a>4.4 DNS（Domain Name System）</h4><ul><li><p>提供给应用使用的应用</p></li><li><p>DNS的必要性 </p><ul><li><p>IP地址标识某一时刻网络中唯一的主机、路由器，但IP地址不好记忆，不便人类使用(没有意义)，人类一般倾向于使用一些有意义的字符串来标识 Internet上的设备。 </p><blockquote><p>例如：<a href="mailto:&#x71;&#x7a;&#x68;&#101;&#110;&#x67;&#64;&#x75;&#x73;&#116;&#x63;&#46;&#x65;&#x64;&#x75;&#46;&#99;&#110;">&#x71;&#x7a;&#x68;&#101;&#110;&#x67;&#64;&#x75;&#x73;&#116;&#x63;&#46;&#x65;&#x64;&#x75;&#46;&#99;&#110;</a> 所在的邮件服务器<br> <a href="http://www.ustc.edu.cn/">www.ustc.edu.cn</a> 所在的web服务器 </p></blockquote></li><li><p>存在着“字符串”—IP地址的转换的必要性</p></li><li><p>DNS提供的主要服务：人类用户提供要访问机器的“字符串”名称，然后由DNS负责转换成为二进制的网络地址</p></li></ul><blockquote><p>DNS通常被其他应用层协议使用，比如：HTTP、SMTP和FTP等。这些协议在正式工作以前，首先利用DNS提供的服务，将主机名转换为IP地址，可以发现的是，DNS为用户带来方便的同时，也为网络应用带来额外的时延——查询DNS服务器的时延。</p></blockquote></li><li><p>DNS系统需要解决的问题 </p><ul><li><p>问题1：如何命名设备？</p><ul><li>用有意义的字符串：好记，便于人类使用</li><li>解决一个平面命名的重名问题：采用层次化命名方式</li></ul><blockquote><p>一个平面进行命名会出现问题：设备越来越多，不重复的命名越来越难实现</p></blockquote></li><li><p>问题2：如何完成名字到IP地址的转换？ </p><ul><li>一台设备集中解决域名到IP地址转换实际上难以实现，因为服务器负载有限，易出现错误。所以采用分布式的数据库维护和响应名字查询。</li></ul></li><li><p>问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作？</p></li></ul></li><li><p>DNS 的历史</p></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210413165837322.png" alt="ARP ANET"></p><ul><li><p>DNS的主要思路</p><ul><li><p>分层的、基于域的命名机制</p></li><li><p>若干分层的DNS服务器组成的分布式数据库完成名字到IP地址的转换</p></li><li><p>运行在UDP之上端口号为53的应用服务</p><blockquote><p>采用UDP原因：DNS只是需要通过域名查询相应的IP地址，采用TCP需要耗费很长时间进行建立联系。</p></blockquote></li><li><p>DNS属于Internet的核心功能，但以端系统的应用层协议实现的</p><ul><li>Internet在网络边缘处理互联网的复杂功能</li></ul></li></ul></li><li><p>DNS主要目的：</p><ul><li><p>实现主机域名-IP地址的转换(name/IP translate) </p></li><li><p>其它目的 </p><ul><li>主机别名到规范名字的转换：Host aliasing </li></ul><blockquote><p>应用服务（例如某一域名<a href="http://www.xxx.com）往往是大量的服务器进行提供维护，对于每一台服务器都有一个规范的主机名来标识，例如：某一地点的某一机房的某一机柜的某一刀片服务器+该域名，为了便于使用，这大量的服务器都被称为www.xxx.com，这个就是主机别名。">www.xxx.com）往往是大量的服务器进行提供维护，对于每一台服务器都有一个规范的主机名来标识，例如：某一地点的某一机房的某一机柜的某一刀片服务器+该域名，为了便于使用，这大量的服务器都被称为www.xxx.com，这个就是主机别名。</a></p><p>规范主机名为了便于管理，而主机别名是为了便于访问。</p></blockquote><blockquote><p>所以DNS往往是实现：主机别名转换为规范主机名再到IP地址的转换</p></blockquote><ul><li>邮件服务器别名到邮件服务器的正规名字的转换：Mail server  aliasing </li></ul><blockquote><p>DNS同样也提供邮件服务器主机名和别名的转换服务，实际上，公司的邮件服务器和Web服务器（如<a href="http://www.xxx.com)可以使用相同的主机别名,就可以使用该公司域名来作为邮件服务器地址(www.xxx.com);mx记录允许一个公司的邮件服务器和web服务器使用相同的主机名./">www.xxx.com）可以使用相同的主机别名，就可以使用该公司域名来作为邮件服务器地址（www.xxx.com）；MX记录允许一个公司的邮件服务器和Web服务器使用相同的主机名。</a></p></blockquote><ul><li>负载均衡：Load Distributio</li></ul><blockquote><p>应用服务（例如某一域名<a href="http://www.xxx.com)往往是大量的服务器进行提供维护,这些服务器都使用同一个主机别名(www.xxx.com),然后该域名收到请求以后,dns将会按照一定原则和依据将任务分配给这些服务器中的一台服务器来提供服务,从而达到负载均衡./">www.xxx.com）往往是大量的服务器进行提供维护，这些服务器都使用同一个主机别名（www.xxx.com），然后该域名收到请求以后，DNS将会按照一定原则和依据将任务分配给这些服务器中的一台服务器来提供服务，从而达到负载均衡。</a></p></blockquote></li></ul></li><li><p>问题1：DNS名字空间</p><ul><li><p>DNS域名结构</p><ul><li><p>一个层面命名设备会有很多重名</p></li><li><p>NDS采用层次树状结构的命名方法实现DNS域名命名</p></li><li><p>Internet 根被划为几百个顶级域(top lever domains) </p><ul><li><p>通用的(generic)</p><p> .com; .edu ; .gov ; .int ; .mil ; .net ; .org .firm ; .hsop ; .web ; .arts ; .rec ; </p></li><li><p>国家的(countries) </p></li></ul><p>.cn ; .us ; .nl ; .jp </p></li><li><p>每个(子)域下面可划分为若干子域(subdomains) </p></li><li><p>树叶是主机</p></li><li><p>根名字服务器有13个</p></li></ul><blockquote><p>如果只有一个，可能出现一个宕机，整个DNS不能使用</p></blockquote><p><img src="/2021/04/10/jsjwl02/image-20210413183435963.png" alt="DNS根名字服务器"></p><ul><li>DNS域名结构</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210413183541230.png" alt="DNS名字空间"></p><ul><li><p>域名(Domain Name)</p><ul><li><p>从本域往上，直到树根</p></li><li><p>中间使用“.”间隔不同的级别</p><blockquote><p>例如: ustc.edu.cn   auto.ustc.edu.cn        <a href="http://www.auto.ustc.edu.cn/">www.auto.ustc.edu.cn</a></p></blockquote></li><li><p>域的域名:可以用于表示一个域  </p><blockquote><p>从树枝往上找</p></blockquote></li><li><p>主机的域名:一个域上的一个主机</p><blockquote><p>从树叶往上找</p></blockquote></li></ul></li><li><p>域名的管理</p><ul><li>一个域管理其下的子域<ul><li>.jp被划分为ac.jp    co.jp</li><li>.cn被划分为edu.cn   com.cn</li></ul></li><li>创建一个新的域，必须征得它所属域的同意</li></ul></li><li><p>域与物理网络无关</p><ul><li>域遵从组织界限，而不是物理网络<ul><li>一个域的主机可以不在一个网络</li><li>一个网络的主机不一定在一个域</li></ul></li><li>域的划分是逻辑的，而不是物理的</li></ul></li></ul></li></ul></li><li><p>问题2：如何解析域名为IP地址问题-名字服务器(Name Server)</p><ul><li><p>只采用一个服务器作为名字服务器的问题</p><ul><li>可靠性问题：单点故障</li><li>扩展性问题：通信容量</li><li>维护问题：远距离的集中式数据库 </li></ul></li><li><p>所以采用分布式服务器来解决域名解析为IP地址的问题，大致来说，存在三种DNS服务器：根DNS服务器、顶级域DNS服务器和权威DNS服务器</p></li><li><p>顶级域(TLD)服务器：</p><ul><li>负责顶级域名（如com, org, net,  edu和gov）和国家级的顶级域名（如cn, uk, fr, ca,  jp ）<ul><li>Network solutions 公司维护com TLD服务器 </li><li>Educause公司维护edu TLD服务器</li></ul></li></ul></li><li><p>将名字空间划分为若干互不相交的区域(zone) </p><ul><li>区域的划分有区域管理者自己决定</li><li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li><li>名字服务器：<ul><li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record) ，组织机构的DNS服务器，提供组织机构服务器可以访问的主机和IP之间的映射</li><li>名字服务器允许被放置在区域之外，以保障可靠性</li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210413185005911.png" alt="Zone"></p><ul><li><p>区域名字服务器通过维护资源记录来维护区域内各域名和主机之间的信息数据</p><ul><li><p>资源记录(resource records) </p><ul><li><p>作用：维护 域名-IP地址(其它)的映射关系</p></li><li><p>位置：Name Server的分布式数据库中 </p></li><li><p>RR格式: (domain_name, ttl, type,class,Value) </p><ul><li><p>Domain_name: 域名 </p></li><li><p>Ttl: time to live : 生存时间</p><blockquote><p>某一域名的RR在它的权威服务器中是无限大的，而在其他服务器中缓冲记录是有限的，一段时间后会将该域名RR删除。</p><p>缓冲目的是为了提高效率<br>删除缓存目的是为了维护一致性</p></blockquote></li><li><p>Class 类别 ：对于Internet，值为IN </p></li><li><p>Value 值：可以是数字，域名或ASCII串等，存的是域名对应的IP地址</p></li><li><p>Type 类别：资源记录的类型</p></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210413195554207.png" alt="Type类型举例"></p></li></ul></li></ul></li></ul></li><li><p>DNS大致工作过程</p><ul><li>应用调用解析器（resolver）</li><li>解析器作为客户向Local Name Server发出查询报文（封装在UDP段中）</li><li>Name Server返回响应报文（name/ip）</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210413211302361.png" alt="DNS大致工作过程"></p></li><li><p>本地名字服务器（Local Name Server）</p><ul><li>并不严格属于DNS服务器的层次结构<ul><li>一般是距离主机最近的名字服务器</li></ul></li><li>每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器<ul><li>也称为“默认名字服务器”</li></ul></li><li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器 <ul><li>起着代理的作用，将查询转发到层次结构中去解析主机名</li><li>名字解析过程：<ul><li>目标名字在Local Name Server中<ul><li><p>情况1：查询的名字在Local Name Server区域内部</p></li><li><p>情况2：Local Name Server中有对应主机的缓存(cashing)</p><blockquote><p>缓冲是为了效率，一段时间后会删除缓冲，是为了保持一致性</p></blockquote></li></ul></li><li>当与本地名字服务器不能解析名字时，联系根名字服务器顺着根-TLD 一直找到权威名字服务器<ul><li><p>递归查询</p><ul><li>名字解析负担都放在当前联络的名字服务器上</li><li>问题：根服务器的负担太重</li><li>解决： 迭代查询 （iterated  queries）</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210413234354328.png" alt="递归查询"></p></li><li><p>迭代查询</p><p>主机cis.poly.edu 想知道主机 gaia.cs.umass.edu 的IP地址</p><ul><li>根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</li><li>最后由权威名字服务器给出解析结果</li><li>当前联络的服务器给出可以联系的服务器的名字“我不知道这个名字，但 可以向这个服务器请求”</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210413234546250.png" alt="迭代查询"></p></li></ul></li></ul></li></ul></li></ul></li><li><p>DNS协议报文</p><ul><li><p>DNS协议的查询和响应报文的报文格式相同，靠标识位flags来判断查询/应答</p><ul><li><p>报文首部：</p><p><img src="/2021/04/10/jsjwl02/image-20210413235044154.png" alt="DNS报文"></p><blockquote><p>ID是为了实现流水线并行查询DNS</p></blockquote><p><img src="/2021/04/10/jsjwl02/image-20210413235107155.png" alt="DNS报文内容"></p></li></ul></li></ul></li><li><p>提高性能：缓存 </p><ul><li>一旦名字服务器学到了一个映射，就将该映射缓存起来 </li><li>根服务器通常都在本地服务器中缓存着 <ul><li>使得根服务器不用经常被访问 </li></ul></li><li>目的：提高效率 </li><li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</li><li>解决方案：TTL（默认2天）</li></ul><blockquote><p>TTL结束后，删除缓存的内容</p></blockquote></li></ul></li><li><p>问题3：维护问题：新增一个域怎么维护？</p><ul><li><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名 和 域名服务器的地址</p></li><li><p>在新增子域 的名字服务器上运行名字服务器，负责本域 的名字解析： 名字-&gt;IP地址 </p><blockquote><p>例子：在com域中建立一个“Network Utopia” </p><ul><li>到注册登记机构注册域名networkutopia.com <ul><li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字 和IP地址</li><li>登记机构在com TLD服务器中插入两条RR记录: (networkutopia.com, dns1.networkutopia.com, NS) (dns1.networkutopia.com, 212.212.212.1, A) </li></ul></li><li>在networkutopia.com的权威服务器中确保有<ul><li>用于Web服务器的<a href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a></li><li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li></ul></li></ul></blockquote></li></ul></li><li><p>攻击DNS，DNS总的来说比较健壮</p><ul><li><p>DDoS 攻击</p><ul><li><p>对根服务器进行流量轰炸攻击：发送大量ping </p><ul><li>没有成功 </li><li>原因１：根目录服务器配置了流量过滤器，防火墙 </li><li>原因２：Local DNS 服务器缓存了TLD服务器的IP地址,  因此无需查询根服务器</li></ul></li><li><p>向TLD服务器流量轰炸攻击 ：发送大量查询 </p><ul><li>可能更危险 </li><li>效果一般，大部分DNS缓存了TLD</li></ul><blockquote><p><font color="red">这里不是很明白，为什么缓存了顶级域名就不会访问根域名了？迭代、递归不都是先访问根域名服务器吗？然后才知道访问哪个顶级域名吗？本地域名服务器可以知道应该访问哪个顶级域名服务器吗？</font></p><p>先访问根域名服务器是为了获得顶级域名服务器的IP地址，本地域名服务器中有相应的缓存即对应IP地址，就可以直接去访问顶级域名，而不用再去访问根域名服务器。</p></blockquote></li></ul></li><li><p>重定向攻击</p><ul><li>中间人攻击 <ul><li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li></ul></li><li>DNS中毒<ul><li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li></ul></li><li>技术上较困难：分布式截获和伪造</li></ul></li><li><p>利用DNS基础设施进行DDoS</p><ul><li>伪造某个IP进行查询， 攻击这个目标IP</li><li>查询放大，响应报文比查询报文大 </li><li>效果有限</li></ul></li></ul></li></ul><h4 id="4-5-P2P应用"><a href="#4-5-P2P应用" class="headerlink" title="4.5 P2P应用"></a>4.5 P2P应用</h4><ul><li><p>纯P2P架构</p><ul><li>没有（或极少）一直运行的服务器</li><li>任意端系统都可以直接通信</li><li>利用peer的服务能力</li><li>Peer节点间歇上网，每次IP地址都有可能变化</li><li>例子：<ul><li>文件分发（BitTorrent）</li><li>流媒体（KanKan）</li><li>VoIP（Skype）</li></ul></li></ul></li><li><p>文件分发：C/S vs P2P</p><p>问题：从一台服务器分发文件（大小F）到N个peer需要多少时间？</p><blockquote><p>Peer节点上下载能力是有限的资源</p></blockquote><p><img src="/2021/04/10/jsjwl02/image-20210414082756872.png" alt="文件分发"></p><ul><li><p>C/S模式的文件分发时间</p><ul><li><p>服务器传输： 都是由服务器发送给peer，服务器必须顺序 传输（上载）N个文件拷贝: </p><ul><li>发送一个copy: F/u<sub>s</sub></li><li>发送N个copy： NF/u<sub>s</sub> </li></ul></li><li><p>客户端: 每个客户端必须下载一个文件拷贝 </p><ul><li><p>d<sub>min</sub> = 客户端最小的下载速率 </p></li><li><p>下载带宽最小的客户端下载的时间：F/d<sub>min</sub></p><blockquote><p>下载带宽最小的客户端是所有客户端中下载所耗费时间最长的</p></blockquote></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210414083126229.png" alt="C/S模型文件分发时间"></p><blockquote><p>客户端较少的时候，下载带宽最小的客户端下载时间是瓶颈；客户端较大时，服务器上载能力是瓶颈。</p></blockquote></li></ul></li><li><p>P2P模式文件分发时间</p><ul><li><p>服务器传输：最少需要上载一份拷贝</p><ul><li>发送一个拷贝的时间：F/u<sub>s</sub> </li></ul></li><li><p>客户端: 所有客户端最终都需要下载一个拷贝 </p><ul><li>最小下载带宽客户单耗时：F/d<sub>min</sub></li></ul></li><li><p>NF文件上载时间：所有客户端总体下载量为NF，而服务器和其他所有Peer节点的总的最大上载带宽是：<br>$$<br>u_s + \Sigma u_i<br>$$</p><blockquote><p>除了服务器可以上载，其他所有的peer节点都可以上载</p></blockquote><p>所以NF文件上载时间：<br>$$<br>\frac {NF}{u_s+\Sigma u_i}<br>$$</p></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210414085223889.png" alt="P2P文件分发"></p><blockquote><p>每个Peer节点的加入，请求资源的节点在增加，同时服务能力也在增加</p></blockquote><p><img src="/2021/04/10/jsjwl02/image-20210414085509474.png" alt="C/S  vs  P2P"></p></li></ul></li><li><p>P2P文件共享两大问题：</p><ul><li><p>如何定位所需资源</p></li><li><p>如何处理对等方的加入与离开</p></li><li><p>可能的方案：P2P系统的管理模式</p><ul><li><p>非结构化P2P</p><ul><li>Peer节点邻居之间有协作关系则有边，然后各个Peer和他们的协作关系构成了应用层逻辑上的网络Overlay（覆盖网）</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210414091248820.png" alt="非结构化覆盖网"></p><blockquote><p>Peer节点之间构成的协作关系（即边）是随机的</p></blockquote><ul><li><p>非结构化的P2P可以分为：</p><ul><li><p>集中式目录</p><p>将每个Peer节点有什么资源和节点上下线等信息作为目录存储在一个服务器上，用户需要什么资源，然后向服务器请求，服务器告知哪个Peer有这个资源，然后用户再与该Peer节点建立联系下载文件，此时用户是客户端，而拥有资源的服Peer节点是服务器。下载完成后，该用户也成为拥有该资源的服务器。</p><blockquote><p>例：Alice在其笔记本电脑上运行P2P客户端程序，间歇性地连接到 Internet，每次从其 ISP得到新的IP地址，假设Alice请求“双截棍.MP3” ，应用程序显示其他有“ 双截棍.MP3” 拷贝的对等方。Alice选择其中一个对等方，如Bob。文件就会从Bob’s PC传送到 Alice的笔记本上：HTTP 。当Alice下载后，其他用户也可以从Alice处下载“ 双截棍.MP3”。</p><p>此外，Alice在下载Bob的内容时，他也可以同时作为其他人的服务器上载自己拥有的其他文件。</p></blockquote><p><img src="/2021/04/10/jsjwl02/image-20210414114834512.png" alt="集中式目录"></p><blockquote><p>文件传输是分散的，但是目录定位内容是高度集中在目录服务器的</p></blockquote><ul><li>集中式目录中存在的问题：<ul><li>单点故障</li><li>性能瓶颈</li><li>侵犯版权</li></ul></li></ul></li><li><p>完全分布式</p><ul><li><p>目录查询、文件传输都采用P2P形式</p></li><li><p>例子：Gnutella</p><ul><li><p>全分布式，没有中心服务器</p><p>开放文件共享协议</p><p>许多Gnutella客户端实现了Gnutella协议</p><p>​    类似HTTP有许多的浏览器</p></li><li><p>覆盖网络：图 </p><p>如果X和Y之间有一个 TCP连接，则二者之间存在一条边</p><p>所有活动的对等方和边就是覆盖网络</p><p>边并不是物理链路，而是传输连接</p><p>给定一个对等方，通常所连接的节点少于10个</p></li><li><p>协议</p></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210414203646040.png" alt="Gnutella协议"></p><blockquote><p>查询文件方式：洪泛（flooding），A向它的所有邻居B、C、D进行查询，然后B、C、D在向自己的所有邻居进行查询，一直向下延续</p></blockquote><ul><li>Gnutella的Peer节点的加入</li></ul><ol><li>新加入的对等方X的Gnutella客户端应用必须首先携带某些已经在覆盖网络中的其他对等方的IP地址：使用可用对等方列表</li></ol><blockquote><p>自己维持一张对等方列表（经常开机的对等方的IP） 联系维持列表的Gnutella站点 </p></blockquote><ol start="2"><li><p>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</p></li><li><p>X向Y发送一个Ping报文，Y向自己连接的节点转发该Ping报文</p></li><li><p>所有收到Ping报文的对等方以Pong报文响应X，回复自己的IP地址、共享文件的数量及总字节数等信息</p></li><li><p>X收到许多Pong报文，然后它能建立起与其他节点的TCP连接</p></li></ol><ul><li>Gnutella的Peer节点的离开</li></ul><p>该节点向邻居发送离开的报文，然后它的邻居会将该节点的信息删除，然后选择一个覆盖网络其他的节点补充为新的邻居，从而维持覆盖网络的服务能力</p></li></ul></li><li><p>混合式</p><ul><li>例子：KaZaA</li><li>每个对等方要么是一个组长，要么隶属于一个组长 <ul><li>对等方与其组长之间有 TCP连接 </li><li>组长对之间有TCP连接</li></ul></li><li>组长跟踪其所有的孩子的内容</li><li>组长与其他组长联系<ul><li>转发查询到其他组长</li><li>获得其他组的数据拷贝</li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210414205526041.png" alt="混合式"></p><ul><li><p>查询方式</p><ul><li>每个文件有一个散列标识码和一个描述符 </li></ul><blockquote><p><img src="/2021/04/10/jsjwl02/image-20210414210256736.png" alt="组长记录组内目录"></p></blockquote><ul><li>客户端向其组长发送关键字查询</li></ul><blockquote><p>通过关键字与描述匹配查询相应文件</p></blockquote><ul><li><p>组长用匹配进行响应：</p><ul><li>对每个匹配：元数据、散列标识码和IP地址</li></ul></li><li><p>如果组长将查询转发给其他组长，其他组长也以匹配进行响应</p></li><li><p>客户端选择要下载的文件</p><ul><li>向拥有文件的对等方发送一个带散列标识码的HTTP请求</li></ul><blockquote><p>通过唯一的散列标识码进行确定需要下载的文件</p></blockquote></li></ul></li></ul></li></ul></li></ul></li><li><p>结构化的P2P（DHT 基于分布式散列表的结构化管理）</p><blockquote><p>Overlay是结构化的，例如环、树等，可以进一步深入拓展等</p></blockquote><ul><li>例如：环状结构化P2P</li></ul><p>每个节点映射成唯一的16位的哈希值作为标识，按照哈希值大小有序地首尾相接构成环状有序拓扑。文件同样映射成唯一16位的哈希值，然后按照0-88标识的文件由88节点管理、89-100文件由100节点管理等形式来有序管理文件，查询时只需按照文件标识即可实现快速查询。</p><p><img src="/2021/04/10/jsjwl02/image-20210414225432242.png" alt="环状结构化P2P"></p></li></ul></li></ul></li><li><p>非结构化P2P应用实例：BitTorrent</p><ul><li>文件被分为一个个块256KB，然后每个客户端有各自的bitmap，bitmap用来标识文件的有无（有为“1”，无为“0”）</li><li>网络中这些Peers发送接受文件块，相互服务</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210414210942114.png" alt="BitTorrent"></p><blockquote><p>tracker记录了洪流中节点的IP地址等信息。新的Peer进来，需要向tracker登记自己信息，同时获得洪流中其他节点的IP信息。</p></blockquote><ul><li><p>新Peer加入torrent：  </p><ul><li><p>新Peer一开始没有块，但是将会通过向其他节点请求来累积文件块 </p><blockquote><p>前几次请求是随机请求，后面几次优先请求稀缺的块，为了保证稀缺的块不会由于其拥有者的下线而丢失，同时，稀缺的块被其他Peer节点所需要，通过提高上载速率来获得更好的下载速率（由下面的tit-for-tat机制决定）</p></blockquote></li><li><p>向跟踪服务器注册，获得peer节点列表，和部分peer 节点构成邻居关系 (“连接 ”) </p></li></ul></li><li><p>当peer下载时，该peer可以同时向其他节点提供上载服务</p></li><li><p>扰动churn: peer节点可能会上线或者下线，但是整体来说维持着文件内容的充分性，P2P服务能力稳定</p></li><li><p>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</p></li><li><p>请求块： </p><ul><li>在任何给定时间，不同 peer节点拥有一个文件块的子集</li><li>周期性的，各个Peer节点向邻居询问他们拥有哪些块的信息 ，即交换bitmap，然后各个Peer向邻居请求它希望的块，稀缺的块</li></ul></li><li><p>发送块：一报还一报 tit-for-tat</p><ul><li><p>每个节点同时只能向4个peer发送块提供服务，来保证提供的带宽较大，而其他peer将被该节点阻塞 (将不会从Alice处获得服务)</p><ul><li><p>所以节点会选择给自己提供带宽较大的、服务较多的4个Peer邻居作为自己服务对象，并且每10秒重新评估一次前4位来优先服务</p><blockquote><p>这种机制有利于激励其他节点提高自己的上载速率，从而提高整个洪流的服务能力</p></blockquote></li><li><p>同时每隔30秒：将随机选择其他peer节点，向这个节点发送块，来 “优化疏通” 这个节点。</p><blockquote><p>原因是新选择的节点所包含的资源有可能是自己需要的，尝试提高给他的服务，有可能有利于之后自己收到它的服务质量的提高</p></blockquote></li></ul></li></ul></li></ul></li></ul><h4 id="4-6-CDN"><a href="#4-6-CDN" class="headerlink" title="4.6 CDN"></a>4.6 CDN</h4><ul><li><p>视频流量：占据着互联网大部分的带宽。</p><p>Netflix，Youlube:占据37%，16%的ISP下行流量<br><del>1B YouTube用户，</del>75M Netflix用户</p><p>挑战:规模性-如何服务者~1B 用户？</p><p>​    单个超级服务器无法提供服务</p><p>挑战:异构性</p><pre><code>不同用户拥有不同的能力（例如:有线接入和移动用户；带宽丰富和受限用户)</code></pre><p>解决方案:分布式的，应用层面的基础设施</p></li><li><p>多媒体：视频</p><ul><li><p>视频：固定速度显示的图像序列，e.g. 24 images/sec</p></li><li><p>网络视频特点：</p><ul><li>高码率：&gt;10x于音频，高的网络带宽需求</li><li>可以被压缩</li><li>90%以上的网络流量是视频 </li></ul></li><li><p>数字化图像：像素的阵列</p></li><li><p>每个像素被若干bits表示</p></li><li><p>编码：使用图像内和图像间的冗余来降低编码的比特数 </p><ul><li>空间冗余（图像内） </li><li>时间冗余（相邻的图像间）</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210415125750098.png" alt="编码方式示例"></p><ul><li><p>编码标准：</p><p>CBR: (constant bit  rate): 以固定速率编码 </p><p>VBR: (variable bit  rate): 视频编码速率随时间的变化而变化</p></li></ul></li></ul></li><li><p>存储视频的流化服务</p><p>对于视频文件，并不是将文件全部下载完成以后才进行播放，而是边下载边播放</p></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210415125951929.png" alt="场景示例"></p><ul><li><p>多媒体流化服务示例：DASH</p><ul><li>DASH: Dynamic, Adaptive Streaming over HTTP</li></ul><blockquote><p>通过HTTP协议传送数据</p></blockquote><ul><li><p>可以解决不同客户端、不同网络情况、不同需求的问题</p></li><li><p>服务器: </p><ul><li>将视频文件分割成多个块</li><li>每个块独立存储，编码于不同码率（8-10种）</li></ul><blockquote><p>对于每一个块都可以有不同版本，可以是不同清晰度的、不同编码方式的、不同码率的</p></blockquote><ul><li>告示文件（manifest file）: 提供不同块的URL </li></ul><blockquote><p>告示文件提供块的数量、格式、版本以及相应的URL等信息</p></blockquote></li><li><p>客户端: </p><ul><li><p>先获取告示文件</p><blockquote><p>客户端会周期性地测量服务器到客户端的带宽</p></blockquote></li><li><p>查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围</p><ul><li>会根据带宽、客户端需求等信息选择下载块的什么版本等，使得播放流畅质量相对高</li><li>如果带宽足够，选择最大码率的视频块</li><li>会话中的不同时刻，可以切换请求不同的编码块（取决于当时的可用带宽等）</li></ul></li></ul></li><li><p>“智能”客户端：客户端自适应决定</p><ul><li>什么时候去请求块 (不至于缓存挨饿，或者溢出)</li><li>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块) </li><li>哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求) </li></ul></li></ul></li><li><p>挑战：服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)？</p><ul><li><p>选择1：单个的、大的超级服务中心“mega-server” </p><ul><li>服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿 </li><li>“二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差） </li><li>单点故障点，性能瓶颈</li></ul><blockquote><p>一个服务器的服务能力有限</p></blockquote><ul><li>周边网络的拥塞</li></ul><blockquote><p>对于网络拥塞问题，服务器难以解决</p></blockquote><ul><li>评价：相当简单，但是这个方法不可扩展</li></ul></li><li><p>选项2：通过CDN（Content distribution networks），全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p><ul><li><p>CDN部署节点方式：</p><ul><li>enter deep：将CDN服务器深入到许多接入网，将缓存节点部署到local ISP<ul><li>更接近用户，服务质量高，但是数量多，离用户近所以管理困难</li><li>例子：Akamai, 1700个位置</li></ul></li><li>bring home：部署在少数(10个左右)关键位置，如将服务器簇安装于POP附近（离若干1<sup>st</sup> ISP POP较近）<ul><li>采用租用线路将服务器簇连接起来，部署节点少还保证质量较高，但是跳数较多</li><li>例子：Limelight</li></ul></li></ul></li><li><p>CDN实现内容加速示例：</p><ul><li>提供内容服务者首先将内容的备份通过专用链路拷贝到CDN服务商部署的缓存节点中，然后用户申请资源时，先向内容提供者的源服务器请求，然后源服务器提供给他一个告示文件（manifest file），告示文件中有用户所需内容在各缓存节点中的版本信息、URL存储位置等信息，然后用户客户端可以根据网络情况、距离、用户需求等就近从CDN缓存中获取文件块。</li><li>用户从CDN中请求内容<ul><li>重定向到最近的拷贝，请求内容 </li><li>如果网络路径拥塞，可能选择不同的拷贝</li></ul></li></ul></li><li><p>CDN是应用层协议，是在网络边缘来加速网络运营服务、来提供服务的     over the top</p></li><li><p>OTT （over the top）面临的挑战：在拥塞的互联网上复制 </p><ul><li>从哪个CDN节点中获取内容？</li><li>用户在网络拥塞时的行为？</li><li>在哪些CDN节点中存储什么内容？</li></ul></li></ul></li></ul></li></ul><h3 id="5-Socket（套接字）编程"><a href="#5-Socket（套接字）编程" class="headerlink" title="5 Socket（套接字）编程"></a>5 Socket（套接字）编程</h3><p><img src="/2021/04/10/jsjwl02/image-20210329092824673.png" alt="网络程序设计接口"></p><ul><li><p>网络应用是在应用层中运行的应用进程之间的通信。应用进程使用<strong>传输层提供的服务</strong>才能够交换报文，实现<strong>应用层协议</strong>，实现应用</p></li><li><p>应用进程与底层协议之间的桥梁：应用编程接口API</p><p>API就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。应用进程通过API将控制权交给操作系统，操作系统调用相应过程，然后将结果传输回应用进程。</p><blockquote><p>传输层以及以下的四层往往由操作系统控制。</p></blockquote></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210329094838806.png" alt="五层结构"></p><ul><li><p>典型的应用编程接口：</p><ul><li>Berkeley UNIX操作系统   套接字接口（socket interface），简称套接字（socket）</li><li>Windows 上     基于socket的稍不同的API：  WINSOCK</li><li>AT&amp;T为其UNIX系统V定义的一种API：TLI（Transport Layer Interface）</li></ul></li><li><p>TCP/IP  应用进程使用Socket API访问传输服务</p><p>地点：界面上的SAP（socket）方式： Socket API  </p><p>socket: 分布式应用进程之间的门，传输层协议提供的端到端 服务接口</p></li><li><p>传输层服务的协议，决定了socket也是两种类型</p><ul><li>TCP：可靠的、字节流的服务</li></ul><blockquote><p>字节流不提供报文的边界区分</p></blockquote><ul><li>UDP：不可靠的（数据UDP数据报）服务</li></ul></li><li><p>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户</p></li></ul><h4 id="5-1-TCP-Socket"><a href="#5-1-TCP-Socket" class="headerlink" title="5.1 TCP Socket"></a>5.1 TCP Socket</h4><ul><li><p>TCP套接字编程</p><ul><li><p>服务器首先运行，等待连接建立 </p></li><li><p>服务器进程必须先处于运行状态：</p><ul><li>创建欢迎socket和对应的一个套接字整数</li><li>和本地端口捆绑</li><li>在欢迎socket上阻塞式等待接收用户的连接</li></ul><blockquote><p>阻塞式，即没有用户连接，则程序停止在该函数，不向下进行</p></blockquote></li><li><p>客户端需要时，将主动和服务器建立连接： </p><ul><li>创建客户端本地套接字（隐式捆绑到本地port）</li><li>然后指定服务器进程的IP地址和端口号，与服务器进程连接</li></ul><blockquote><p>向服务器请求连接时，服务器的响应未到达时，客户端的socket函数也是阻塞状态</p></blockquote></li><li><p>当客户端的连接请求到达服务器时：</p><p>服务器接受来自用户端的请求 ，解除阻塞式等待，返回一个 新的socket（与欢迎socket不 一样），与客户端通信</p><ul><li>允许服务器与多个客户端通信</li><li>使用源IP和源端口来区分不同的客户端</li></ul></li><li><p>连接API调用有效时，客户端与服务器建立了TCP连接</p></li></ul></li><li><p>TCP socket应用示例</p><p>C/S模式的应用样例: </p><ol><li>客户端从标准输入装置读取一行字符，发送给服务器</li><li>服务器从socket读取字符</li><li>服务器将字符转换成大写 ，然后返回给客户端</li><li>客户端从socket中读取一行字符，然后打印出来</li></ol><p>实际上，这里描述了C-S之间交互的动作次序</p><p><img src="/2021/04/10/jsjwl02/image-20210415191855698.png" alt="TCP socket 示例"></p><ul><li><p>socket中涉及的数据结构介绍</p><ol><li>数据结构 sockaddr_in</li></ol><p>IP地址和port捆绑关系的数据结构（标示进程的端节点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> sin_family; <span class="comment">//AF_INET</span></span><br><span class="line">      <span class="comment">/*地址族 简单来说就是底层是使用的哪种通信协议来递交数据的，如 AF_INET 用的是 TCP/IPv4；AF_INET6使用的是 TCP/IPv6；而 AF_LOCAL 或者 AF_UNIX 则指的是本地通信（即本次通信是在当前主机上的进程间的通信），一般用绝对路径的形式来指明*/</span></span><br><span class="line">  u_short sin_port; <span class="comment">//port  端口号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> ;</span><span class="comment">/*IP address, unsigned long*/</span></span><br><span class="line">  <span class="keyword">char</span> sin_zero[<span class="number">8</span>];  <span class="comment">//align  </span></span><br><span class="line">      <span class="comment">/*起对齐作用，为了让其他格式的不同长度IP地址和TCP/IP格式中的IP地址对齐*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>数据结构 hostent</li></ol><p>域名和IP地址的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *h_name;<span class="comment">//主机域名</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;<span class="comment">//主机的一系列别名</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;</span><br><span class="line"><span class="keyword">int</span> h_length;<span class="comment">/*地址的长度*/</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">//存储一系列IP地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作为调用域名解析函数时的参数返回后，将IP地址拷贝到 sockaddr_in的IP地址部分</p></li><li><p>C/S socket 交互：TCP </p><p><img src="/2021/04/10/jsjwl02/TCPsocket.png" alt="TCPsocket交互过程"></p></li></ul><blockquote><p>黑色箭头是TCP的建立连接过程，红色箭头是TCP Socket传输数据</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//argv[]</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server   服务器的信息sockaddr_in结构*/</span> </span><br><span class="line"><span class="keyword">int</span> clientSocket; <span class="comment">/* socket descriptor 客户端socket整数*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry 指针指向hostent的结构体*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];  </span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];  </span><br><span class="line">    <span class="comment">//argv[0]存应用程序本身名字</span></span><br><span class="line">    host = argv[<span class="number">1</span>]; <span class="comment">//argv[1]存服务器域名 字符串</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]); <span class="comment">//argv[2]存服务器端口号 字符串   //atoi()  字符串转为整形</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Create client socket, connect to server</span></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//建立TCP socket</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure 清零sad*/</span>  </span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet 地址族*/</span>  </span><br><span class="line">    sad.sin_port = htons((u_short)port); <span class="comment">//(u_short)  port先转为无符号短整型   然后htons再变成网络次序（大端/小端）</span></span><br><span class="line">    ptrh = gethostbyname(host);  <span class="comment">/* Convert host name to IP address 由域名得到有效IP地址*/</span> </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length);  <span class="comment">//将IP地址拷贝到sad.sin_addr </span></span><br><span class="line">    connect(clientSocket,(struct sockaddr*)&amp;sad,<span class="keyword">sizeof</span>(sad));<span class="comment">//将客户端与服务器建立连接</span></span><br><span class="line">    </span><br><span class="line">    gets(Sentence);<span class="comment">//Get input stream from user 标准input获得用户输入</span></span><br><span class="line">    n=write(clientSocket, Sentence,<span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>); <span class="comment">//Send line to server</span></span><br><span class="line">n=read(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence)); <span class="comment">//Read line from server</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n”,modifiedSentence);</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">close(clientSocket); //Close connection</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server服务器本地的sockaddr_in*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/*client的sockaddr_in */</span></span><br><span class="line"><span class="keyword">int</span> welcomeSocket, connectionSocket; <span class="comment">/* socket descriptor 套接字*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> clientSentence[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>]; </span><br><span class="line">    </span><br><span class="line">port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//Create welcoming socket at port &amp; Bind a local address</span></span><br><span class="line">welcomeSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span> </span><br><span class="line">sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span> </span><br><span class="line">bind(welcomeSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));<span class="comment">//和自己的IP、端口绑定</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Specify the maximum number of clients that can be queued 可以并行10个进程，超过将会拒绝其他连接*/</span></span><br><span class="line">listen(welcomeSocket, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">connectionSocket=accept(welcomeSocket, (struct sockaddr *)&amp;cad, &amp;alen);<span class="comment">//Wait, on welcoming socket for contact by a client</span></span><br><span class="line">n=read(connectionSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line"><span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span> </span><br><span class="line">    n=write(connectionSocket, capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>); <span class="comment">//Write out the result to socket</span></span><br><span class="line">close(connectionSocket); <span class="comment">//End of while loop,loop back and wait for another client connection</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-UDP-Socket"><a href="#5-2-UDP-Socket" class="headerlink" title="5.2 UDP Socket"></a>5.2 UDP Socket</h4><ul><li>UDP：在客户端和服务器之间没有连接 <ul><li>没有握手</li><li>发送端必须在每一个报文中明确地指定目标的IP地址和端口号</li><li>服务器必须从收到的分组中提取出发送端的IP地址和端口号 </li></ul></li><li>UDP：传送的数据可能乱序，也可能丢失。UDP为客户端和服务器提供不可靠的字节组的传送服务。</li><li>UDP交互过程：</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210415232630215.png" alt="UDP socket 交互"></p><blockquote><p>UDP的socket包括socket套接字整数值、自己的IP、自己的端口号，而无对方的IP和端口号</p></blockquote><blockquote><p><font color="red">疑问：是不是UDP不能并行？只有一个Socket</font></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span> </span><br><span class="line"><span class="keyword">int</span> clientSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span> modifiedSentence[<span class="number">128</span>]; </span><br><span class="line"></span><br><span class="line">    host = argv[<span class="number">1</span>]; port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);<span class="comment">//创建客户端 socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine the server&#x27;s address */</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">sad.sin_port = htons((u_short)port); </span><br><span class="line">ptrh = gethostbyname(host);</span><br><span class="line"><span class="comment">/* Convert host name to IP address */</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length); </span><br><span class="line">    <span class="comment">//无connect  客户端socket没有连接到服务器</span></span><br><span class="line">    </span><br><span class="line">gets(Sentence);<span class="comment">//Get input stream from user</span></span><br><span class="line">addr_len =<span class="keyword">sizeof</span>(struct sockaddr); </span><br><span class="line">n=sendto(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>,(struct sockaddr *) &amp;sad, addr_len); <span class="comment">//Send line to server  要指明服务器IP和端口号</span></span><br><span class="line">    </span><br><span class="line">n=recvfrom(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence),(struct sockaddr *) &amp;sad, &amp;addr_len);<span class="comment">//Read line from server 要指明服务器IP和端口号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n”,modifiedSentence); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">close(clientSocket); //Close connection</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line"><span class="keyword">int</span> serverSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>]; </span><br><span class="line"></span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//Create welcoming socket at port &amp; Bind a local address</span></span><br><span class="line"></span><br><span class="line">    serverSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span> </span><br><span class="line">sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span> </span><br><span class="line">bind(serverSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));<span class="comment">//和自己的IP、端口绑定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line"></span><br><span class="line">        n=recvfrom(serverSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence), <span class="number">0</span> (struct sockaddr *) &amp;cad, &amp;addr_len );<span class="comment">//Receive messages from clients</span></span><br><span class="line"><span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span></span><br><span class="line"></span><br><span class="line">        n=sendto(serverSocket , capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>,(struct sockaddr *) &amp;cad, &amp;addr_len); <span class="comment">//Write out the result to socket</span></span><br><span class="line">&#125; <span class="comment">//End of while loop,loop back and wait for another client connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h3><h4 id="6-1-章节整体框架"><a href="#6-1-章节整体框架" class="headerlink" title="6.1 章节整体框架"></a>6.1 章节整体框架</h4><ul><li>应用程序体系结构<ul><li>客户-服务器</li><li>P2P </li><li>混合</li></ul></li><li>应用程序需要的服务品质描述：<ul><li>可靠性、带宽、延时、安全</li></ul></li><li>Internet传输层服务模式 <ul><li>可靠的、面向连接的服务： TCP</li><li>不可靠的数据报：UDP</li></ul></li><li>流行的应用层协议：<ul><li>HTTP</li><li>FTP</li><li>SMTP, POP, IMAP </li><li>DNS </li></ul></li><li>Socket编程</li></ul><h4 id="6-2-复习部分协议内容"><a href="#6-2-复习部分协议内容" class="headerlink" title="6.2 复习部分协议内容"></a>6.2 复习部分协议内容</h4><ul><li>应用层协议报文类型：请求/响应报文：<ul><li>客户端请求信息或服务</li><li>服务器以数据、状态码进行响应 </li></ul></li><li>报文格式： <ul><li>首部：关于数据信息的字段</li><li>数据：被交换的信息</li></ul></li><li>控制报文 vs. 数据报文<ul><li>带内（控制与数据报文一起传输）、带外（控制报文与数据报文不在同一端口传输）</li></ul></li><li>集中式 vs. 分散式</li><li>无状态 vs. 维护状态</li><li>可靠的 vs. 不可靠的报文传输 </li><li>在网络边缘处理复杂性</li><li>一个协议定义了在两个或多个通信实体之间交换报文的格式和次序、以及就一条报文传输和接收或其他事件采取的动作</li></ul><hr><p>终于肝完了，然而我们老师已经讲到了链路层，泪目…  </p><p>之后会加快学习进度 /汗  求支持</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-绪论</title>
      <link href="2021/04/05/jsjwl01/"/>
      <url>2021/04/05/jsjwl01/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-绪论"><a href="#计算机网络-绪论" class="headerlink" title="计算机网络-绪论"></a>计算机网络-绪论</h2><blockquote><ul><li>主要参考书籍：<ul><li>《计算机网络：自顶向下方法》（James F.Kurose、Keith W.Ross)</li></ul></li><li>主要参考视频：<ul><li><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=8">中科大郑烇老师全套《计算机网络》</a></li><li><a href="https://www.bilibili.com/video/BV1Up411Z7hC?p=1&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1598544022&unique_k=eeA2CI">哈尔滨工业大学 计算机网络</a></li><li><a href="https://www.bilibili.com/video/av64605483/">计算机网络微课堂</a></li></ul></li><li>其他参考文献：<ul><li><a href="https://blog.csdn.net/qq_39326472/article/details/88089747?utm_source=app&app_version=4.5.4">计算机网络（自顶向下方法）学习笔记(头秃的女程序员)</a></li></ul></li></ul></blockquote><span id="more"></span><h3 id="1-计算机网络定义"><a href="#1-计算机网络定义" class="headerlink" title="1. 计算机网络定义"></a>1. 计算机网络定义</h3><p>​    计算机网络=通信技术+计算机技术</p><p>​    计算机网络就是一种通信网络。</p><ul><li><p>定义：计算机网络就是互连的、自治的计算机集合。</p><p> 自治-无主从关系 互连-互联互通</p><p>距离远、数量大如何保证互连？通过交换网络互连主机</p></li></ul><h3 id="2-Internet"><a href="#2-Internet" class="headerlink" title="2. Internet"></a>2. Internet</h3><ul><li><p>全球最大的互联网络：Internet<br>ISP(Internet Service Provider)网络互连的“网络之网络”</p></li><li><p>Internet组成：<br>计算设备集合</p><blockquote><p>· 主机（hosts）=端系统（end systems）<br>· 运行各种网络应用</p></blockquote><p>通信链路</p><blockquote><p>光纤，铜缆，无线电，卫星……</p></blockquote><p>分组交换：转发分组（数据包）</p><blockquote><p>路由器（routers）和交换机（switches）</p></blockquote></li><li><p>Internet提供的服务：</p><ul><li>为网络应用提供通信服务的通信基础设施</li></ul><blockquote><p>Web, VoIP, email, 网络游戏, 电子商务, 社交网络, …</p></blockquote><ul><li>为网络应用提供应用编程接口（API）</li></ul><blockquote><p>· 支持应用程序“连接” Internet，发送/接收数据<br>· 提供类似于邮政系统的数据传输服务</p></blockquote></li></ul><h3 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3. 网络协议"></a>3. 网络协议</h3><ul><li><p>协议是计算机网络有序运行的重要保证<br>硬件（主机、路由器、通信链 路等）是计算机网络的基础<br>计算机网络中的数据交换必须遵守事先约定好的规则</p></li><li><p>网络通信：<br>通信主体是“机器”<br>交换“电子化”或 “数字化”消息<br>计算机网络的所有通信过程都必须遵守某种/些规则—协议</p></li><li><p>网络协议(network protocol)，简称为协议 ，是为进行网络中的数据交换而建立的规 则、标准或约定。</p><p>协议规定了通信实体之间所交换的消息的 格式、意义、顺序以及针对收到信息或发 生的事件所采取的“动作”（actions）</p></li><li><p>协议的三要素：<br>语法（Syntax） </p></li></ul><blockquote><p> 数据与控制信息的结构或格式  信号电平 </p></blockquote><p>语义（Semantics） </p><blockquote><p> 需要发出何种控制信息  完成何种动作以及做出何种响应  差错控制  </p></blockquote><p>  时序（Timing） </p><blockquote><p> 事件顺序  速度匹配</p></blockquote><ul><li><p>Internet协议标准</p><p>RFC: Request for Comments </p><p>IETF:互联网工程任务组（ Internet Engineering Task  Force）</p></li></ul><h3 id="4-计算机网络的结构"><a href="#4-计算机网络的结构" class="headerlink" title="4. 计算机网络的结构"></a>4. 计算机网络的结构</h3><h4 id="4-1-计算机网络的结构"><a href="#4-1-计算机网络的结构" class="headerlink" title="4.1 计算机网络的结构"></a>4.1 计算机网络的结构</h4><ul><li>网络边缘</li></ul><blockquote><p>主机<br>网络应用</p></blockquote><ul><li>接入网络，物理介质</li></ul><blockquote><p>有线或无线通信链路</p></blockquote><ul><li>网络核心（核心网络）</li></ul><blockquote><p>互联的路由器（或分组转发设备）<br>网络之网络</p></blockquote><h4 id="4-2-网络边缘"><a href="#4-2-网络边缘" class="headerlink" title="4.2 网络边缘"></a>4.2 网络边缘</h4><ul><li>主机（端系统）<ul><li>位于“网络边缘”</li><li>运行网络应用程序</li></ul></li></ul><blockquote><ul><li>客户/服务器（client/server）应用模型<ul><li>客户发送请求，接受服务器响应</li></ul></li><li>对等（peer-peer，P2P）应用模型<ul><li>无（或不仅依赖）专用服务器</li><li>通信在对等实体之间直接进行</li></ul></li></ul></blockquote><ul><li>如何将网络边缘接入核心网（边缘路由器）？   接入网络</li></ul><h4 id="4-3-接入网络"><a href="#4-3-接入网络" class="headerlink" title="4.3 接入网络"></a>4.3 接入网络</h4><ul><li><p>接入网络：数字用户线路（DSL）</p><ul><li>利用已有的电话线连接中心局的DSLAM</li><li>非对称的 ：<br>上行传输速率&lt;2.5Mbps     下行传输速率&lt;24Mbps</li><li>FDM ：频分多路复用<br>50 kHz - 1 MHz用于下行 4 kHz - 50 kHz用于上行 0 kHz - 4 kHz用于传统电话</li></ul></li><li><p>接入网络：电缆网络</p><ul><li>HFC:混合光纤同轴电缆（ hybrid fiber coax）<br>非对称: 下行高达30Mbps传输速率，上行为2 Mbps传 输速率</li><li>频分多路复用</li><li>各家庭（设备）通过电缆网络→光纤接入ISP路由器<br>各家庭共享家庭至电缆头端的接入网络<br>不同于DSL的独占至中心局的接入</li></ul></li><li><p>机构（企业）接入网络（Ethernet）<br><em>Ethernet</em>一般指以太网。以太网是一种计算机局域网技术。</p><p>主要用于公司、高校、企业等组织机构<br>典型传输速率：10 Mbps, 100Mbps, 1Gbps, 10Gbps<br>目前，端系统通常直接连接以太网交换机（switch）</p></li><li><p>无线接入网络</p><p>通过共享的无线接入网络连接端系统与路由器 （通过基站（base station）或称为“接入点”（access point））</p></li></ul><p>  <img src="/2021/04/05/jsjwl01/image-20210324200838785.png" alt="image-20210324200838785"></p><h4 id="4-4-网络核心"><a href="#4-4-网络核心" class="headerlink" title="4.4 网络核心"></a>4.4 网络核心</h4><ul><li><p>网络核心：互联的路由器网络</p></li><li><p>网络核心的关键功能：路由+转发</p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324201246749.png" alt="image-20210324201246749"></p><ul><li><p>ISP（互联网服务提供商（Internet Service Provider））</p></li><li><p>端系统通过接入ISP（access ISPs ）连接到 Internet，接入ISP必须进一步互连，这样任意两个主机才可以互相发送分组 。这就构成复杂的网络互连的网络。（经济和国家政策是网络演进的主要驱动力）</p></li><li><p>接入ISP包括住宅、学校、公司、移动网络的基站等</p></li><li><p>Internet结构</p><blockquote><p>access net 接入网络    ISP 互联网服务提供商</p></blockquote></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324202751918.png" alt="image-20210324202751918"></p><blockquote><p>对等链路、IXP都是连接ISP的结构，其中IXP可以实现多个ISP的连接</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210324202847419.png" alt="image-20210324202847419"></p><blockquote><p>局域ISP进一步细化</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210324202906584.png" alt="image-20210324202906584"></p><blockquote><p>ISP是提供接入网络的<br>ICP（内容供应商）是提供业务、服务的<br>ICP也需要ISP来接入网络，成本高，提供网质量不高，所以后来大型的ICP（例如Google等）在全球部署数据中心机房（DC）利用专用电缆、光缆将DC连接，再接入ISP，来降低成本，提高用户体验</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210324202942386.png" alt="image-20210324202942386"></p><ul><li>Internet结构<ul><li>划分方式一：互联网分为结点和链路。主机结点称为网络边缘，网络交换结点和交换结点以及链路称为网络核心，将网络边缘接入网络核心的链路称为接入网络。</li><li>划分方式二：接入ISP汇集到区域ISP，区域ISP再汇集到一级ISP。</li></ul></li></ul><h4 id="4-6-数据交换"><a href="#4-6-数据交换" class="headerlink" title="4.6 数据交换"></a>4.6 数据交换</h4><ul><li><p>网络核心是为了解决将源主机发送的数据通过网络核心成功地传递给目的主机        –通过数据交换实现。</p></li><li><p>数据交换的类型：<br>电路交换      报文交换     分组交换</p></li></ul><h5 id="4-6-1-电路交换"><a href="#4-6-1-电路交换" class="headerlink" title="4.6.1 电路交换"></a>4.6.1 电路交换</h5><ul><li>最典型的电路交换网络：电话网络</li><li>电路交换的三个阶段：<br>建立连接（呼叫/电路建立）      通信       释放连接（拆除电路）</li><li>电路交换是独占资源的</li><li>电路交换网络如何共享中继线？    多路复用</li></ul><h5 id="4-6-2-多路复用"><a href="#4-6-2-多路复用" class="headerlink" title="4.6.2 多路复用"></a>4.6.2 多路复用</h5><ul><li><p>多路复用(multiplexing)，简称复用，是通信技术 中的基本概念。</p></li><li><p>多路复用(Multiplexing): 链路/网络资源（如带宽）划分为“资源片” 。<br>将资源片分配给各路“呼 叫”（calls）<br>每路呼叫独占分配到的资源片进行通信<br>资源片可能“闲置”(idle)  (无共享)</p></li><li><p>典型多路复用方法:<br>频分多路复用( frequency  division multiplexing-FDM )<br>时分多路复用( time division  multiplexing-TDM )<br>波分多路复用(Wavelength  division multiplexing-WDM)<br>码分多路复用( Code  division multiplexing-CDM )</p></li><li><p>频分多路复用FDM<br><img src="/2021/04/05/jsjwl01/image-20210324203913089.png" alt="image-20210324203913089"><br>频分多路复用的各用户占用不同的带宽资源（请注意，这里的“带宽 ”是频率带宽（单位：Hz）而不是数据的发送速率）。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<br><img src="/2021/04/05/jsjwl01/image-20210324204022544.png" alt="image-20210324204022544"></p></li><li><p>时分多路复用TDM<br>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧），每个用户在每个 TDM 帧中占用固定序号的时隙。<br>每用户所占用的时隙是周期性出现（其周期就是 TDM 帧的长度）。</p><p><img src="/2021/04/05/jsjwl01/image-20210324204152398.png" alt="image-20210324204152398"></p><p>时分复用的所有用户是在不同的时间占用相同的频带宽度</p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324204209123.png" alt="image-20210324204209123"></p><ul><li>波分多路复用WDM<br>波分复用就是光的频分复用</li><li>码分多路复用CDM<img src="/2021/04/05/jsjwl01/image-20210324204526439-1618041462218.png" alt="image-20210324204537250"></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324204537250-1618041480074.png" alt="image-20210324204537250"></p><p><img src="/2021/04/05/jsjwl01/image-20210324204607434.png" alt="image-20210324204607434"></p><p><img src="/2021/04/05/jsjwl01/image-20210324204619871.png" alt="image-20210324204619871"></p><h5 id="4-6-3-报文交换"><a href="#4-6-3-报文交换" class="headerlink" title="4.6.3 报文交换"></a>4.6.3 报文交换</h5><ul><li><p>报文：源（应用）发送信息整体，比如：一个文件。</p></li><li><p>报文交换（message switching)</p></li></ul><h5 id="4-6-4-分组交换"><a href="#4-6-4-分组交换" class="headerlink" title="4.6.4 分组交换"></a>4.6.4 分组交换</h5><ul><li><p>分组：报文拆分出来的一系列相对较小的数据包。<br><img src="/2021/04/05/jsjwl01/image-20210324205156713.png" alt="image-20210324205156713"></p></li><li><p>分组交换需要报文的拆分和重组，会产生额外的开销。</p></li><li><p>分组交换中是按需共享链路（statistical multiplexing）的，不同设备的分组序列不确定，所以分组交换又称：统计多路复用。</p></li><li><p>报文交换和分组交换均采用存储-转发（store-and-forward）交换方式。<br>区别：报文交换是以完整报文进行“存储-转发”，而分组交换是以较小的分组进行“存储-转发”。</p></li><li><p>传输延迟：<br>分组传输延迟（delay）=分组（packets）/链路传输速率</p></li><li><p>报文交换 vs 分组交换<br>分组交换总传输延迟更小，所需要路由器的带宽更小。</p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324211945460.png" alt="image-20210324211945460"></p><ul><li><p>例：<br><img src="/2021/04/05/jsjwl01/image-20210324212548450.png" alt="image-20210324212548450"></p><p><img src="/2021/04/05/jsjwl01/image-20210324212606781.png" alt="image-20210324212606781"></p></li><li><p>电路交换 vs 分组交换<br>分组交换资源共享率更高，让更多用户共享网络资源。<br>分组交换适用于突发数据传输网络，可以资源充分共享，同时简单、无需呼叫建立。///////////////////////////TCP三次握手？<br>分组交换可能产生拥塞（congestion）：分组延迟和丢失。（需要用协议处理可靠数据传输和拥塞控制）</p></li><li><p>问题：分组交换如何提供电路级性能保障？</p></li></ul><ul><li>分组丢失</li></ul><h4 id="4-7-计算机网络性能"><a href="#4-7-计算机网络性能" class="headerlink" title="4.7 计算机网络性能"></a>4.7 计算机网络性能</h4><ul><li><p>速率<br>速率即数据率（data rate）、数据传输速率、比特率（bit rate）</p><ul><li><p>单位时间（秒）传输信息（比特）量</p></li><li><p>计算机网络中最重要的一个性能指标</p></li><li><p>单位：b/s（或bps） kb/s、Mb/s、Gb/s</p></li><li><p>k=10^3        M=10^6      G=10^9</p></li><li><p>速率往往是指额定速率或者标称速率，实际很难达到。</p></li></ul></li><li><p>带宽</p><ul><li><p>带宽（bandwidth）原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</p></li><li><p>网络中的带宽通常是指数字信道所能传送的“最高数据率”，单位：b/s（bps）</p></li><li><p>常用单位：kb/s、Mb/s、Gb/s、Tb/s</p></li><li><p>k=10^3        M=10^6      G=10^9    T=10^12</p></li></ul></li><li><p>延迟/时延（delay或latency）</p></li></ul><p>分组交换为什么会发生丢包？</p><p>分组在路由器缓存中排队，分组到达速率超过输出链路容量时/路由器缓存不足以存储分组，就会发生丢包。</p><p>时延：分组排队，等待输出链路可用</p><p><img src="/2021/04/05/jsjwl01/image-20210331170923229.png" alt="image-20210331170923229"></p><ul><li><p>四种分组延迟</p><p><img src="/2021/04/05/jsjwl01/image-20210331172225453.png" alt="image-20210331172225453"></p><ul><li><p>d<sub>proc</sub>：结点处理延迟（nodal processing delay）</p><p>处理时延是因为节点需要解析分组的必要信息然后决定其出链路（索引转发表等操作）而产生的，通常在微秒或者更低数量级；</p></li><li><p>d<sub>queue</sub>：排队延迟（queueing delay）</p><p>排队时延是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的；一般来说，排队时延是到达该队列的流量强度和性质的函数，通常可以达到毫秒级到微秒级；</p></li><li><p>d<sub>trans</sub>：传输延迟（transmission delay）</p><p>传输时延是将所有分组的比特推向链路所有需要的时间，实际的传输时延通常在毫秒到微秒数量级。</p><ul><li>L：分组长度（bits）</li><li>R：从路由器A到B的链路传输速率/链路带宽（bps）</li><li>d<sub>trans</sub>=L/R</li></ul></li><li><p>d<sub>prop</sub>：传播延迟（propagation delay）</p><p>传播时延是指比特进入链路后，从该链路的起点到下一个结点所用的时间；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。</p><ul><li>d：物理链路长度</li></ul></li><li><p>s：信号传播速度（铜缆中电信号速度0.7倍光速~2×10<sup>8</sup>m/sec）</p><ul><li>d<sub>prop</sub>=d/s</li></ul><blockquote><p><strong>传输时延和传播时延的对比</strong></p><p>传输时延是传输一个分组的时间，传播时延是分组从一个结点到另一个结点的时间。如果打个比方的话，传输时延就是大卡车经过收费站的时间而传播时间就是车在高速公路上行驶的时间。</p></blockquote><p>一跳的时间延迟（某一分组从到达一个结点到传播到下一个结点的时间）d<sub>nodal</sub>=d<sub>proc</sub>+d<sub>queue</sub>+d<sub>trans</sub>+d<sub>prop</sub></p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331172851542.png" alt="image-20210331172851542"></p></li><li><p>排队延迟和丢包</p></li></ul><p>丢包：到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失</p><p>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；如果分组到达的速度高于结点的处理速度，那么分组就会在缓冲队列里排队等待。当缓冲空间用完后，如果还有到的分组，那么该分组将被迫丢弃。</p><p>为了描述网络状体，我们引入了流量强度这一概念：流量强度=分组到达的速度/结点的处理速度；流量工程里一个金科玉律就是：设计系统时流量强度不能大于1；</p><p>当流量强度持续大于1时，就将出现丢包现象。</p><blockquote><p>R：链路带宽（bps）   L：分组长度（bits）   a：平均分组到达速率</p><p>流量强度（traffic intensity）= La/R</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210331173545650.png" alt="image-20210331173545650"></p><p><img src="/2021/04/05/jsjwl01/image-20210331173454963.png" alt="image-20210331173454963"></p><ul><li><p>时延带宽积/带宽时延积</p><p>时延带宽积 = 传播时延 × 带宽 = d<sub>prop</sub> × R （bits）</p><p><img src="/2021/04/05/jsjwl01/image-20210331173859612.png" alt="image-20210331173859612"></p><blockquote><p>时延带宽积表示链路能够容纳的比特位</p><p>链路的时延带宽积又称为以比特为单位的链路长度</p></blockquote></li><li><p>分组丢失（丢包）</p><ul><li>队列缓存有限，分组到达已满队列将被丢弃（丢失），丢弃分组可能由前序结点或者源重发（也可能不重发）</li><li>丢包率 = 丢包数 / 已发分组总数</li></ul></li><li><p>吞吐量/率（Troughput）</p><ul><li><p>表示在发送<strong>端</strong>与接受<strong>端</strong>之间传送数据速率（b/s）</p><ul><li>即时吞吐率：给定时刻的速率</li><li>平均吞吐量：一段时间的平均速率</li></ul><blockquote><p>吞吐量可以近似为源和目的地之间路径的最小传输速率。最小传输速率的链路为<strong>瓶颈链路</strong>。吞吐量取决于瓶颈链路（bottleneck link），瓶颈链路：端到端路径上，限制端到端吞吐量的链路</p></blockquote></li></ul></li></ul><h3 id="5-计算机网络体系结构概述"><a href="#5-计算机网络体系结构概述" class="headerlink" title="5. 计算机网络体系结构概述"></a>5. 计算机网络体系结构概述</h3><h4 id="5-1-分层结构"><a href="#5-1-分层结构" class="headerlink" title="5.1 分层结构"></a>5.1 分层结构</h4><ul><li><p>采用分层结构来研究计算机网络体系结构，每层完成一类特定功能/服务，每层依赖底层提供的服务，通过层内动作完成相应功能</p></li><li><p>网络体系结构是从功能上描述计算机网络结构</p></li><li><p>计算机网络体系结构简称网络体系结构是分层结构，每层遵循某个/些网络协议完成本层功能。计算机网络体系结构是计算机网络的各层以及其协议的集合，是计算机网络的功能层次以及关系的定义，是抽象的。</p></li><li><p>分层结构<br>优点</p><ul><li>结构清晰，有利于识别复杂系统的部件以及关系</li><li>模块化的分层易于系统更新、维护</li><li>有利于标准化</li></ul><p>缺点</p><ul><li>分层过多可能导致效率较低，例：某层的功能可能需要仅在其它层才出现的信息</li></ul></li><li><p>功能上的冗余，比如许多协议栈针对链路和端到端两种情况都提供了差错恢复功能</p></li><li><p><img src="/2021/04/05/jsjwl01/image-20210331182052218.png" alt="image-20210331182052218"></p><ul><li>实体（entity）表示任何可发送或者接受信息的硬件或者软件进程</li><li>协议是控制两个对等实体进行通信的规则的集合，协议是“水平的”</li><li>任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是“垂直的”</li><li>下层协议的实现对上层的服务用户是透明的</li><li>同系统的相邻层实体间通过接口进行交互，通过服务访问点SAP（Service Access Point），交换原语，指定请求的特定服务</li></ul></li></ul><h4 id="5-2-OSI参考模型"><a href="#5-2-OSI参考模型" class="headerlink" title="5.2 OSI参考模型"></a>5.2 OSI参考模型</h4><ul><li><p>OSI参考模型</p><ul><li><p>开放系统互联（OSI）参考模型是由国际标准化组织(ISO)于1984年提出的分层网络体系结构模型<br>目的是支持异构网络系统的互联互通<br>异构网络系统互连的国际标准理解网络通信的最佳学习工具(理论模型)</p><blockquote><p>理论成功，市场失败</p></blockquote><p>7层(功能）,每层完成特定的网络功能</p></li></ul></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331182931687.png" alt="image-20210331182931687"></p><ul><li>OSI通信过程</li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331183505710.png" alt="image-20210331183505710"></p><blockquote><p>前四层称为“端到端层（end-end）”</p></blockquote><ul><li><p>数据封装与解封装</p><p><img src="/2021/04/05/jsjwl01/image-20210331183955509.png" alt="image-20210331183955509"></p><ul><li>为什么需要数据封装？<ul><li>增加控制信息<ul><li>构造协议数据单元（PDU）</li></ul></li><li>控制信息主要包括<ul><li>地址（Address）：标识发送端/接受端</li><li>差错检测编码（Error-detecting code）：用于差错检测或者纠正（有的协议有，有的协议没有）</li><li>协议控制（Protocol control）：实现协议功能的附加信息，如：优先级（priority）、服务质量（Qos）和安全控制等</li></ul></li></ul></li></ul></li><li><p>物理层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331184757076.png" alt="image-20210331184757076"></p><ul><li>接口特性<ul><li>机械特性、电气特性、功能特性、规程特性</li></ul></li><li>比特编码</li><li>数据率</li><li>比特同步<ul><li>时钟同步</li></ul></li><li>传输模式<ul><li>单工（Simplex）：只能单向传输</li><li>半双工（half-duplex）：可以双向进行，但是同一时刻只能一个方向进行</li><li>全双工（full-duplex）：可以同时进行双向传输</li></ul></li></ul></li><li><p>数据链路层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331185211807.png" alt="image-20210331185211807"></p><ul><li>负责结点-结点（node-to-node）数据传输</li><li>组帧（Framing），加头加尾，为了接收端物理层可以切分数据流成帧</li><li>物理寻址（Physical addressing）<ul><li>在帧头中增加发送结点和/或接受结点的物理地址标识数据帧的发送和/接收端</li></ul></li><li>流量控制（Flow control）<ul><li>避免淹没接受端</li></ul></li><li>差错控制（Error control）<ul><li>检测并重传损坏或丢失帧，并避免重复帧</li></ul></li><li>访问（接入）控制（Access control）<ul><li>在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权</li></ul></li></ul></li><li><p>网络层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331190332672.png" alt="image-20210331190332672"></p><ul><li>负责源主机到目的主机数据分组（packet）交付<ul><li>可能穿越多个网络–逻辑寻址</li></ul></li><li>逻辑寻址（Logical addressing）<ul><li>全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址</li></ul></li><li>路由（Routing）<ul><li>路由器（或网关）互连网络，并路由分组至最终目的主机</li><li>路径选择</li></ul></li><li>分组转发</li></ul></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331190643191.png" alt="image-20210331190643191"></p><blockquote><p>红色S、A等表示网络层地址（逻辑地址）不变，绿色02、27等表示数据链路层地址（物理地址）会改变</p></blockquote><ul><li><p>传输层功能</p><p>负责源-目的（端-端）（进程间）完整报文传输</p><p><img src="/2021/04/05/jsjwl01/image-20210331191041188.png" alt="image-20210331191041188"></p><ul><li><p>分段与重组</p></li><li><p>SAP寻址</p><ul><li>确保将完整报文提交给正确的进程，如端口号</li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331191406873.png" alt="image-20210331191406873"></p></li><li><p>连接控制  （逻辑连接，不是电路连接）</p></li><li><p>流量控制（端到端）</p></li><li><p>差错控制</p></li></ul></li><li><p>会话层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331191850256.png" alt="image-20210331191850256"></p><ul><li>对话控制（dialog controlling）<ul><li>建立、维护</li></ul></li><li>同步（synchronization）<ul><li>在数据流中插入“同步点”（syn），可以在对话出现差错时就近恢复</li></ul></li></ul></li><li><p>表示层功能</p><p>处理两个系统间交换信息的语法与语义（syntax and semantics）问题</p><p><img src="/2021/04/05/jsjwl01/image-20210331191950105.png" alt="image-20210331191950105"></p><ul><li>数据表示转换<ul><li>发送端将信息转化为一种独立的不依赖于主机的编码，接收端接收到后将这种编码再转换为自身的编码信息</li></ul></li><li>加密/解密</li><li>压缩/解压缩</li></ul></li><li><p>应用层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331192404895.png" alt="image-20210331192404895"></p><ul><li>支持用户通过用户代理（如浏览器）或网络接口使用网络（服务）</li></ul></li></ul><h4 id="5-3-TCP-IP参考模型"><a href="#5-3-TCP-IP参考模型" class="headerlink" title="5.3 TCP/IP参考模型"></a>5.3 TCP/IP参考模型</h4><p><img src="/2021/04/05/jsjwl01/image-20210331192847062.png" alt="image-20210331192847062"></p><p><img src="/2021/04/05/jsjwl01/image-20210331192902759.png" alt="image-20210331192902759"></p><blockquote><p>网络接口层无具体协议，是链路层的简化</p></blockquote><h4 id="5-4-五层参考模型"><a href="#5-4-五层参考模型" class="headerlink" title="5.4 五层参考模型"></a>5.4 五层参考模型</h4><blockquote><p>综合OSI（理论清晰）和TCP/IP（实用，如今的Internet就是这样的结构）的优点</p></blockquote><p>各层的所有协议组合起来，称为<strong>协议栈</strong>。因特网的协议栈有5个层次组成：物理层、链路层、网络成、传输层、应用层</p><p><strong>应用层</strong>：应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为报文；<br><strong>传输层</strong>：传输层在应用程序端点之间传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为报文段。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。<br><strong>网络层</strong>：网络层将称为数据报的网络层分组从一台主机移动到另一台主机。网络层协议包含著名的IP协议以及其他一些路由选择协议。数据报<br><strong>链路层</strong>：链路层将称为帧的链路层分组从一个结点移动到路径上的另一个端点。一个帧可能被沿途不同链路上的不同链路层协议处理。帧<br><strong>物理层</strong>：物理层的任务是将帧中的比特从一个结点移动到下一个节点，它提供了传输信息的实际物理通道；<br><img src="/2021/04/05/jsjwl01/image-20210331193222684.png" alt="image-20210331193222684"></p><ul><li><p>五层模型的数据封装</p><p>​    <strong>封装</strong>：一个分组，在不同的层次有不同的称谓，是因为它们经过每一层的时候就被该层封装上了属于该层的相关信息，也就是前面提到的必要信息；于是，每一分层的分组有两种类型的字段：首部字段和有效负载；其中有效负载即为来自上一层的分组数据，而首部字段就是该层加上的必要信息；分组不断被封装以实现各层协议规定的相关功能。</p><p><img src="/2021/04/05/jsjwl01/image-20210331193541952.png" alt="image-20210331193541952"></p></li></ul><h3 id="6-计算机网络与Internet发展历史"><a href="#6-计算机网络与Internet发展历史" class="headerlink" title="6.计算机网络与Internet发展历史"></a>6.计算机网络与Internet发展历史</h3><p><img src="/2021/04/05/jsjwl01/image-20210331193804005.png" alt="image-20210331193804005"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194018327.png" alt="image-20210331194018327"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194416382.png" alt="image-20210331194416382"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194554759.png" alt="image-20210331194554759"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194816888.png" alt="image-20210331194816888"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
