<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python</title>
      <link href="2021/04/12/python01/"/>
      <url>2021/04/12/python01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统绪论</title>
      <link href="2021/04/12/os01/"/>
      <url>2021/04/12/os01/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统绪论"><a href="#操作系统绪论" class="headerlink" title="操作系统绪论"></a>操作系统绪论</h2><blockquote><ul><li>主要参考书籍：<ul><li>《操作系统导论》（Remzi H. Arpaci-Dusseau、Andrea C. Arpaci-Dusseau)</li><li>《操作系统概念》（Abraham Silberschatz、Peter Bear  Galvin、Greg  Gagne）</li></ul></li><li>主要参考视频：<ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=9067503727200252128">操作系统（哈工大李治军老师）32讲（全）超清</a></li></ul></li></ul></blockquote><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络应用层</title>
      <link href="2021/04/10/jsjwl02/"/>
      <url>2021/04/10/jsjwl02/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络应用层"><a href="#计算机网络应用层" class="headerlink" title="计算机网络应用层"></a>计算机网络应用层</h2><ul><li><p>学习目标：</p><ul><li><p>网络应用的原理：网络应用协议的概念和实现方面</p><ul><li>网络应用的体系结构：<ul><li>客户-服务器模式     对等模式（peer-to-peer）     混合结构</li></ul></li><li>网络应用的服务需求：<ul><li>可靠性     带宽     时延</li></ul></li></ul><span id="more"></span></li><li><p>传输层提供的服务模型</p><ul><li>TCP、UDP 如何为应用层提供的支持？</li></ul></li><li><p>内容分发网络</p></li><li><p>网络应用的实例：互联网流行的应用层协议</p><ul><li>web应用–HTTP协议</li><li>文件传输应用–FTP协议</li><li>email应用–SMTP、POP3、IMAP协议</li><li>实现网络核心应用功能的DNS</li></ul></li><li><p>编程：如何开发网络应用程序？</p><ul><li>Socket API</li></ul></li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/20190324183705231.png" alt="应用层知识点框图"></p><h3 id="1-网络应用体系结构"><a href="#1-网络应用体系结构" class="headerlink" title="1 网络应用体系结构"></a>1 网络应用体系结构</h3><p>​    网络应用在不同的端系统上运行。网络应用通过网络基础设施提供的服务，应用进程彼此之间通信。例如web应用，web服务器软件和浏览器软件通信。</p><p>​    在网络核心中没有应用层软件，网络核心中没有应用层功能，网络应用只在端系统上存在，更方便网络应用的开发和部署。</p><p><img src="/2021/04/10/jsjwl02/image-20210410165338821.png" alt="网络应用开发和部署"></p><h4 id="1-1-客户机-服务器结构（Client-Server，C-S）"><a href="#1-1-客户机-服务器结构（Client-Server，C-S）" class="headerlink" title="1.1 客户机/服务器结构（Client-Server，C/S）"></a>1.1 客户机/服务器结构（Client-Server，C/S）</h4><p><img src="/2021/04/10/jsjwl02/image-20210410165429573.png" alt="C/S"></p><ul><li><p>服务器</p><ul><li>一直运行</li><li>永久性访问地址/域名</li><li>利用大量服务器实现可拓展性，服务器场，数据中心进行扩展</li></ul></li><li><p>客户机</p><ul><li>主动与服务器通信，使用服务器提供的服务</li><li>间接性接入网络</li><li>可能是动态IP地址</li><li>不会与其他客户机直接通信</li></ul></li><li><p>缺点：</p><ul><li>可拓展性差，服务器有限的服务能力，链路带宽限制；</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210401180447699.png" alt="C/S拓展性差"></p><ul><li>可靠性差，依赖于服务器</li></ul></li></ul><blockquote><p>通常，如果仅有一台服务器处理所有的请求，那么服务器系统将很快变得不堪重负，为此，配备大量主机的数据中心常被用于创建强大的虚拟的服务器，一个数据中心可以有数十万台服务器，它们需要供电和维护，同时服务提供商还需要支付不断出现的互联和带宽费用，以及发送和接收到达/来自数据中心的数据。</p></blockquote><ul><li>应用例子：Web、FTP、Telnet和电子邮件</li></ul><h4 id="1-2-P2P结构"><a href="#1-2-P2P结构" class="headerlink" title="1.2 P2P结构"></a>1.2 P2P结构</h4><p><img src="/2021/04/10/jsjwl02/image-20210410165453140.png" alt="P2P"></p><ul><li><p>（几乎）无永远在线的服务器</p></li><li><p>任意端系统/节点之间可以直接通讯</p></li><li><p>每一节点既是客户端又是服务器</p><ul><li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li></ul><blockquote><p>比如在文件共享应用中，对等方可能通过向文件的原始拥有者发出请求而产生工作量，但是对等方也有可能通过为其他对等方传送文件而为原始拥有者分担压力。</p></blockquote></li><li><p>节点间接性接入网络且可能改变IP地址</p></li><li><p>优点：高度可拓展性</p></li><li><p>缺点：</p><ul><li>ISP友好。大多数住宅ISP受制于非对称带宽应用，也就是下载比上传要多得多。但是P2P视频和文件分发应用改变了从服务器到住宅ISP的上传流量，因而给ISP带来压力；</li><li>安全性。因为其高度的分布和开放式，P2P应用也可能给安全带来挑战；</li><li>激励。如何说服用户资源向应用提供带宽、存储和计算资源？这是一个问题；</li></ul></li><li><p>应用例子：目前，流量密集型应用都是P2P体系结构的。这些应用包括文件共享（例如BitTorrent）、协助下载（例如迅雷）、因特网电话（例如Skype）和IPTV(例如迅雷看看)。</p></li></ul><h4 id="1-3-混合结构"><a href="#1-3-混合结构" class="headerlink" title="1.3 混合结构"></a>1.3 混合结构</h4><ul><li><p>Napster</p><ul><li><p>文件传输使用P2P结构</p><ul><li>任意Peer节点之间</li></ul></li><li><p>文件的搜索采用C/S结构–集中式</p><ul><li>每个结点向中央服务器登记自己的资源信息</li><li>每个结点向中央服务器提交查询请求，查找相应资源</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210331234531220.png" alt="Napster"></p></li></ul></li><li><p>例：即时通信</p><ul><li>在线检测：集中<ul><li>当用户上线时，向中心服务器注册其IP地址</li><li>用户与中心服务器联系，以找到其在线好友的位置</li></ul></li><li>两个用户之间聊天：P2P</li></ul></li></ul><h3 id="2-网络应用的进程间通信"><a href="#2-网络应用的进程间通信" class="headerlink" title="2 网络应用的进程间通信"></a>2 网络应用的进程间通信</h3><p>在操作系统中，实际进行通信的是进程而不是应用程序。<br>当进程运行在同一个端系统上时，它们使用进程间通信机制相互通信；而进程间通信的规则是由端系统上的操作系统确定的。<br>当进程运行在不同的端系统上时，它们通过跨越计算机网络的报文相互通信；发送进程产生报文并且向网络中发送，接收进程接收报文并对此作出响应（不响应也是一种响应）。</p><h4 id="2-1-进程间通信基本概念"><a href="#2-1-进程间通信基本概念" class="headerlink" title="2.1 进程间通信基本概念"></a>2.1 进程间通信基本概念</h4><ul><li><p>网络应用的基础：进程间通信</p></li><li><p>进程：主机上运行的程序</p></li><li><p>同一主机上运行的进程之间如何通信？</p><ul><li>进程间通信控制（由操作系统提供）</li></ul></li><li><p>不同主机上运行的进程间如何通信？</p><ul><li><p>按照网络应用协议进行消息交换（例如报文交换）</p><ul><li>借助传输层提供的服务</li></ul></li><li><p>同时使用OS提供的通信服务</p></li></ul></li><li><p>客户机进程/服务器进程</p><ul><li>客户机进程：发起通信的进程</li><li>服务器进程：等待通信请求的进程</li></ul><blockquote><p> 在P2P架构的应用中也存在客户机进程、服务器进程这样进程关系。在某些P2P应用中，一个进程可能既是客户也是服务器，因为在一个文件共享应用中，一个进程的确既能请求文件也能发送文件。所以从进程所扮演的角色来区分是客户进程还是服务器进程不够精确，所以我们从发起通信的顺序来定义它们：<strong>在给定的一对进程之间，首先发起通信的进程被标记为客户进程，在会话开始时等待联系的进程被称为服务器进程。</strong></p></blockquote></li></ul><h4 id="2-2-分布式进程间通信实现机制"><a href="#2-2-分布式进程间通信实现机制" class="headerlink" title="2.2 分布式进程间通信实现机制"></a>2.2 分布式进程间通信实现机制</h4><p><img src="/2021/04/10/jsjwl02/image-20210410172627902.png" alt="分布式进程间通信"></p><ul><li><p>分布式进程间通信需要解决的问题：</p><ul><li><p>问题1：进程标示和寻址问题（服务用户） </p><ul><li>对进程进行编址：进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）<ul><li>主机：唯一的32位IP地址<ul><li>仅仅有IP地址不能够唯一标识一个进程：在一台端系统上有很多进程在运行</li></ul></li><li>端口号（Port Numbers）（16bit）：确定是哪一个进程</li><li>所采用的传输层协议：TCP or UDP<ul><li>常见端口号例子：<ul><li>HTTP：TCP 80</li><li>Mail：TCP 25</li><li>FTP：TCP 2</li></ul></li></ul></li></ul></li><li>一个进程：用IP+port标示 端节点(end-point)</li><li>本质上，一对主机进程之间的通信由2个端结点构成</li></ul></li><li><p>问题2：传输层-应用层提供服务是如何（服务） </p><ul><li>传输层提供的服务-应用层与传输层层间接口必须要传递的信息：<ul><li>要传输的报文（对本层来说：SDU）</li><li>谁传的：对方的应用进程的标示：IP+TCP（UDP）端口号</li><li>传给谁：对方的应用进程的标示：对方的IP+TCP（UDP）端口号</li></ul></li><li>传输层实体（TCP或者UDP实体）根据应用层传输的信息进行TCP报文段（或者UDP报文段）的封装<ul><li>源端口号，目标端口号等封装为报文段头部，数据等封装到报文段负载</li><li>并将IP地址（源IP，目标IP）往下交给IP实体，用于封装IP数据报</li></ul></li></ul><p>​    如果每次两个主机的两个特定应用程序一段时间内多次进行信息传递或者进行信息传递比较频繁，每次传递信息都需要传递自己的和对方的IP+端口号，都携带如此多信息，太繁琐易错，不便于管理。</p><p>​    所以在应用层和传输层之间引入了Socket，用一个本地代号来标识通信的双方（TCP）或者单方（UDP）。就像是OS打开文件返回的句柄一样，对句柄的操作，就是对文件的操作，而不用再使用这个文件的目录名、文件名。</p><ul><li><p><strong>TCP socket：</strong></p><p>TCP服务，两个进程之间的通信需要通信之前就建立连接<font color="#A9A9A9">(两个进程通信会持续一端时间，通信关系稳定)</font>。可以用一个整数即Socket（类似句柄）来在本地对两个应用实体之间的通信关系进行标示。这样两个应用实体之间通信时，穿过层间接口的信息就只需要包含所需传递的消息数据。</p><p>对于使用面向连接服务（TCP）的应用而言，TCP socket是4元组的一个具有<strong>本地意义</strong><font color="#A9A9A9">(只有本地的应用层和传输层知道)</font>的标示。4元组：源IP，源端口，目标IP，目标端口</p><blockquote><p>TCP socket唯一的指定了一个会话（两个进程之间的会话关系）</p><p>应用使用这个标示与远程的应用进程进行通信，不必在每个报文的发送都指定这4元组。</p><p>简单，便于管理；同时减少穿过层间的数据</p></blockquote></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411094526831.png" alt="TCP socket"></p><ul><li><strong>UDP socket：</strong></li></ul><p>UDP服务，两个进程之间的通信之前无需建立连接<font color="#A9A9A9">（每个报文都是独立传输的，前后报文可能给不同的分布式进程）</font>。因此只能用一个整数表示本应用实体的标示。</p><p>UDP socket是2元组（源IP，源端口）的一个具有本地意义的标示。UDP套接字指定了应用所在的一个端结点（end-point）。</p><p>在发送数据报时，采用创建好的本地套接字（标示ID），就不必再发送每个报文中自己的ip和port。但是传输报文时，必须提供目的IP和目的端口号。接受报文的时候，传输层同样需要上传对方的IP和端口号。</p><p><img src="/2021/04/10/jsjwl02/image-20210411100319390.png" alt="UDP socket"></p><ul><li><p>套接字（Socket）</p><ul><li>进程向套接字发送报文或者从套接字接受报文</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411100617644.png" alt="套接字"></p></li><li><p>传输层-应用层提供服务的：</p><p>位置：层间界面的SAP （TCP/IP ：socket） </p><p>形式：应用程序接口API （TCP/IP ：socket API）</p></li></ul></li><li><p>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）</p><ul><li><p>定义应用层协议，协议定义了运行在不同端系统上的应用进程如何相互交换报文</p><ul><li>交换报文类型：请求和应答报文</li><li>各种报文类型的语法：报文中的各字段及其描述</li><li>字段的语义：即字段取值的含义</li><li>进程何时、如何发送报文及对报文进行响应的规则</li></ul><blockquote><p>应用协议仅是应用的一个组成部分。例如：web应用包含了HTTP协议，web客户端，web服务器，HTML等</p></blockquote><blockquote><p>实体：仅仅和网络交互有关的、遵守协议的且是运行中的软件模块和硬件模块被称为实体。</p></blockquote><blockquote><p>公开协议：</p><p>​    由RFC文档定义</p><p>​    允许互操作</p><p>​    如HTTP，SMTP</p><p>专用（私有）协议：</p><p>​    协议不公开，如：Skype</p></blockquote></li><li><p>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等；</p><ul><li>传输基础设施向进程提供API<ul><li>传输协议的选择</li><li>参数的设置</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="3-Internet传输层服务模型"><a href="#3-Internet传输层服务模型" class="headerlink" title="3 Internet传输层服务模型"></a>3 Internet传输层服务模型</h3><ul><li><p>问题4：应用需要传输层提供什么样的服务？如何描述传输层的服务？</p><h4 id="3-1-描述传输层指标"><a href="#3-1-描述传输层指标" class="headerlink" title="3.1 描述传输层指标"></a>3.1 描述传输层指标</h4><ul><li>数据丢失率<ul><li>有些应用（如音频）能容忍一定比例以下的数据丢失</li><li>有些应用则要求100%的可靠数据传输（如文件）</li></ul></li><li>延迟<ul><li>一些应用出于有效性的考虑，对数据传输有严格的时间限制<ul><li>Internet电话、交互式游戏</li></ul></li></ul></li><li>吞吐<ul><li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li></ul></li><li>一些应用能充分利用可供使用的吞吐（弹性应用）</li><li>安全性</li><li>机密性   完整性   可认证性（鉴别）</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411102836028.png" alt="常见应用对传输服务的要求"></p><h4 id="3-2-Internet传输层提供什么样的服务？"><a href="#3-2-Internet传输层提供什么样的服务？" class="headerlink" title="3.2 Internet传输层提供什么样的服务？"></a>3.2 Internet传输层提供什么样的服务？</h4><ul><li>TCP服务：<ul><li>可靠的传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐保证和安全保证</li><li>面向连接：要求通信前在客户端进程和服务器进程之间建立连接。（仅在端系统实现连接，而不对网络核心提供服务和维护）</li></ul></li><li>UDP服务<ul><li>不可靠数据传输</li><li><strong>不</strong>提供的服务：可靠，流量控制，拥塞控制，时间，带宽保障，建立连接</li><li>为什么要有UDP？（UDP存在的必要性）<ul><li>能够区分不同的进程，而IP服务不能</li><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li><li>无需建立连接，省去了建立连接时间，适合事务性的应用</li><li>不做可靠性的工作，例如检错重发，适合那些对实时 性要求比较高而对正确性要求不高的应用<ul><li> 因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发等）</li></ul></li><li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据 <ul><li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li></ul></li></ul></li></ul><img src="/2021/04/10/jsjwl02/image-20210411103950494.png" alt="Internet应用及其应用层协议和传输协议"></li><li>安全TCP<blockquote><p>TCP和UDP都没有加密，明文通过互联网传输信息，甚至密码，安全性很低</p></blockquote><ul><li>SSL<pre><code>在TCP之上实现，提供加密的TCP连接。保证私密性。数据完整性以及端到端的鉴别。SSL在应用层中：应用采用SSL库形式与应用一起运行，然后SSL库使用TCP通信SSL socket API：应用通过API将明文交给socket，SSL将其加密后在互联网传输</code></pre><blockquote><p>例如https，HTTP协议运行在SSL之上，SSL运行在TCP协议之上，实现了web应用的安全可靠传输。</p></blockquote></li></ul><img src="/2021/04/10/jsjwl02/image-20210411132650541.png" alt="进程、SSL与TCP关系"></li></ul></li></ul><h3 id="4-特定网络应用以及协议"><a href="#4-特定网络应用以及协议" class="headerlink" title="4 特定网络应用以及协议"></a>4 特定网络应用以及协议</h3><h4 id="4-1-Web与HTTP"><a href="#4-1-Web与HTTP" class="headerlink" title="4.1 Web与HTTP"></a>4.1 Web与HTTP</h4><ul><li><p>一些术语：</p><ul><li>web页：由一些对象组成</li></ul><blockquote><p>web页含有一个基本的HTML文件，该基本HTML文件本身就是一个对象，其中还包含其他对象的引用（以链接URL的形式）</p></blockquote><ul><li><p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p></li><li><p>通过URL对每个对象进行引用</p><ul><li><p>每个对象都有唯一的URL进行标识</p></li><li><p>访问协议：用户名、口令字、端口等</p></li><li><p>URL格式：<img src="/2021/04/10/jsjwl02/image-20210411112003845.png" alt="URL格式"></p><ul><li><p>协议名：以什么协议来访问对象（HTTP/FTP等）</p></li><li><p>用户:口令：访问对象用什么用户:口令访问</p><blockquote><p>有的网站支持匿名访问，无需提供用户:口令</p></blockquote></li><li><p>端口：如果未指定端口，会采用协议的默认端口号（如HTTP的默认端口80）</p></li></ul></li></ul></li></ul></li></ul><h5 id="4-1-1-HTTP概况"><a href="#4-1-1-HTTP概况" class="headerlink" title="4.1.1 HTTP概况"></a>4.1.1 HTTP概况</h5><ul><li><p>HTTP ：超文本传输协议</p><ul><li>Web的应用层协议</li><li>客户/服务器模式<ul><li>客户：请求、接受和显示Web对象的浏览器</li><li>服务器：对请求进行响应，发送对象的Web服务器</li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411131620123.png" alt="HTTP协议"></p><ul><li><p>HTTP 1.0 ：RFC 1945</p><p>HTTP 1.1 ：RFC 2068</p></li><li><p>使用TCP</p><ol><li>客户发起一个与服务器的TCP连接（建立socket），端口号为80</li><li>服务器接受客户的TCP连接</li><li>在浏览器（HTTP客户端）与Web服务器（HTTP服务器server）交换HTTP报文（应用层协议报文）</li><li>TCP连接关闭</li></ol><p><img src="/2021/04/10/jsjwl02/image-20210411134148359.png" alt="HTTP建立连接示意图"></p></li><li><p>HTTP是无状态的</p><ul><li>服务器并不维护关于客户的任何信息，即交换过HTTP报文以后就断开TCP连接，不会存储客户信息，客户之后对报文更改与服务器无关</li><li>优点：简单；无状态的服务器能够支持更多的客户端</li></ul><blockquote><p>维护状态的协议很复杂！</p><ul><li>必须维护历史信息（状态）</li><li>如果服务器/客户端死机，它们的状态信息可能不一致，而必须维护成信息一致的</li></ul></blockquote></li></ul></li></ul><h5 id="4-1-2-HTTP连接"><a href="#4-1-2-HTTP连接" class="headerlink" title="4.1.2 HTTP连接"></a>4.1.2 HTTP连接</h5><ul><li><p>非持久HTTP</p><ul><li>每个TCP连接在服务器最多发送一个对象后就会关闭，也就是每个TCP只传送一个请求报文和响应报文</li><li>下载多个对象需要多个TCP连接</li><li>HTTP/1.0使用非持久连接</li></ul><p>假设用户输入URL:<a href="http://www.someschool.edu/someDept/home.index">www.someSchool.edu/someDept/home.index</a>  (假设这个web中包含文本和10个jpeg图像的引用)</p><p><img src="/2021/04/10/jsjwl02/image-20210411140316400.png" alt="非持久HTTP"></p><ul><li><p>响应时间模型</p><ul><li>往返时间RTT（round-trip-time）</li></ul><p>一个小的分组从客户端到服务器，再回到客户端的时间（RTT包括分组的传播时延、排队时延、处理时延（因为是短分组，所以其传输时延可不计））</p><ul><li>响应时间：<ul><li>一个RTT用来发起TCP连接</li><li>一个RTT用来HTTP请求并等待HTTP响应</li><li>文件传输时间</li><li>共2RTT+传输时间</li></ul></li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411140846744.png" alt="响应时间模型"></p><ul><li>非持久HTTP的缺点：<ul><li>每个对象传输要2个RTT+传输时间</li><li>操作系统必须为每个TCP连接分配资源</li><li>但浏览器通常打开并行TCP连接，以获取引用对象</li></ul></li></ul></li><li><p>持久HTTP</p><ul><li>服务器在发送响应后，仍保持TCP连接；在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li><li>多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</li><li>HTTP/1.1默认使用持久连接</li><li>持久HTTP分为非流水方式的持久HTTP和流水方式的持久HTTP<ul><li>非流水方式（no-pipeline）的持久HTTP<ul><li>客户端只能在收到前一个响应后才能发出新的请求</li><li>每个引用对象花费一个RTT</li></ul></li><li>流水方式（pipeline）的持久HTTP、<ul><li>HTTP/1.1的默认方式</li><li>客户端遇到一个引用对象就立即产生一个请求</li><li>所以引用（小）对象只花费一个RTT是可能的</li></ul></li></ul></li></ul></li></ul><h5 id="4-1-3-HTTP报文格式：请求报文和响应报文"><a href="#4-1-3-HTTP报文格式：请求报文和响应报文" class="headerlink" title="4.1.3 HTTP报文格式：请求报文和响应报文"></a>4.1.3 HTTP报文格式：请求报文和响应报文</h5><ul><li><p>两种类型的HTTP报文：请求、响应</p></li><li><p>HTTP请求报文：</p><ul><li><p>ASCII    -具有可读性</p><p><img src="/2021/04/10/jsjwl02/image-20210411143216745.png" alt="HTTP请求报文"></p><ul><li><p>一个请求报文具有至少一行的内容。请求报文的第一行称为请求行，其后继的各行被称为首部行。</p></li><li><p>请求行包含三个内容：方法字段、URL字段、HTTP版本；其中方法字段可为：GET、POST、PUT、DELETE、HEAD等。URL字段里可以传递请求对象的标志。</p></li><li><p>首部行包含是否在发送完响应报文后关闭TCP连接的Connection、请求的主机地址（该头部信息被Web高速缓存所要求）Host、客户端用户代理（浏览器）版本User-agent、可接受的语言Accept-language等头部信息；</p></li><li><p>在首部行之后一个空行，之后便是请求的“实体体”。</p><blockquote><p>该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等。</p><p>值得注意的是，表单也不一定必须使用POST方法。</p><ul><li>方法类型：</li></ul><p>HTTP/1.0 : GET、POST、HEAD</p><p>HTTP/1.1 : GET、POST、HEAD、PUT、DELETE</p><p>get，实体主体为空，上载内容会显示在URL的参数中。服务器将会用一个HTTP响应报文进行响应，报文中包含请求的对象。</p><p>Head类似于get方法，服务器将会用一个HTTP报文进行响应，但是不返回请求对象，经常用作调试跟踪。</p><p>put方法允许用户上传对象到URL指定的Web服务器上指定的路径。</p><p>Delete方法允许用户或应用程序删除URL指定的Web服务器上的对象。</p></blockquote></li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411144156506.png" alt="请求报文格式"></p><ul><li>HTTP请求报文也可向服务器提交内容，提交表单输入有如下两种方式：<ul><li>Post方式<ul><li>网页通常包括表单输入</li><li>提交的内容包含在实体体（entity body）中，然后被提交到服务器</li></ul></li><li>URL方式<ul><li>方法：GET</li><li>表单输入通过请求行的URL字段上载</li><li>例如：<a href="http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3%E9%80%9A%E8%BF%87URL%E4%B8%AD%E7%9A%84">http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3通过URL中的</a> 参数：wd，cl 参数值：XX+YY+zzz，3 形式信息</li></ul></li></ul></li></ul></li><li><p>HTTP响应报文</p><ul><li><p>ASCII    -具有可读性</p><p><img src="/2021/04/10/jsjwl02/image-20210411145603153.png" alt="HTTP响应报文"></p><ul><li><p>响应报文总体上也分三个部分，第一部分是状态行，包含HTTP版本、状态以及状态信息等内容；第二部分是首部行，包含发送日期、服务器类型、上一次修改请求资源的时间、内容的长度和内容的类型等内容。第三部分是实体主体。实体主体包含请求对象本身。</p></li><li><p>首部行中的内容的长度是用于描述HTTP消息实体的传输长度，为了让应用层区分报文的边界</p><blockquote><p>因为TCP向上层应用层传递的是字节流，是不区分边界的，因此应用层要通过Content-Length来维护报文的界限</p></blockquote></li><li><p>首部行的Date是从文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。</p></li><li><p>HTTP响应状态码：位于服务器→客户端的响应报文中的首行</p></li></ul><blockquote><p>一些状态码的例子：</p><p>200 OK </p><p>&emsp;请求成功，请求对象包含在响应报文的后续部分 </p><p>301 Moved Permanently </p><p>&emsp;请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定</p><p>&emsp;客户端软件自动用新的URL去获取对象 </p><p>400 Bad Request </p><p>&emsp;一个通用的差错代码，表示该请求不能被服务器解读 </p><p>404 Not Found</p><p>&emsp;请求的文档在该服务上没有找到 </p><p>505 HTTP Version Not Supported</p></blockquote></li></ul></li></ul><h5 id="4-1-4-用户与服务器的交互：Cookie"><a href="#4-1-4-用户与服务器的交互：Cookie" class="headerlink" title="4.1.4 用户与服务器的交互：Cookie"></a>4.1.4 用户与服务器的交互：Cookie</h5><ul><li><p>HTTP是无状态协议，但是Web站点为了识别用户身份或者限制用户访问的时间或者将用户访问的内容同用户身份相关联，Web站点可以使用Cookie技术实现用户信息存储。</p></li><li><p>Cookie技术包含4个组成部分</p><ol><li>HTTP响应报文里增加一个关于Cookie的首部行；</li><li>HTTP请求报文里增加一个关于Cookie的首部行；</li><li>用户端系统中保留一个Cookie文件，由用户的浏览器维护和管理；</li><li>在Web站点后端数据库建立Cookie和用户身份的关联；</li></ol><p><img src="/2021/04/10/jsjwl02/image-20210411161744290.png" alt="Cookies:维护状态"></p><blockquote><p>用户首次访问web服务器时，HTTP请求报文中无Cookie，在访问时，服务器会为用户建立Cookie，然后响应报文中首部行会有Cookie标示内容，用户收到响应报文后，用户浏览器会将cookie保存在本地cookies文件中，然后之后用户再次HTTP请求报文都会携带有cookie。</p></blockquote></li><li><p>Cookies能带来功能：</p><ul><li>用户验证</li><li>购物车</li><li>推荐</li><li>用户状态（Web e-mail）等</li></ul></li><li><p>如何维护状态：</p><ul><li>协议端节点：在多个事物上，发送端和接收端维持状态</li><li>cookies：HTTP报文携带状态信息</li></ul></li><li><p>Cookies的隐私泄露问题：</p><ul><li>Cookies允许站点知道许多关于用户的信息，站点可能将它知道的东西卖给第三方</li><li>使用重定向和cookie的搜索引擎还能知道用户更多的信息<ul><li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li></ul></li><li>广告公司从站点获得信息</li></ul></li></ul><h5 id="4-1-5-Web缓存（代理服务器）"><a href="#4-1-5-Web缓存（代理服务器）" class="headerlink" title="4.1.5 Web缓存（代理服务器）"></a>4.1.5 Web缓存（代理服务器）</h5><p>Web缓存器也被称为代理服务器，它代表初始web服务器来满足HTTP请求。它具有自己的存储空间，并在存储空间里保持有最近请求过的对象的副本；可以通过配置浏览器，将所有指向初始服务器的请求首先指向代理服务器。</p><p>当代理服务器收到一个HTTP请求后，它将检查本地是否缓存过该对象，如果缓存过该对象，将检查是否过期，如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p><ul><li>目标：不访问原始服务器，就满足客户的请求</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411163153908.png" alt="代理服务器示意图"></p><ul><li><p>Web缓存既是客户端又是服务器</p></li><li><p>通常缓存是由ISP安装（大学、公司、居民区ISP）</p></li><li><p>Web缓存优点：</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internet接入链路上的流量，减少原始服务器负担</li><li>互联网大量使用了缓存，可以使较弱的ICP也能够有效提供内容</li></ul></li><li><p>缓存示例：</p></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411163746751.png" alt="正常情况"></p><blockquote><p>接入链路流量强度接近于1，所以排队延迟（d<sub>queue</sub> = (I/(1-I))*(L/R)）将会很大，用户访问的时间因此而很大。</p></blockquote><p><img src="/2021/04/10/jsjwl02/image-20210411163945732.png" alt="更快的接入链路"></p><p><img src="/2021/04/10/jsjwl02/image-20210411163959897.png" alt="安装本地缓存1"></p><p><img src="/2021/04/10/jsjwl02/image-20210411164018449.png" alt="安装本地缓存2"></p><h5 id="4-1-6-条件GET方法"><a href="#4-1-6-条件GET方法" class="headerlink" title="4.1.6 条件GET方法"></a>4.1.6 条件GET方法</h5><p>高速缓存器的使用，带来很多好处，但是有一个问题就是代理服务器对缓存对象的管理：如何确保所请求的对象是最新的？</p><p>其实HTTP提供了一种机制，允许缓存器证实其使用的对象是最新的，这种机制就是条件GET方法。</p><p>使用条件GET方法只需在使用GET方法的时候，增加一个If-Modified-Since首部行，其对应的内容是一个时间，如果所请求的资源在指定日期后(与Last-Modified比较)被修改了，那么服务器将返回新的对象，否则服务器将返回一个包含空实体主体的报文。这样代理服务器就可以确认缓存是否过期了。</p><ul><li>目标：即时更新缓存中的对象拷贝。<ul><li>如果缓存拷贝需要更新，返回 HTTP/1.0  200  OK，实体主体中包含对象</li><li>如果缓存拷贝不需要更新，则返回HTTP/1.0  304  Not Modified，且实体主体中不包含对象</li></ul></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411165916546.png" alt="条件Get方法"></p><h4 id="4-2-FTP：文件传输协议"><a href="#4-2-FTP：文件传输协议" class="headerlink" title="4.2 FTP：文件传输协议"></a>4.2 FTP：文件传输协议</h4><p><img src="/2021/04/10/jsjwl02/image-20210411194534840.png" alt="FTP"></p><ul><li>FTP应用包括FTP用户接口、FTP客户端、本地文件系统、界面等。而FTP服务器有服务器的文件系统，守候在21号端口，等待连接。</li><li>FTP协议中，用户通过FTP客户端可以向远程主机上传输文件或从远程主机接受文件</li><li>客户/服务器模式<ul><li>客户端：发起传输的一方</li><li>服务器：远程主机</li></ul></li><li>FTP：RFC 959</li><li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议<ul><li>客户端通过控制连接获得身份确认</li><li>客户端通过控制连接发送命令浏览远程目录</li></ul></li><li>但是，当服务器收到一个文件传输命令时，服务器打开第二个TCP数据连接（服务器20号端口到客户端的数据连接）来传输文件。</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411202825985.png" alt="FTP端口连接"></p><ul><li><p>控制连接：带外（out of band）传送</p></li><li><p>FTP带内是传输数据的（20号端口），带外是传送控制信号（21号端口）</p></li><li><p>FTP是有状态的协议</p><ul><li>FTP服务器维护用户的状态信息：当前路径、用户账户与控制连接对应</li></ul></li><li><p>FTP命令、响应都是ASCII文本形式</p><ul><li>FTP命令：在控制连接上以ASCII文本方式传送</li></ul><blockquote><p>USER username</p><p>PASS password </p><p>LIST：请服务器返回远程主机当前目录的文件列表 </p><p>RETR filename：从远程主机的当前目录检索文件 (gets) </p><p>STOR filename：向远程主机的当前目录存放文件(puts)</p></blockquote><blockquote><p>注：</p><p>上载：客户端向服务器发数据</p><p>下载：服务器向客户端发数据</p></blockquote><ul><li>返回码：</li></ul><blockquote><p>状态码和状态信息（同HTTP）</p><p>331 Username OK,  password required </p><p>125 data connection  already open;  transfer starting </p><p>425 Can’t open data  connection </p><p>452 Error writing  file</p></blockquote></li></ul><h4 id="4-3-EMail"><a href="#4-3-EMail" class="headerlink" title="4.3 EMail"></a>4.3 EMail</h4><ul><li><p>email的3个主要组成部分：</p><ul><li><p>用户代理</p><ul><li>又名“邮件阅读器”</li><li>撰写、编辑和阅读邮件，如Outlook、Foxmail等</li><li>输出和输入邮件保存在服务器上</li></ul></li><li><p>邮件服务器</p><ul><li>邮件服务器中输出报文队列保存并依此发送待发送邮件报文</li><li>邮箱中管理和维护发送给用户的邮件</li><li>邮件服务器之间的SMTP协议：发送Email报文<ul><li>客户端：发送方邮件服务器</li><li>服务器：接受方邮件服务器</li></ul></li></ul><blockquote><p>一封邮件发送过程：<br>用户通过用户代理撰写邮件，然后通过用户代理经SMTP协议发送邮件到邮件服务器中的输出邮件队列中。该服务器作为发送方邮件服务器，通过SMTP协议找到并将邮件接收方邮件服务器。接受方服务器将接受到的邮件放到服务器中相应用户邮箱中，目标用户再经用户代理通过拉取邮件的协议（POP3等）拉取邮箱中自己收到的邮件。</p></blockquote><blockquote><p>用户代理向服务器发邮件，用户是client，邮件服务器是sever。</p><p>发送方邮件服务器向接收方邮件服务器发邮件，发送方邮件服务器是client，接收方邮件服务器是sever。</p></blockquote><blockquote><p>发送方的邮件服务器必须能处理接收方服务器的故障，如果发送方的服务器不能将邮件交付给接收方的服务器，发送方将在一个报文队列中保持该邮件并之后再尝试发送报文，如果一直失败，服务器就会删除该邮件，并以邮件方式通知发送用户。</p></blockquote></li><li><p>简单邮件传输协议：SMTP</p><ul><li><p>SMTP使用TCP在客户端和服务器之间传送报文，端口号为25</p></li><li><p>SMTP为直接传输：从发送方服务器到接收方服务器，邮件并不在中间的某个服务器停留</p></li><li><p>传输的3个阶段：</p><ul><li>握手</li><li>持续传输报文</li><li>关闭</li></ul><blockquote><p>SMTP是持续连接：如果发送邮件服务器有多个邮件，它可以通过同一TCP连接发送这些邮件。</p></blockquote></li><li><p>命令/响应交互</p><ul><li>命令：ASCII文本</li><li>响应：状态码和状态信息</li></ul></li><li><p>SMTP要求报文（首部和主体）必须为7位ASCII码</p></li></ul><blockquote><p>这将限制SMTP的数据传输，即在SMTP传输邮件之前，需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应ASCII码邮件解码还原成多媒体数据。HTTP传输不需要将多媒体数据编码成ASCII码。</p></blockquote><ul><li>SMTP服务器使用CRLF.CRLF决定报文的尾部</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210411205241273.png" alt="EMail原理"></p><ul><li><p>SMTP与HTTP比较：</p><ul><li>HTTP：拉（pull）</li><li>SMTP：推（push）</li><li>两者都是ASCII形式的命令、响应交互、状态码</li></ul><blockquote><p>对于多媒体…</p></blockquote><ul><li>HTTP：每个对象封装在各自的响应报文中</li><li>SMTP：多个对象包含在一个报文中</li></ul><blockquote><p>解释：</p></blockquote></li><li><p>SMTP：交换Email报文的协议     </p><ul><li><p>RFC 822：文本报文的标准：</p><ul><li><p>首部行：如，</p><ul><li>To:</li><li>From:</li><li>Subject:</li></ul><p>与SMTP命令不同</p><blockquote><p>???</p></blockquote></li><li><p>主体</p><ul><li>报文，只能是ASCII码字符</li></ul></li></ul></li><li><p>多媒体拓展的报文格式</p><ul><li>MIME：多媒体邮件扩展（multimedia mail extension）   RFC  2045，2056</li><li>在报文首部用额外的行声明MIME内容类型</li></ul><p><img src="/2021/04/10/jsjwl02/image-20210412145320300.png" alt="MIME"></p></li></ul></li></ul></li></ul></li><li><p>EMail协议</p><p><img src="/2021/04/10/jsjwl02/image-20210412145541524.png" alt="Email协议"></p><ul><li><p>发送的协议：简单邮件传输协议：SMTP</p><blockquote><p>传送到接受方的邮件服务器</p></blockquote></li><li><p>拉取的协议：POP3，IMAP，HTTP   </p><blockquote><p>用于邮件访问</p></blockquote></li></ul></li><li><p>邮件访问协议</p><ul><li>邮件访问协议：从服务器访问邮件<ul><li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul><li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li></ul></li><li>IMAP：Internet邮件访问协议（Internet Mail Access  Protocol）[RFC 1730] <ul><li>更多特性 (更复杂) </li><li>在服务器上处理存储的报文</li></ul></li><li>HTTP：Hotmail , Yahoo! Mail等 <ul><li>方便</li></ul></li></ul></li><li>POP3协议<ul><li>用户确认阶段 <ul><li>客户端命令： <ul><li>user: 申明用户名</li><li>pass: 口令 </li></ul></li><li>服务器响应 <ul><li>+OK</li><li>-ERR </li></ul></li></ul></li><li>事物处理阶段, 客户端： <ul><li>list: 报文号列表 </li><li>retr: 根据报文号检索报文 </li><li>dele: 删除 </li><li>quit</li></ul></li></ul></li><li></li></ul></li></ul><h3 id="5-Socket（套接字）编程"><a href="#5-Socket（套接字）编程" class="headerlink" title="5 Socket（套接字）编程"></a>5 Socket（套接字）编程</h3><p><img src="/2021/04/10/jsjwl02/image-20210329092824673.png" alt="网络程序设计接口"></p><ul><li><p>网络应用是在应用层中运行的应用进程之间的通信。应用进程使用<strong>传输层提供的服务</strong>才能够交换报文，实现<strong>应用层协议</strong>，实现应用</p></li><li><p>应用进程与底层协议之间的桥梁：应用编程接口API</p><p>API就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。应用进程通过API将控制权交给操作系统，操作系统调用相应过程，然后将结果传输回应用进程。</p><blockquote><p>传输层以及以下的四层往往由操作系统控制。</p></blockquote></li></ul><p><img src="/2021/04/10/jsjwl02/image-20210329094838806.png" alt="五层结构"></p><ul><li>典型的应用编程接口：<ul><li>Berkeley UNIX操作系统   套接字接口（socket interface），简称套接字（socket）</li><li>Windows 上     基于socket的稍不同的API：  WINSOCK</li><li>AT&amp;T为其UNIX系统V定义的一种API：TLI（Transport Layer Interface）</li></ul></li><li></li></ul><p>TCP/IP  应用进程使用Socket API访问传输服务</p><p>地点：界面上的SAP（socket）方式：Socket API  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络绪论</title>
      <link href="2021/04/05/jsjwl01/"/>
      <url>2021/04/05/jsjwl01/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络绪论"><a href="#计算机网络绪论" class="headerlink" title="计算机网络绪论"></a>计算机网络绪论</h2><blockquote><ul><li>主要参考书籍：<ul><li>《计算机网络：自顶向下方法》（James F.Kurose、Keith W.Ross)</li></ul></li><li>主要参考视频：<ul><li><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=8">中科大郑烇老师全套《计算机网络》</a></li><li><a href="https://www.bilibili.com/video/BV1Up411Z7hC?p=1&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1598544022&unique_k=eeA2CI">哈尔滨工业大学 计算机网络</a></li><li><a href="https://www.bilibili.com/video/av64605483/">计算机网络微课堂</a></li></ul></li><li>其他参考文献：<ul><li><a href="https://blog.csdn.net/qq_39326472/article/details/88089747?utm_source=app&app_version=4.5.4">计算机网络（自顶向下方法）学习笔记(头秃的女程序员)</a></li></ul></li></ul></blockquote><span id="more"></span><h3 id="1-计算机网络定义"><a href="#1-计算机网络定义" class="headerlink" title="1. 计算机网络定义"></a>1. 计算机网络定义</h3><p>​    计算机网络=通信技术+计算机技术</p><p>​    计算机网络就是一种通信网络。</p><ul><li><p>定义：计算机网络就是互连的、自治的计算机集合。</p><p> 自治-无主从关系 互连-互联互通</p><p>距离远、数量大如何保证互连？通过交换网络互连主机</p></li></ul><h3 id="2-Internet"><a href="#2-Internet" class="headerlink" title="2. Internet"></a>2. Internet</h3><ul><li><p>全球最大的互联网络：Internet<br>ISP(Internet Service Provider)网络互连的“网络之网络”</p></li><li><p>Internet组成：<br>计算设备集合</p><blockquote><p>· 主机（hosts）=端系统（end systems）<br>· 运行各种网络应用</p></blockquote><p>通信链路</p><blockquote><p>光纤，铜缆，无线电，卫星……</p></blockquote><p>分组交换：转发分组（数据包）</p><blockquote><p>路由器（routers）和交换机（switches）</p></blockquote></li><li><p>Internet提供的服务：</p><ul><li>为网络应用提供通信服务的通信基础设施</li></ul><blockquote><p>Web, VoIP, email, 网络游戏, 电子商务, 社交网络, …</p></blockquote><ul><li>为网络应用提供应用编程接口（API）</li></ul><blockquote><p>· 支持应用程序“连接” Internet，发送/接收数据<br>· 提供类似于邮政系统的数据传输服务</p></blockquote></li></ul><h3 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3. 网络协议"></a>3. 网络协议</h3><ul><li><p>协议是计算机网络有序运行的重要保证<br>硬件（主机、路由器、通信链 路等）是计算机网络的基础<br>计算机网络中的数据交换必须遵守事先约定好的规则</p></li><li><p>网络通信：<br>通信主体是“机器”<br>交换“电子化”或 “数字化”消息<br>计算机网络的所有通信过程都必须遵守某种/些规则—协议</p></li><li><p>网络协议(network protocol)，简称为协议 ，是为进行网络中的数据交换而建立的规 则、标准或约定。</p><p>协议规定了通信实体之间所交换的消息的 格式、意义、顺序以及针对收到信息或发 生的事件所采取的“动作”（actions）</p></li><li><p>协议的三要素：<br>语法（Syntax） </p></li></ul><blockquote><p> 数据与控制信息的结构或格式  信号电平 </p></blockquote><p>语义（Semantics） </p><blockquote><p> 需要发出何种控制信息  完成何种动作以及做出何种响应  差错控制  </p></blockquote><p>  时序（Timing） </p><blockquote><p> 事件顺序  速度匹配</p></blockquote><ul><li><p>Internet协议标准</p><p>RFC: Request for Comments </p><p>IETF:互联网工程任务组（ Internet Engineering Task  Force）</p></li></ul><h3 id="4-计算机网络的结构"><a href="#4-计算机网络的结构" class="headerlink" title="4. 计算机网络的结构"></a>4. 计算机网络的结构</h3><h4 id="4-1-计算机网络的结构"><a href="#4-1-计算机网络的结构" class="headerlink" title="4.1 计算机网络的结构"></a>4.1 计算机网络的结构</h4><ul><li>网络边缘</li></ul><blockquote><p>主机<br>网络应用</p></blockquote><ul><li>接入网络，物理介质</li></ul><blockquote><p>有线或无线通信链路</p></blockquote><ul><li>网络核心（核心网络）</li></ul><blockquote><p>互联的路由器（或分组转发设备）<br>网络之网络</p></blockquote><h4 id="4-2-网络边缘"><a href="#4-2-网络边缘" class="headerlink" title="4.2 网络边缘"></a>4.2 网络边缘</h4><ul><li>主机（端系统）<ul><li>位于“网络边缘”</li><li>运行网络应用程序</li></ul></li></ul><blockquote><ul><li>客户/服务器（client/server）应用模型<ul><li>客户发送请求，接受服务器响应</li></ul></li><li>对等（peer-peer，P2P）应用模型<ul><li>无（或不仅依赖）专用服务器</li><li>通信在对等实体之间直接进行</li></ul></li></ul></blockquote><ul><li>如何将网络边缘接入核心网（边缘路由器）？   接入网络</li></ul><h4 id="4-3-接入网络"><a href="#4-3-接入网络" class="headerlink" title="4.3 接入网络"></a>4.3 接入网络</h4><ul><li><p>接入网络：数字用户线路（DSL）</p><ul><li>利用已有的电话线连接中心局的DSLAM</li><li>非对称的 ：<br>上行传输速率&lt;2.5Mbps     下行传输速率&lt;24Mbps</li><li>FDM ：频分多路复用<br>50 kHz - 1 MHz用于下行 4 kHz - 50 kHz用于上行 0 kHz - 4 kHz用于传统电话</li></ul></li><li><p>接入网络：电缆网络</p><ul><li>HFC:混合光纤同轴电缆（ hybrid fiber coax）<br>非对称: 下行高达30Mbps传输速率，上行为2 Mbps传 输速率</li><li>频分多路复用</li><li>各家庭（设备）通过电缆网络→光纤接入ISP路由器<br>各家庭共享家庭至电缆头端的接入网络<br>不同于DSL的独占至中心局的接入</li></ul></li><li><p>机构（企业）接入网络（Ethernet）<br><em>Ethernet</em>一般指以太网。以太网是一种计算机局域网技术。</p><p>主要用于公司、高校、企业等组织机构<br>典型传输速率：10 Mbps, 100Mbps, 1Gbps, 10Gbps<br>目前，端系统通常直接连接以太网交换机（switch）</p></li><li><p>无线接入网络</p><p>通过共享的无线接入网络连接端系统与路由器 （通过基站（base station）或称为“接入点”（access point））</p></li></ul><p>  <img src="/2021/04/05/jsjwl01/image-20210324200838785.png" alt="image-20210324200838785"></p><h4 id="4-4-网络核心"><a href="#4-4-网络核心" class="headerlink" title="4.4 网络核心"></a>4.4 网络核心</h4><ul><li><p>网络核心：互联的路由器网络</p></li><li><p>网络核心的关键功能：路由+转发</p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324201246749.png" alt="image-20210324201246749"></p><ul><li><p>ISP（互联网服务提供商（Internet Service Provider））</p></li><li><p>端系统通过接入ISP（access ISPs ）连接到 Internet，接入ISP必须进一步互连，这样任意两个主机才可以互相发送分组 。这就构成复杂的网络互连的网络。（经济和国家政策是网络演进的主要驱动力）</p></li><li><p>接入ISP包括住宅、学校、公司、移动网络的基站等</p></li><li><p>Internet结构</p><blockquote><p>access net 接入网络    ISP 互联网服务提供商</p></blockquote></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324202751918.png" alt="image-20210324202751918"></p><blockquote><p>对等链路、IXP都是连接ISP的结构，其中IXP可以实现多个ISP的连接</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210324202847419.png" alt="image-20210324202847419"></p><blockquote><p>局域ISP进一步细化</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210324202906584.png" alt="image-20210324202906584"></p><blockquote><p>ISP是提供接入网络的<br>ICP（内容供应商）是提供业务、服务的<br>ICP也需要ISP来接入网络，成本高，提供网质量不高，所以后来大型的ICP（例如Google等）在全球部署数据中心机房（DC）利用专用电缆、光缆将DC连接，再接入ISP，来降低成本，提高用户体验</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210324202942386.png" alt="image-20210324202942386"></p><ul><li>Internet结构<ul><li>划分方式一：互联网分为结点和链路。主机结点称为网络边缘，网络交换结点和交换结点以及链路称为网络核心，将网络边缘接入网络核心的链路称为接入网络。</li><li>划分方式二：接入ISP汇集到区域ISP，区域ISP再汇集到一级ISP。</li></ul></li></ul><h4 id="4-6-数据交换"><a href="#4-6-数据交换" class="headerlink" title="4.6 数据交换"></a>4.6 数据交换</h4><ul><li><p>网络核心是为了解决将源主机发送的数据通过网络核心成功地传递给目的主机        –通过数据交换实现。</p></li><li><p>数据交换的类型：<br>电路交换      报文交换     分组交换</p></li></ul><h5 id="4-6-1-电路交换"><a href="#4-6-1-电路交换" class="headerlink" title="4.6.1 电路交换"></a>4.6.1 电路交换</h5><ul><li>最典型的电路交换网络：电话网络</li><li>电路交换的三个阶段：<br>建立连接（呼叫/电路建立）      通信       释放连接（拆除电路）</li><li>电路交换是独占资源的</li><li>电路交换网络如何共享中继线？    多路复用</li></ul><h5 id="4-6-2-多路复用"><a href="#4-6-2-多路复用" class="headerlink" title="4.6.2 多路复用"></a>4.6.2 多路复用</h5><ul><li><p>多路复用(multiplexing)，简称复用，是通信技术 中的基本概念。</p></li><li><p>多路复用(Multiplexing): 链路/网络资源（如带宽）划分为“资源片” 。<br>将资源片分配给各路“呼 叫”（calls）<br>每路呼叫独占分配到的资源片进行通信<br>资源片可能“闲置”(idle)  (无共享)</p></li><li><p>典型多路复用方法:<br>频分多路复用( frequency  division multiplexing-FDM )<br>时分多路复用( time division  multiplexing-TDM )<br>波分多路复用(Wavelength  division multiplexing-WDM)<br>码分多路复用( Code  division multiplexing-CDM )</p></li><li><p>频分多路复用FDM<br><img src="/2021/04/05/jsjwl01/image-20210324203913089.png" alt="image-20210324203913089"><br>频分多路复用的各用户占用不同的带宽资源（请注意，这里的“带宽 ”是频率带宽（单位：Hz）而不是数据的发送速率）。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<br><img src="/2021/04/05/jsjwl01/image-20210324204022544.png" alt="image-20210324204022544"></p></li><li><p>时分多路复用TDM<br>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧），每个用户在每个 TDM 帧中占用固定序号的时隙。<br>每用户所占用的时隙是周期性出现（其周期就是 TDM 帧的长度）。</p><p><img src="/2021/04/05/jsjwl01/image-20210324204152398.png" alt="image-20210324204152398"></p><p>时分复用的所有用户是在不同的时间占用相同的频带宽度</p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324204209123.png" alt="image-20210324204209123"></p><ul><li>波分多路复用WDM<br>波分复用就是光的频分复用</li><li>码分多路复用CDM<img src="/2021/04/05/jsjwl01/image-20210324204526439-1618041462218.png" alt="image-20210324204537250"></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324204537250-1618041480074.png" alt="image-20210324204537250"></p><p><img src="/2021/04/05/jsjwl01/image-20210324204607434.png" alt="image-20210324204607434"></p><p><img src="/2021/04/05/jsjwl01/image-20210324204619871.png" alt="image-20210324204619871"></p><h5 id="4-6-3-报文交换"><a href="#4-6-3-报文交换" class="headerlink" title="4.6.3 报文交换"></a>4.6.3 报文交换</h5><ul><li><p>报文：源（应用）发送信息整体，比如：一个文件。</p></li><li><p>报文交换（message switching)</p></li></ul><h5 id="4-6-4-分组交换"><a href="#4-6-4-分组交换" class="headerlink" title="4.6.4 分组交换"></a>4.6.4 分组交换</h5><ul><li><p>分组：报文拆分出来的一系列相对较小的数据包。<br><img src="/2021/04/05/jsjwl01/image-20210324205156713.png" alt="image-20210324205156713"></p></li><li><p>分组交换需要报文的拆分和重组，会产生额外的开销。</p></li><li><p>分组交换中是按需共享链路（statistical multiplexing）的，不同设备的分组序列不确定，所以分组交换又称：统计多路复用。</p></li><li><p>报文交换和分组交换均采用存储-转发（store-and-forward）交换方式。<br>区别：报文交换是以完整报文进行“存储-转发”，而分组交换是以较小的分组进行“存储-转发”。</p></li><li><p>传输延迟：<br>分组传输延迟（delay）=分组（packets）/链路传输速率</p></li><li><p>报文交换 vs 分组交换<br>分组交换总传输延迟更小，所需要路由器的带宽更小。</p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210324211945460.png" alt="image-20210324211945460"></p><ul><li><p>例：<br><img src="/2021/04/05/jsjwl01/image-20210324212548450.png" alt="image-20210324212548450"></p><p><img src="/2021/04/05/jsjwl01/image-20210324212606781.png" alt="image-20210324212606781"></p></li><li><p>电路交换 vs 分组交换<br>分组交换资源共享率更高，让更多用户共享网络资源。<br>分组交换适用于突发数据传输网络，可以资源充分共享，同时简单、无需呼叫建立。///////////////////////////TCP三次握手？<br>分组交换可能产生拥塞（congestion）：分组延迟和丢失。（需要用协议处理可靠数据传输和拥塞控制）</p></li><li><p>问题：分组交换如何提供电路级性能保障？</p></li></ul><ul><li>分组丢失</li></ul><h4 id="4-7-计算机网络性能"><a href="#4-7-计算机网络性能" class="headerlink" title="4.7 计算机网络性能"></a>4.7 计算机网络性能</h4><ul><li><p>速率<br>速率即数据率（data rate）、数据传输速率、比特率（bit rate）</p><ul><li><p>单位时间（秒）传输信息（比特）量</p></li><li><p>计算机网络中最重要的一个性能指标</p></li><li><p>单位：b/s（或bps） kb/s、Mb/s、Gb/s</p></li><li><p>k=10^3        M=10^6      G=10^9</p></li><li><p>速率往往是指额定速率或者标称速率，实际很难达到。</p></li></ul></li><li><p>带宽</p><ul><li><p>带宽（bandwidth）原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</p></li><li><p>网络中的带宽通常是指数字信道所能传送的“最高数据率”，单位：b/s（bps）</p></li><li><p>常用单位：kb/s、Mb/s、Gb/s、Tb/s</p></li><li><p>k=10^3        M=10^6      G=10^9    T=10^12</p></li></ul></li><li><p>延迟/时延（delay或latency）</p></li></ul><p>分组交换为什么会发生丢包？</p><p>分组在路由器缓存中排队，分组到达速率超过输出链路容量时/路由器缓存不足以存储分组，就会发生丢包。</p><p>时延：分组排队，等待输出链路可用</p><p><img src="/2021/04/05/jsjwl01/image-20210331170923229.png" alt="image-20210331170923229"></p><ul><li><p>四种分组延迟</p><p><img src="/2021/04/05/jsjwl01/image-20210331172225453.png" alt="image-20210331172225453"></p><ul><li><p>d<sub>proc</sub>：结点处理延迟（nodal processing delay）</p><p>处理时延是因为节点需要解析分组的必要信息然后决定其出链路（索引转发表等操作）而产生的，通常在微秒或者更低数量级；</p></li><li><p>d<sub>queue</sub>：排队延迟（queueing delay）</p><p>排队时延是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的；一般来说，排队时延是到达该队列的流量强度和性质的函数，通常可以达到毫秒级到微秒级；</p></li><li><p>d<sub>trans</sub>：传输延迟（transmission delay）</p><p>传输时延是将所有分组的比特推向链路所有需要的时间，实际的传输时延通常在毫秒到微秒数量级。</p><ul><li>L：分组长度（bits）</li><li>R：从路由器A到B的链路传输速率/链路带宽（bps）</li><li>d<sub>trans</sub>=L/R</li></ul></li><li><p>d<sub>prop</sub>：传播延迟（propagation delay）</p><p>传播时延是指比特进入链路后，从该链路的起点到下一个结点所用的时间；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。</p><ul><li>d：物理链路长度</li></ul></li><li><p>s：信号传播速度（铜缆中电信号速度0.7倍光速~2×10<sup>8</sup>m/sec）</p><ul><li>d<sub>prop</sub>=d/s</li></ul><blockquote><p><strong>传输时延和传播时延的对比</strong></p><p>传输时延是传输一个分组的时间，传播时延是分组从一个结点到另一个结点的时间。如果打个比方的话，传输时延就是大卡车经过收费站的时间而传播时间就是车在高速公路上行驶的时间。</p></blockquote><p>一跳的时间延迟（某一分组从到达一个结点到传播到下一个结点的时间）d<sub>nodal</sub>=d<sub>proc</sub>+d<sub>queue</sub>+d<sub>trans</sub>+d<sub>prop</sub></p></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331172851542.png" alt="image-20210331172851542"></p></li><li><p>排队延迟和丢包</p></li></ul><p>丢包：到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失</p><p>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；如果分组到达的速度高于结点的处理速度，那么分组就会在缓冲队列里排队等待。当缓冲空间用完后，如果还有到的分组，那么该分组将被迫丢弃。</p><p>为了描述网络状体，我们引入了流量强度这一概念：流量强度=分组到达的速度/结点的处理速度；流量工程里一个金科玉律就是：设计系统时流量强度不能大于1；</p><p>当流量强度持续大于1时，就将出现丢包现象。</p><blockquote><p>R：链路带宽（bps）   L：分组长度（bits）   a：平均分组到达速率</p><p>流量强度（traffic intensity）= La/R</p></blockquote><p><img src="/2021/04/05/jsjwl01/image-20210331173545650.png" alt="image-20210331173545650"></p><p><img src="/2021/04/05/jsjwl01/image-20210331173454963.png" alt="image-20210331173454963"></p><ul><li><p>时延带宽积/带宽时延积</p><p>时延带宽积 = 传播时延 × 带宽 = d<sub>prop</sub> × R （bits）</p><p><img src="/2021/04/05/jsjwl01/image-20210331173859612.png" alt="image-20210331173859612"></p><blockquote><p>时延带宽积表示链路能够容纳的比特位</p><p>链路的时延带宽积又称为以比特为单位的链路长度</p></blockquote></li><li><p>分组丢失（丢包）</p><ul><li>队列缓存有限，分组到达已满队列将被丢弃（丢失），丢弃分组可能由前序结点或者源重发（也可能不重发）</li><li>丢包率 = 丢包数 / 已发分组总数</li></ul></li><li><p>吞吐量/率（Troughput）</p><ul><li><p>表示在发送<strong>端</strong>与接受<strong>端</strong>之间传送数据速率（b/s）</p><ul><li>即时吞吐率：给定时刻的速率</li><li>平均吞吐量：一段时间的平均速率</li></ul><blockquote><p>吞吐量可以近似为源和目的地之间路径的最小传输速率。最小传输速率的链路为<strong>瓶颈链路</strong>。吞吐量取决于瓶颈链路（bottleneck link），瓶颈链路：端到端路径上，限制端到端吞吐量的链路</p></blockquote></li></ul></li></ul><h3 id="5-计算机网络体系结构概述"><a href="#5-计算机网络体系结构概述" class="headerlink" title="5. 计算机网络体系结构概述"></a>5. 计算机网络体系结构概述</h3><h4 id="5-1-分层结构"><a href="#5-1-分层结构" class="headerlink" title="5.1 分层结构"></a>5.1 分层结构</h4><ul><li><p>采用分层结构来研究计算机网络体系结构，每层完成一类特定功能/服务，每层依赖底层提供的服务，通过层内动作完成相应功能</p></li><li><p>网络体系结构是从功能上描述计算机网络结构</p></li><li><p>计算机网络体系结构简称网络体系结构是分层结构，每层遵循某个/些网络协议完成本层功能。计算机网络体系结构是计算机网络的各层以及其协议的集合，是计算机网络的功能层次以及关系的定义，是抽象的。</p></li><li><p>分层结构<br>优点</p><ul><li>结构清晰，有利于识别复杂系统的部件以及关系</li><li>模块化的分层易于系统更新、维护</li><li>有利于标准化</li></ul><p>缺点</p><ul><li>分层过多可能导致效率较低，例：某层的功能可能需要仅在其它层才出现的信息</li></ul></li><li><p>功能上的冗余，比如许多协议栈针对链路和端到端两种情况都提供了差错恢复功能</p></li><li><p><img src="/2021/04/05/jsjwl01/image-20210331182052218.png" alt="image-20210331182052218"></p><ul><li>实体（entity）表示任何可发送或者接受信息的硬件或者软件进程</li><li>协议是控制两个对等实体进行通信的规则的集合，协议是“水平的”</li><li>任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是“垂直的”</li><li>下层协议的实现对上层的服务用户是透明的</li><li>同系统的相邻层实体间通过接口进行交互，通过服务访问点SAP（Service Access Point），交换原语，指定请求的特定服务</li></ul></li></ul><h4 id="5-2-OSI参考模型"><a href="#5-2-OSI参考模型" class="headerlink" title="5.2 OSI参考模型"></a>5.2 OSI参考模型</h4><ul><li><p>OSI参考模型</p><ul><li><p>开放系统互联（OSI）参考模型是由国际标准化组织(ISO)于1984年提出的分层网络体系结构模型<br>目的是支持异构网络系统的互联互通<br>异构网络系统互连的国际标准理解网络通信的最佳学习工具(理论模型)</p><blockquote><p>理论成功，市场失败</p></blockquote><p>7层(功能）,每层完成特定的网络功能</p></li></ul></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331182931687.png" alt="image-20210331182931687"></p><ul><li>OSI通信过程</li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331183505710.png" alt="image-20210331183505710"></p><blockquote><p>前四层称为“端到端层（end-end）”</p></blockquote><ul><li><p>数据封装与解封装</p><p><img src="/2021/04/05/jsjwl01/image-20210331183955509.png" alt="image-20210331183955509"></p><ul><li>为什么需要数据封装？<ul><li>增加控制信息<ul><li>构造协议数据单元（PDU）</li></ul></li><li>控制信息主要包括<ul><li>地址（Address）：标识发送端/接受端</li><li>差错检测编码（Error-detecting code）：用于差错检测或者纠正（有的协议有，有的协议没有）</li><li>协议控制（Protocol control）：实现协议功能的附加信息，如：优先级（priority）、服务质量（Qos）和安全控制等</li></ul></li></ul></li></ul></li><li><p>物理层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331184757076.png" alt="image-20210331184757076"></p><ul><li>接口特性<ul><li>机械特性、电气特性、功能特性、规程特性</li></ul></li><li>比特编码</li><li>数据率</li><li>比特同步<ul><li>时钟同步</li></ul></li><li>传输模式<ul><li>单工（Simplex）：只能单向传输</li><li>半双工（half-duplex）：可以双向进行，但是同一时刻只能一个方向进行</li><li>全双工（full-duplex）：可以同时进行双向传输</li></ul></li></ul></li><li><p>数据链路层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331185211807.png" alt="image-20210331185211807"></p><ul><li>负责结点-结点（node-to-node）数据传输</li><li>组帧（Framing），加头加尾，为了接收端物理层可以切分数据流成帧</li><li>物理寻址（Physical addressing）<ul><li>在帧头中增加发送结点和/或接受结点的物理地址标识数据帧的发送和/接收端</li></ul></li><li>流量控制（Flow control）<ul><li>避免淹没接受端</li></ul></li><li>差错控制（Error control）<ul><li>检测并重传损坏或丢失帧，并避免重复帧</li></ul></li><li>访问（接入）控制（Access control）<ul><li>在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权</li></ul></li></ul></li><li><p>网络层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331190332672.png" alt="image-20210331190332672"></p><ul><li>负责源主机到目的主机数据分组（packet）交付<ul><li>可能穿越多个网络–逻辑寻址</li></ul></li><li>逻辑寻址（Logical addressing）<ul><li>全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址</li></ul></li><li>路由（Routing）<ul><li>路由器（或网关）互连网络，并路由分组至最终目的主机</li><li>路径选择</li></ul></li><li>分组转发</li></ul></li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331190643191.png" alt="image-20210331190643191"></p><blockquote><p>红色S、A等表示网络层地址（逻辑地址）不变，绿色02、27等表示数据链路层地址（物理地址）会改变</p></blockquote><ul><li><p>传输层功能</p><p>负责源-目的（端-端）（进程间）完整报文传输</p><p><img src="/2021/04/05/jsjwl01/image-20210331191041188.png" alt="image-20210331191041188"></p><ul><li><p>分段与重组</p></li><li><p>SAP寻址</p><ul><li>确保将完整报文提交给正确的进程，如端口号</li></ul><p><img src="/2021/04/05/jsjwl01/image-20210331191406873.png" alt="image-20210331191406873"></p></li><li><p>连接控制  （逻辑连接，不是电路连接）</p></li><li><p>流量控制（端到端）</p></li><li><p>差错控制</p></li></ul></li><li><p>会话层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331191850256.png" alt="image-20210331191850256"></p><ul><li>对话控制（dialog controlling）<ul><li>建立、维护</li></ul></li><li>同步（synchronization）<ul><li>在数据流中插入“同步点”（syn），可以在对话出现差错时就近恢复</li></ul></li></ul></li><li><p>表示层功能</p><p>处理两个系统间交换信息的语法与语义（syntax and semantics）问题</p><p><img src="/2021/04/05/jsjwl01/image-20210331191950105.png" alt="image-20210331191950105"></p><ul><li>数据表示转换<ul><li>发送端将信息转化为一种独立的不依赖于主机的编码，接收端接收到后将这种编码再转换为自身的编码信息</li></ul></li><li>加密/解密</li><li>压缩/解压缩</li></ul></li><li><p>应用层功能</p><p><img src="/2021/04/05/jsjwl01/image-20210331192404895.png" alt="image-20210331192404895"></p><ul><li>支持用户通过用户代理（如浏览器）或网络接口使用网络（服务）</li></ul></li></ul><h4 id="5-3-TCP-IP参考模型"><a href="#5-3-TCP-IP参考模型" class="headerlink" title="5.3 TCP/IP参考模型"></a>5.3 TCP/IP参考模型</h4><p><img src="/2021/04/05/jsjwl01/image-20210331192847062.png" alt="image-20210331192847062"></p><p><img src="/2021/04/05/jsjwl01/image-20210331192902759.png" alt="image-20210331192902759"></p><blockquote><p>网络接口层无具体协议，是链路层的简化</p></blockquote><h4 id="5-4-五层参考模型"><a href="#5-4-五层参考模型" class="headerlink" title="5.4 五层参考模型"></a>5.4 五层参考模型</h4><blockquote><p>综合OSI（理论清晰）和TCP/IP（实用，如今的Internet就是这样的结构）的优点</p></blockquote><p>各层的所有协议组合起来，称为<strong>协议栈</strong>。因特网的协议栈有5个层次组成：物理层、链路层、网络成、传输层、应用层</p><p><strong>应用层</strong>：应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为报文；<br><strong>传输层</strong>：传输层在应用程序端点之间传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为报文段。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。<br><strong>网络层</strong>：网络层将称为数据报的网络层分组从一台主机移动到另一台主机。网络层协议包含著名的IP协议以及其他一些路由选择协议。数据报<br><strong>链路层</strong>：链路层将称为帧的链路层分组从一个结点移动到路径上的另一个端点。一个帧可能被沿途不同链路上的不同链路层协议处理。帧<br><strong>物理层</strong>：物理层的任务是将帧中的比特从一个结点移动到下一个节点，它提供了传输信息的实际物理通道；<br><img src="/2021/04/05/jsjwl01/image-20210331193222684.png" alt="image-20210331193222684"></p><ul><li><p>五层模型的数据封装</p><p>​    <strong>封装</strong>：一个分组，在不同的层次有不同的称谓，是因为它们经过每一层的时候就被该层封装上了属于该层的相关信息，也就是前面提到的必要信息；于是，每一分层的分组有两种类型的字段：首部字段和有效负载；其中有效负载即为来自上一层的分组数据，而首部字段就是该层加上的必要信息；分组不断被封装以实现各层协议规定的相关功能。</p><p><img src="/2021/04/05/jsjwl01/image-20210331193541952.png" alt="image-20210331193541952"></p></li></ul><h3 id="6-计算机网络与Internet发展历史"><a href="#6-计算机网络与Internet发展历史" class="headerlink" title="6.计算机网络与Internet发展历史"></a>6.计算机网络与Internet发展历史</h3><p><img src="/2021/04/05/jsjwl01/image-20210331193804005.png" alt="image-20210331193804005"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194018327.png" alt="image-20210331194018327"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194416382.png" alt="image-20210331194416382"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194554759.png" alt="image-20210331194554759"></p><p><img src="/2021/04/05/jsjwl01/image-20210331194816888.png" alt="image-20210331194816888"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
