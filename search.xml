<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法TIPS-高精度计算以及压位</title>
      <link href="2022/04/03/%E7%AE%97%E6%B3%95TIPS_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E5%8E%8B%E4%BD%8D/"/>
      <url>2022/04/03/%E7%AE%97%E6%B3%95TIPS_%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%BB%A5%E5%8F%8A%E5%8E%8B%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>高精度计算，加法最多压9位（int类型），乘法最多压4位（int类型）。</p><h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><h2 id="不圧位代码"><a href="#不圧位代码" class="headerlink" title="不圧位代码"></a>不圧位代码</h2><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="压9位的代码"><a href="#压9位的代码" class="headerlink" title="压9位的代码"></a>压9位的代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % base);</span><br><span class="line">        t /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (a[i] - <span class="string">&#x27;0&#x27;</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A.<span class="built_in">push_back</span>(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (b[i] - <span class="string">&#x27;0&#x27;</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            B.<span class="built_in">push_back</span>(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; C.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%09d&quot;</span>, C[i]);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法TIPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法TIPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux常用命令</title>
      <link href="2022/04/02/tmux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
      <url>2022/04/02/tmux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><p><a href="https://blog.csdn.net/xunbaobao123/article/details/103400890">跑深度学习实验-shell脚本，tmux，pycharm小技巧_2020拯救世界的博客-CSDN博客_pycharm tmux</a></p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s xxx  # 新建一个终端窗体（伪终端）用来执行新的shell脚本，其中xxx为所设置的这个新窗体的名字，通常以你要跑的文件的名字命名</span><br></pre></td></tr></table></figure><p>当我们输入了对应的执行指令，现在想要开始跑第二个shell脚本实验，那就要先跳出这个窗体，回到我们真正的终端，通过<code>ctrl+b d</code>指令跳回一开始的终端。需要注意的是这实际上是两个步骤，ctrl+b然后再输入d跳回。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach -t XXX # 这条指令的意思就是由终端进入之前曾经创建好的窗体中去，如果xxx窗体不存在会报错</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls # 回到终端，通过`tmux ls`来对已创建的窗体进行一个遍历查看</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmux kill-session -t XXX </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建的的窗体还在而又用不到了，这时候通过tmux的<span class="built_in">kill</span>操作来删除它：</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tmux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda常用命令</title>
      <link href="2022/04/02/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2022/04/02/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># conda版本查看</span></span><br><span class="line">conda -V</span><br><span class="line">conda --version</span><br><span class="line"><span class="comment">#更新         </span></span><br><span class="line">conda update conda            <span class="comment">#更新conda</span></span><br><span class="line">conda update anaconda        <span class="comment">#更新anaconda</span></span><br><span class="line">conda update anaconda-navigator    <span class="comment">#update最新版本的anaconda-navigator</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看已安装的虚拟环境</span></span><br><span class="line">conda env <span class="built_in">list</span> </span><br><span class="line">conda info -e</span><br><span class="line">conda info –env</span><br><span class="line"> </span><br><span class="line"><span class="comment"># conda -create -n env_name list_of_packages# env_name是需要创建的环境名称，list_of_packages是在新环境中需要安装的工具包，有多个时用空格隔开# 创建一个名为的环境，指定Python版本是3.5（conda会自动寻找3.5.x中的最新版本）</span></span><br><span class="line"> </span><br><span class="line">conda create -n xxxx python=<span class="number">3.5</span></span><br><span class="line">conda create --name xxxx python=<span class="number">3.5</span></span><br><span class="line"> </span><br><span class="line">conda activate xxxx           <span class="comment">#开启xxxx环境</span></span><br><span class="line">conda deactivate              <span class="comment">#关闭环境</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 克隆环境，我想创建一个新环境BBB，完全克隆AAA的环境配置</span></span><br><span class="line">conda create -n BBB --clone AAA</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除一个已有的环境</span></span><br><span class="line">conda remove -n xxxx --<span class="built_in">all</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 环境重命名# conda没有重命名的命令，所以可以先 clone 一个环境，然后删除原有的环境</span></span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> conda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研-计算机网络03数据链路层</title>
      <link href="2022/04/01/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>2022/04/01/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>链路</strong>（Link）就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。<br><strong>数据链路</strong>（Data Link）是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。<br>数据链路层以<strong>帧</strong>为单位传输和处理数据。</p><span id="more"></span><p><img src="/2022/04/01/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-image-20220401210458194.png"></p><h2 id="数据链路层的三个重要问题"><a href="#数据链路层的三个重要问题" class="headerlink" title="数据链路层的三个重要问题"></a>数据链路层的三个重要问题</h2><p>对于点对点信道的数据链路层而言的三个问题：</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>添加帧头和帧尾，封装成帧<br><img src="/2022/04/01/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-image-20220401210809063.png"></p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>发送方在发送数据之前，会基于待发送的数据和检错算法计算出检错码，并将其封装在帧尾。<br>接收方接收到帧以后，会根据检错码和检错算法来检测帧中是否出现误码。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>接收方收到有误码的帧之后，会将该帧丢弃。如果数据链路层向上层提供的是可靠传输，该被丢弃的帧会被要求重新传输，如果提供的是不可靠传输，则不会重传。</p><h3 id="使用广播信道的数据链路层（共享式局域网）"><a href="#使用广播信道的数据链路层（共享式局域网）" class="headerlink" title="使用广播信道的数据链路层（共享式局域网）"></a>使用广播信道的数据链路层（共享式局域网）</h3><p>对于使用广播信道的数据链路层而言，除了上述三个问题，还需要考虑1. 编址问题 2. 碰撞。</p><h4 id="编址问题"><a href="#编址问题" class="headerlink" title="编址问题"></a>编址问题</h4><p>广播信道中，代表帧的信号会通过总线传输到总线的其他各主机。此时需要让所有接受到信息的主机自己判断数据是传输给谁的，其他主机需要自己丢弃这个帧。<br>方法：通过目的地址判断<br><img src="/2022/04/01/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C03%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-image-20220401211918110.png"></p><h4 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h4><p>碰撞问题是采用共享式局域网无法避免的问题。<strong>以太网</strong>的媒体接入控制协议采用一种特殊的协议<strong>CSMA/CD</strong>（载波监听多点接入/碰撞检测）来解决。</p><blockquote><p>交换式局域网，使用点对点链路和链路交换机的<strong>交换式局域网</strong>在有线领域已经完全取代了共享式局域网。<br>无线局域网仍然使用的是共享式局域网。例如802.11<strong>局域网</strong>采用的媒体接入控制协议是<strong>CSMA/CA</strong>（载波监听多点接入/碰撞避免）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 408 </tag>
            
            <tag> 王道 </tag>
            
            <tag> 湖科大 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-21红黑树、并查集</title>
      <link href="2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><blockquote><p>408新增考点：红黑树、并查集！</p></blockquote><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>平衡二叉树在插入时最多只需要两次旋转就会重新恢复平衡</strong>。<br>平衡二叉树在查找时有着二叉查找树的优越性，在插入时还能通过调整继续保持着。那么为什么还要使用到红黑树呢？可以从以下两个方面来考虑：</p><span id="more"></span><ol><li>删除：对于平衡二又树来说，在最坏情况下，需要维护从被删结点到根节点这条路径上所有节点的平衡性，旋转的量级是O(logN)。但是红黑树就不一样了，最多只需3次旋转就会重新平衡，旋转的量级是O(1)。</li><li>保持平衡︰平衡二叉树高度平衡，这也就意味着在大量插入和删除节点的场景下，平衡二叉树为了保持平衡需要调整的频率会更高。<br>注意：在大量查找的情况下，平衡二叉树的效率更高，也是首要选择。而在大量增删的情况下，红黑树是首选。<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>红黑树是一颗<strong>二叉搜索树</strong>，通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出两倍，因而是<strong>近似于平衡的</strong>。<br>(1) 结点是<mark style="background: #FF5582A6;">红色</mark> 或<mark style="background: #CACFD9A6;">黑色</mark> 。<br>(2) <strong>根结点</strong>是<strong>黑色</strong>。<br>(3) 每个 <strong>叶子节点（NIL）</strong> 都是<mark style="background: #CACFD9A6;">黑色的空节点</mark> 。<br>(4) 每个<strong>红色结点</strong>的两个子结点都是<strong>黑色</strong>。（从根节点到叶子结点的<mark style="background: #FF5582A6;">所有路径上不能有两个连续的红色结点</mark> ）<br>(5) 从<strong>任一确定的结点</strong>出发，到叶子结点的<mark style="background: #CACFD9A6;">所有路径都包含相同数目的黑色结点</mark> 。<br><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401170929086.png" alt="红黑树"><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3>从根到叶子的<strong>最长的</strong>可能路径不多于<strong>最短的</strong>可能路径的<strong>两倍长</strong>。所以保证了树的较弱的一个平衡性。<br>一颗有n个<strong>内部节点</strong>的红黑树的<strong>最大高度</strong>：<br>$$<br>2log_2(n+1)<br>$$<br>红黑树的查找、插入、删除、找最大值、找最小值等操作都是 <strong>O(logn)</strong> 的时间复杂度。<br>黑高（black-height）：从某个结点x出发（不含该节点）到达一个叶节点的任意一条简单路径上的黑色结点个数称为该节点的黑高，记为bh(x)。定义红黑树的黑高为其根节点的黑高。<blockquote><p>注：NIL的黑高为0。<br><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401191209880.png" alt="黑高"></p></blockquote><h3 id="平衡操作"><a href="#平衡操作" class="headerlink" title="平衡操作"></a>平衡操作</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4>#TODO 这里次数不确定，还有删除的最大递归次数也是不确定<blockquote><p>递归操作，但是最多递归h/2次？？？</p></blockquote></li></ol><p>默认插入红色<mark style="background: #FF5582A6;">结点</mark> ，先按照二叉搜索树的方式来插入，然后再调整。</p><h5 id="被插入的节点是根节点。"><a href="#被插入的节点是根节点。" class="headerlink" title="被插入的节点是根节点。"></a>被插入的节点是根节点。</h5><p>直接把此节点涂为<mark style="background: #CACFD9A6;">黑色</mark> 。</p><h5 id="被插入的节点的父节点是黑色。"><a href="#被插入的节点的父节点是黑色。" class="headerlink" title="被插入的节点的父节点是黑色。"></a>被插入的节点的父节点是黑色。</h5><p>什么也不需要做。</p><h5 id="被插入的节点的父节点是红色。"><a href="#被插入的节点的父节点是红色。" class="headerlink" title="被插入的节点的父节点是红色。"></a>被插入的节点的父节点是红色。</h5><ol><li>当前节点的祖父节点的另一个子节点（叔叔节点）也是<mark style="background: #FF5582A6;">红色</mark> 。<br>(1) 将“父节点”设为<mark style="background: #CACFD9A6;">黑色</mark> 。<br>(2) 将“叔叔节点”设为<mark style="background: #CACFD9A6;">黑色</mark> 。<br>(3) 将“祖父节点”设为<mark style="background: #FF5582A6;">红色</mark> 。<br>(4) 将“祖父节点”设为“当前节点”(红色节点)；即，<strong>之后继续对“当前节点”进行操作</strong>（递归进行）。<blockquote><p>叔父双红：叔父爷染色，爷结点变新</p></blockquote></li></ol><p><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401192053191.png" alt="叔父双红"></p><blockquote><p>注：不能只是单纯将5和8结点直接变为黑色，因为这样会导致这个<strong>子树</strong>的左右子树黑色结点数都加1。这时候从<strong>整棵树</strong>角度来看，一般就会不满足“从任一个确定节点出发，到每个叶结点的路径上黑节点数相同”的性质。</p></blockquote><ol start="2"><li>叔叔节点是黑色（或叶节点NIL），且当前节点是其父节点的右孩子<br>(1) 将“父节点”作为“新的当前节点”。<br>(2) 以“新的当前节点”为支点进行左旋。<blockquote><p>父红叔黑右孩子：父新左旋</p></blockquote></li></ol><p><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401192249108.png" alt="父红叔黑右孩子"><br>3. 叔叔节点是黑色（或叶节点NIL），且当前节点是其父节点的左孩子<br>(1) 将“父节点”设为“黑色”。<br>(2) 将“祖父节点”设为“红色”。<br>(3) 以“祖父节点”为支点进行右旋。</p><blockquote><p>父红叔黑左孩子：父黑爷红，爷右旋</p></blockquote><p><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401192554933.png" alt="父红叔黑左孩子"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>删除也是递归操作，最多操作O(logn)次</p></blockquote><p>先按照二叉搜索树的方式删除：</p><ol><li>删除<mark style="background: #FF5582A6;">红色结点</mark> ，直接删除即可，<strong>无需再继续调整。</strong></li><li>删除只有一个孩子的<mark style="background: #CACFD9A6;">黑色结点</mark> ，将这个孩子提上来，并将颜色累加到这个孩子上。所以暂时这个孩子的颜色是“红+黑”或“黑+黑”。</li><li>删除有两个孩子的<mark style="background: #CACFD9A6;">黑色结点</mark> ，按照二叉搜索树的方法找左子树的最右结点（或右子树的最左结点）的值作为该结点的值（颜色不变），并删除那个最右（左）结点。然后就是讨论这个最右（左）结点怎么删除（必然为只有一个或零个孩子的结点）。</li><li>删除没有孩子的<mark style="background: #CACFD9A6;">黑色结点</mark> ，由于红黑树性质叶节点为NIL的黑色结点。所以暂时这个孩子的颜色是“黑+黑”。<br>然后再调整：<h5 id="x指向一个“红-黑”节点"><a href="#x指向一个“红-黑”节点" class="headerlink" title="x指向一个“红+黑”节点"></a>x指向一个“红+黑”节点</h5>将x设为一个“黑”节点即可。<h5 id="x指向根结点"><a href="#x指向根结点" class="headerlink" title="x指向根结点"></a>x指向根结点</h5>将x设为一个“黑”节点即可。<h5 id="x指向一个“黑-黑”结点且不是根节点"><a href="#x指向一个“黑-黑”结点且不是根节点" class="headerlink" title="x指向一个“黑+黑”结点且不是根节点"></a>x指向一个“黑+黑”结点且不是根节点</h5><h6 id="x的兄弟节点是红色"><a href="#x的兄弟节点是红色" class="headerlink" title="x的兄弟节点是红色"></a>x的兄弟节点是红色</h6>(1) 将x的兄弟节点设为“黑色”。<br>(2) 将x的父节点设为“红色”。<br>(3) 对x的父节点进行左旋。<br>(4) 左旋后，重新设置x的兄弟节点。<blockquote><p>这种情况的主要作用是让x的兄弟结点改为黑色的结点，变成情况2/3/4。</p></blockquote></li></ol><p><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401200737181.png"></p><h6 id="x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"><a href="#x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色" class="headerlink" title="x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色"></a>x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</h6><p>(1) 将x的兄弟节点设为“红色”。<br>(2) 设置“x的父节点”为“新的x节点”。将原x的一个黑色上移给新的x节点。</p><blockquote><p>这种情况的主要作用是将x的黑色上移一个。</p></blockquote><p><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401200719435.png"></p><h6 id="x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"><a href="#x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的" class="headerlink" title="x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的"></a>x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</h6><p>(1) 将x兄弟节点的左孩子设为“黑色”。<br>(2) 将x兄弟节点设为“红色”。<br>(3) 对x的兄弟节点进行右旋。<br>(4) 右旋后，重新设置x的兄弟节点。</p><blockquote><p>这种情况的主要作用是将x的右兄弟的右孩子变为红色，转换成情况4</p></blockquote><p><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401200705162.png"></p><h6 id="x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"><a href="#x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色" class="headerlink" title="x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色"></a>x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</h6><p>(1) 将x父节点颜色赋值给x的兄弟节点。<br>(2) 将x父节点设为“黑色”。<br>(3) 将x兄弟节点的右子节设为“黑色”。<br>(4) 对x的父节点进行左旋。此时就可以将x的一个黑色去掉。<br><img src="/2022/04/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98-21%E7%BA%A2%E9%BB%91%E6%A0%91_%E5%B9%B6%E6%9F%A5%E9%9B%86-image-20220401200623370.png"></p><blockquote><p>情况4直接实现符合红黑树要求</p></blockquote><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>用森林维护集合关系，支持<strong>合并两个集合</strong>、<strong>查询某个元素在哪个集合中</strong>等操作。</p><ol><li>合并两个集合：让两个树合并，让其中一颗树根节点指向另一个树的根节点</li><li>查询某个元素在哪个集合中：即看两个数的根节点是不是同一个<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3>(1) 路径压缩<br>某一个过程走过找到根节点之后的同时就让这个结点的指针指向根节点，这样之后就不会再重复进行过程的搜索。<br>(2) 按秩合并<br>是一种启发式合并。一般路径越长查找越慢，所以合并树时尽可能让树高度更小。一种启发式合并：尽可能让矮树插到高树里。<br>另一种启发式合并：让树结点少的合并到结点多的树中。<blockquote><p>只进行路径压缩优化时间复杂度是O(mlogn)（m是操作数，n是节点数），且近似O(1)；只进行按秩合并时间复杂度是O(logn)。如果两个优化同时进行，时间复杂度是O(1)。</p></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><a href="https://www.acwing.com/activity/content/problem/content/5916/">AcWing 836. 合并集合 - AcWing</a><br>—共有n个数，编号是1～n，最开始每个数各自在一个集合中。<br>现在要进行m个操作，操作共有两种:</li><li><code>M a b</code>，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，询问编号为a和b的两个数是否在同一个集合中；</li></ol><p><strong>输入格式</strong><br>第一行输入整数n和m。<br>接下来m行，每行包含一个操作指令，指令为 <code>M a b</code> 或 <code>Q a b</code> 中的一种。<br><strong>输出格式</strong><br>对于每个询问指令<code>Q a b</code>，都要输出一个结果，如果a和b在同一集合内，则输出<code>Yes</code>，否则输出<code>No</code> 。<br>每个结果占一行。<br><strong>数据范围</strong><br>$1 &lt; n,:m ≤10^5$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N], r[N]; <span class="comment">// p[N] 父结点（路径压缩后也可是根节点） r[N] 树高</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 查找根节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 合并 + 按秩合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r[a] &gt; r[b]) p[b] = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[a] = b;</span><br><span class="line">        <span class="keyword">if</span> (r[a] == r[b]) r[b] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i; <span class="comment">// 开始自成一组</span></span><br><span class="line">        r[i] = <span class="number">1</span>; <span class="comment">// 开始高度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">merge</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing算法基础课-05动态规划</title>
      <link href="2022/03/30/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE_05%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2022/03/30/AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE_05%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划模型"><a href="#动态规划模型" class="headerlink" title="动态规划模型"></a>动态规划模型</h1><p>关键找状态表示和状态计算。<br>先从最朴素的角度出发写出状态方程，然后再考虑优化，优化实际上就是状态方程的等价变化。</p><span id="more"></span><h2 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h2><p>==**背包问题的状态方程一般为两维<code>f[i][j]</code>**。==<br><strong>状态方程<code>f[i][j]</code>表示：只考虑前i个物品，且所有物品的体积和小于等于j的情况下的最大价值。</strong></p><blockquote><p>01背包、完全背包在<a href="AcWing%E7%AE%97%E6%B3%95%E9%A2%98_%E9%97%AB%E5%BC%8FDP%E6%B3%95.md">AcWing算法题_闫式DP法</a>有详细讲解</p></blockquote><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a><br>每个物品最多使用一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N], na, va;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; na &gt;&gt; va;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= na; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= na; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// f[i][j]  只考虑前i个物品，且总体积小于等于j 的最大价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = va; j &gt;= v[i]; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[va] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><a href="https://www.acwing.com/problem/content/description/3/">3. 完全背包问题 - AcWing题库</a><br>每个物品有无限个<br>f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f[i][j] 表示只考虑前i个物品，且总体积不超过i的最大总价值</span></span><br><span class="line">    <span class="comment">// f[i][j] = max(f[i - 1][j], f[i - 1][j - 1 * v[i]] + 1 * w[i], ...) </span></span><br><span class="line">    <span class="comment">// f[i][j - v[i]] + w[i] = max(f[i - 1][j - v[i]] + w[i], f[i - 1][j - 2 * v[i]] + 2 * w[i], ...)</span></span><br><span class="line">    <span class="comment">// f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i])</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i]; j &lt;= V; ++ j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[V] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><a href="https://www.acwing.com/problem/content/4/">4. 多重背包问题 I - AcWing题库</a><br>每个物品数量有各自限制</p><h4 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h4><p>和完全背包的朴素解法一致，只是对于k多了限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N]; </span><br><span class="line"><span class="comment">// f[i][j] 前i物品 体积小于等于j 最大价值</span></span><br><span class="line"><span class="comment">// f[i][j] = max(f[i - 1][j], f[i - 1][j - k * v[i]] + k * w[i]);</span></span><br><span class="line"><span class="comment">// k &lt;= s[i] &amp;&amp; j &gt;= k * v[i]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; j &gt;= k * v[i]; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][V] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><p><a href="https://www.acwing.com/problem/content/submission/5/">5. 多重背包问题 II - AcWing题库</a><br>这道题物品个数N的取值范围从0-100变为了0-1000，所以如果采用暴力解法将会TLE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>*v[i]]+w[i], f[i<span class="number">-1</span>][j<span class="number">-2</span>*v[i]]+<span class="number">2</span>*v[i], ..., f[i<span class="number">-1</span>][j-s*v[i]]+s*w[i])</span><br><span class="line">f[i][j<span class="number">-1</span>*v[i]] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>*v[i]], f[i<span class="number">-1</span>][j<span class="number">-2</span>*v[i]]+<span class="number">2</span>*w[i], f[i<span class="number">-1</span>][j<span class="number">-3</span>*v[i]]+<span class="number">3</span>*v[i], ..., f[i<span class="number">-1</span>][j-s*v[i]]+s*w[i],f[i<span class="number">-1</span>][j-(s+<span class="number">1</span>)*v[i]]+(s+<span class="number">1</span>)*w[i] )</span><br></pre></td></tr></table></figure><p>显然，上下两个公式不能通过完全背包的方式进行优化！</p><h5 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h5><blockquote><p><strong>对于多重背包的经典优化</strong></p></blockquote><p>对于s[i] = 1023，我们理论上需要遍历0到1023所有的数（如果符合V的限制），而对于0到1023这些数，实际上可以通过1、2、4、8、…、512这10个数<strong>相加求和</strong>得到。<br>所以我们可以通过将同一个物品打包，每包内分别是1个该物品、2个、4个、…、512个物品，然后通过判断选不选这些包裹来实现遍历s[i]的所有可能取值。这样就可以将遍历s[i]这个O(n)的操作优化成O(logn)的操作。</p><blockquote><p>例如对于s[i] = 200，我们可以用1、2、4、8、16、32、64、73来凑出来所有的0到200的数。</p></blockquote><p>然后我们认为对于s[i]个物品i，s[i]可以按照上面所说拆分为sp[0]、sp[1]、sp[2]、…、sp[m]。那么物品i的选取方式就等价于，我们有m个物品，他们的体积和价值分别是v[i] * sp[0]、w[i] * sp[0]，v[i] * sp[1]、w[i] * sp[1]，…v[i] * sp[m]、w[i] * sp[m]，而数量都为1。这样对于物品i的有数量限制的选取（0到s[i]个）就转换为对m个物品选与不选（1或0个）的问题。<br>那么对于整个问题而言，所有物品都进行如此切分，我们可以得到一个01背包问题。时间复杂度为：O(NVlogS)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25000</span>; <span class="comment">// 注意要多开一些空间 至少是原来20倍左右，否则开的太小就会访问越界</span></span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 标记打包得到的新的物品的总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, s;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对物品进行分组打包成新的物品</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ; </span><br><span class="line">            k = s;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= v[i]; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]); </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[V] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#注意 多重背包一定要多开空间<br>因为将原来至多N种物品进行分别打包当作多个物品讨论了，所以仅开N大小的数组是不够的，尽量开到N * log S以上。（这里N = 1000，S = 2000，所以至少要开22000左右）</p><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p><a href="https://www.acwing.com/problem/content/9/">9. 分组背包问题 - AcWing题库</a><br>物品分组，每组里面有多个物品，然后每组的物品只能选择一个</p><h4 id="朴素解法-1"><a href="#朴素解法-1" class="headerlink" title="朴素解法"></a>朴素解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N]; </span><br><span class="line"><span class="keyword">int</span> s[N], v[N][N], w[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s[i]; ++ j)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k])</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化解法-1"><a href="#优化解法-1" class="headerlink" title="优化解法"></a>优化解法</h4><p>同01背包一样，也可以从两维优化成一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[N]; </span><br><span class="line"><span class="keyword">int</span> s[N], v[N][N], w[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s[i]; ++ j)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k])</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><p>递推方程有一个明显的<mark style="background: #FF5582A6;">线性关系</mark> ，可以是一维，也可以是多维。</p><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><a href="https://www.acwing.com/problem/content/900/">898. 数字三角形 - AcWing题库</a><br>状态表示<code>f[i][j]</code>是二维的，表示所有从起点走到<code>(i, j)</code>的路径的<strong>最大值</strong>。<br>#知识点 动态规划的时间复杂度估算 = 状态数 * 每个状态的转移数<br>自上向下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++ j)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; f[i][j]; </span><br><span class="line">            <span class="keyword">int</span> tem;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span>) tem = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>) tem = f[i - <span class="number">1</span>][j];</span><br><span class="line">            f[i][j] += tem; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = f[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) re = <span class="built_in">max</span>(re, f[n - <span class="number">1</span>][i]);</span><br><span class="line">    cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)</a><br>给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。<br><strong>输入</strong><br>第一行包含整数N<br>第二行包含N个整数，表示完整序列<br><strong>输出</strong><br>输出一个整数，表示最大长度<br><strong>数据范围</strong><br>$1\leq N\leq 1000$，<br>$-10^9 \leq \text{数列中的数} \leq 10^9$</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>状态表示：<code>f[i]</code>表示所有以第i个数结尾的上升的子序列的<strong>最大值</strong><br>状态计算：按照上升子序列的倒数第二个数是0、1、2 … i - 1划分情况，然后求最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">2550</span>]; <span class="comment">// 以i结尾的最长递增子序列</span></span><br><span class="line">    <span class="keyword">int</span> re;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">        re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>; <span class="comment">// 注意初始化，刚开始只有自己时长度为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; -- j)</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], nums[j] &lt; nums[i] ? f[j] + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            re = <span class="built_in">max</span>(re, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>采用q数组存储长度为i的子序列中末尾元素的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">q[<span class="number">0</span>] = <span class="number">-2e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(q[mid] &lt; a[i]) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/submissions/">1143. 最长公共子序列 - 力扣（LeetCode） (leetcode-cn.com)</a><br>这道题输入两个序列，所以一般是二维的状态方程。<br>状态方程：<code>f[i][j]</code>表示所有由第一个序列的前i个字母和第二个序列的前j个字母的最大公共子序列的最大值。<br><code>f[i][j] = max(f[i-1][j-1], f[i-1][j], f[i][j-1], f[i-1][j-1] + 1);</code></p><blockquote><p>注：这里状态方程的求解是可以有重复的，因为求解的是MAX。<br><code>f[i-1][j-1]</code>可以不写，已经被包含了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, l1 = text1.<span class="built_in">size</span>(); i &lt;= l1; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>, l2 = text2.<span class="built_in">size</span>(); j &lt;= l2; ++ j)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="keyword">int</span>)(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离 - 力扣（LeetCode） (leetcode-cn.com)</a><br>编辑距离问题的状态表示与最大公共子序列的状态表示很接近。<br><strong>状态表示</strong>：<code>f[i][j]</code>表示所有将<code>a[1~i]</code>变成<code>b[1~j]</code>的操作方式的操作次数的最小值。<br><strong>状态计算</strong>：三种情况取最小值</p><ol><li>最后一步是删除<code>a[i]</code>，<code>f[i - 1, j] + 1</code></li><li>最后一步是<code>a[i]</code>添加元素，<code>f[i, j - 1] + 1</code></li><li>最后一步是修改<code>a[i]</code>，<code>f[i - 1, j - 1] + (a[i] != b[j])</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">    <span class="comment">// f[i][j] = min(f[i][j - 1] + 1, f[i - 1][j] + 1, f[i - 1][j - 1] + (word1[i] != word1[j])); </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.<span class="built_in">size</span>(), l2 = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l2; ++ i) f[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++ i) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l2; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>] + <span class="number">1</span>, <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2>状态函数多为<mark style="background: #FF5582A6;">区间形式</mark> 。<h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><a href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a><br>状态表示：<code>f[i][j]</code>表示所有将第i堆石子到第j堆合并成一堆石子的方式中最小代价<br>状态计算：以最后一次合并的分界线为划分基础划分子集并计算代价<blockquote><p>区间DP：一般两层循环，外层是长度，内层是起始点。</p><blockquote><p>不采用一个最左点，一个最右点，因为可能会提前访问到没有求解的中间值。</p></blockquote></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h3 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h3><p>一个正整数n可以表示成若干个正整数之和，形如：$n = n_1+n_2+…+n_k$，其中$n_1\geq n_2\geq …\geq n_k,: k \geq  1$。<br>我们将这样的一种表示称为正整数n的一种划分。<br>现在给定一个正整数n，请你求出n共有多少种不同的划分方法。<br><strong>输入格式</strong><br>共一行，包含一个整数n。<br><strong>输出格式</strong><br>共一行，包含一个整数，表示总划分数量。<br>由于答案可能很大，输出结果请对$10^9+7$取模。<br><strong>数据范围</strong><br>$1≤n≤1000$</p><h4 id="题解1-完全背包问题"><a href="#题解1-完全背包问题" class="headerlink" title="题解1 完全背包问题"></a>题解1 完全背包问题</h4><p>因为数字限定了拆分数的排列次序，所以这道题是一个组合问题，即相同的数视作一种方案。<br>因此这道题目可以看作一个<mark style="background: #FF5582A6;">完全背包问题</mark> 。<br><code>f[i][j]</code>表示只考虑前i个数，然后总和等于j的所有方案数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i )</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line">f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h4><p>状态表示：所有总和是i，并且恰好表示成j个数的和的方案的数量。<br>状态计算：</p><ol><li>最小值是1的方案数，<code>f[i - 1, j - 1]</code></li><li>最小值大于1的方案数，将方案中的每个数减去一个1，那么他的总数i减去了1，但是方案数还是不变的，<code>f[i - j, j]</code><br><code>ans = f[n, 1] + f[n, 2] + ... + f[n, n]</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">res = (res + f[n][i]) % mod;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分 - 力扣（LeetCode） (leetcode-cn.com)</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看作完全背包问题</span></span><br><span class="line"><span class="comment">// 可选的数是 1 2 ... (n - 1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">60</span>]; <span class="comment">// i表示前i个数  j表示最大容量</span></span><br><span class="line">    <span class="comment">// f[i][j] = max(f[i - 1][j], f[i - 1][j - i] * i, f[i - 1][j - 2 * i] * i * i, ...)</span></span><br><span class="line">    <span class="comment">// f[i][j - i] = max(f[i - 1][j - i], f[i - 1][j - 2* i] * i, ...)</span></span><br><span class="line">    <span class="comment">// f[i][j] = max(f[i - 1][j], f[i][j - i] * i)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - i] * i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2></li></ol><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h2 id="记忆性搜索"><a href="#记忆性搜索" class="headerlink" title="记忆性搜索"></a>记忆性搜索</h2>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-09贪心算法</title>
      <link href="2022/03/29/%E7%AE%97%E6%B3%95_09%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>2022/03/29/%E7%AE%97%E6%B3%95_09%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：</p><ol><li><a href="https://www.programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83">代码随想录 (programmercarl.com)-贪心算法</a></li></ol></blockquote><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong><br>何时选用贪心算法？<br><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。<br>一般数学证明有如下两种方法：</p><ul><li>数学归纳法</li><li>反证法<span id="more"></span><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2></li></ul><ol><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2>全局目标：被喂饱的小孩子数量<br>所以尽可能多的满足小孩子需求，而胃口小的更容易被喂饱，所以从小胃口的开始喂。而为了保证尽可能多的喂饱，所以要用从小饼干开始找第一个能喂饱这个孩子的饼干。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最小的孩子开始  最小饼干开始  依此开始满足 </span></span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; g.<span class="built_in">size</span>() &amp;&amp; j &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i] &lt;= s[j])</span><br><span class="line">                i ++, j ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-08回溯算法</title>
      <link href="2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：</p><ol><li><a href="https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E5%A4%A7%E7%BA%B2%E5%A6%82%E4%B8%8B">代码随想录 (programmercarl.com)-回溯算法</a></li><li><a href="https://www.bilibili.com/video/BV1cy4y167mM/">带你学透回溯算法（理论篇）| 回溯法精讲！_哔哩哔哩_bilibili</a></li></ol></blockquote><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。<br>递归与回溯是相辅相成的。一般在递归函数下面进行回溯。<br>回溯本质上也是暴力搜索，效率也不是很高。但是有些暴力搜索的操作无法通过for循环实现，所以需要通过回溯来实现。<br>==核心：回溯法抽象为树形结构后，其遍历过程就是：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。==</p><span id="more"></span><h2 id="回溯算法常见解决问题"><a href="#回溯算法常见解决问题" class="headerlink" title="回溯算法常见解决问题"></a>回溯算法常见解决问题</h2><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p>N个数里面按一定规则找出k个数的集合<br>例如：</p><ol><li>对1，2，3，4进行两两组合，问所有可能的组合情况。<h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3>排列强调元素的顺序，而组合不强调顺序问题。<h3 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h3>一个字符串按一定规则有几种切割方式<br>例如：</li><li>给定一个字符串，问他所有子串形式</li><li>给定一个字符串，问可以切割出多少回文子串<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3>一个N个数的集合里有多少符合条件的子集<br>例如：</li><li>给定集合{1，2，3，4}，问他所有子集有哪些。<h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3>例如：</li><li>N皇后问题</li><li>解数独<h2 id="解题框架"><a href="#解题框架" class="headerlink" title="解题框架"></a>解题框架</h2></li></ol><p><strong>回溯法通常都可以抽象为一个N叉树</strong>。N的值通常是由问题中集合的大小决定，树的深度是由递归决定，递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。即最后回溯问题可以看作：循环+递归。<br><img src="/2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_03%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-image-20220328161909009.png" alt="回溯法解题框架"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line"><span class="comment">// 通常是叶子结点，进行收集结果</span></span><br><span class="line"><span class="comment">// 注：子集问题可能不仅要在叶子结点收集结果，中间也需要</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单层搜索逻辑</span></span><br><span class="line"><span class="keyword">for</span>(集合元素集)&#123;</span><br><span class="line"><span class="comment">// 处理结点</span></span><br><span class="line"><span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归函数</span></span><br><span class="line"><span class="comment">// 回溯结果（恢复现场）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。<br>backtracking这里自己调用自己，实现递归。<br><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="组合问题-1"><a href="#组合问题-1" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><a href="https://leetcode-cn.com/problems/combinations/">77. 组合 - 力扣（LeetCode）</a><br>如果采用for循环来写，那么就需要嵌套k层循环，k是变量，显然无法直接书写这个for循环。但是可以<strong>通过回溯法用递归来解决嵌套层数的问题</strong>。<br><strong>即通过每一次递归中嵌套一个for循环，然后用边界条件决定for循环的层数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不写</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不写</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><p>优化过程如下：</p><ol><li> 已经选择的元素个数：path.size();</li><li> 还需要的元素个数为: k - path.size();</li><li> 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历<br>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。<br>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。<br>从2开始搜索都是合理的，可以是组合[2, 3, 4]。<br>所以优化之后的for循环是：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) <span class="comment">// i为本次搜索的起始位置</span></span><br></pre></td></tr></table></figure><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/submissions/">17. 电话号码的字母组合 - 力扣（LeetCode） (leetcode-cn.com)</a><br>注意，这道题和上一道题主要不同在于：这里for循环不是从startIndex开始遍历的，而是从0开始。因为本题每一个数字代表的是不同集合，也就是求<strong>不同集合之间的组合</strong>，而上一题是求<strong>同一个集合中的组合</strong>。<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode） (leetcode-cn.com)</a><br>注意本题和77.组合的一个区别是：<strong>本题元素为可重复选取的</strong>。</li></ol><p><strong>本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？</strong></p><ul><li>如果是一个集合来求组合的话，就需要startIndex，例如：77.组合，216.组合总和III 。</li><li>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：17.电话号码的字母组合</li><li><em>注意以上只是说求组合的情况，如果是排列问题，又是另一套分析的套路</em>*<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    sum += candidates[i];</span><br><span class="line">    path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates, target, sum, i); <span class="comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">    sum -= candidates[i];   <span class="comment">// 回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剪枝优化-1"><a href="#剪枝优化-1" class="headerlink" title="剪枝优化"></a>剪枝优化</h4>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。<br>for循环剪枝代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)</span><br></pre></td></tr></table></figure><h3 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h3>这道题目和39.组合总和如下区别：</li></ul><ol><li>本题candidates 中的每个数字在每个组合中只能使用一次。</li><li>本题数组candidates的元素是有重复的，而39.组合总和是无重复元素的数组candidates</li></ol><p>最后本题和39.组合总和要求一样，解集不能包含重复的组合。<br>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合。<br>把所有组合求出来，再用set或者map去重，这么做很容易超时！<br><strong>所谓去重，其实就是使用过的元素不能重复选取。</strong> 这么一说好像很简单！<br>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong><br>元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。所以我们要去重的是<strong>同一树层上的“使用过”</strong>，同一树枝上的都是一个组合里的元素，不用去重。<br><strong>强调一下，树层去重的话，需要对数组排序！</strong><br><img src="/2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_03%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-image-20220329083857267.png" alt="组合总和II"><br>**如果<code>candidates[i] == candidates[i - 1]</code> 并且 <code>used[i - 1] == false</code>，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。<br>此时for循环里就应该做continue的操作。<br><img src="/2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_03%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-image-20220329084123807.png" alt="组合总和II去重"><br>可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p><ul><li>  used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</li><li>  used[i - 1] == false，说明同一树层candidates[i - 1]使用过<h2 id="切割问题-1"><a href="#切割问题-1" class="headerlink" title="切割问题"></a>切割问题</h2>切割问题其实是一种组合问题！<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3>本题递归函数参数还需要startIndex，因为<strong>切割过的地方，不能重复切割</strong>，和组合问题也是保持一致的。<br>#注意 string.substr()函数用法<br><code>str.substr(a, b)</code> 的参数a是<strong>开始位置</strong>，参数b是==<strong>切割子串的大小</strong>==！<br>#注意 continue不要写成break！<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3>横向for循环遍历IP地址的每一段的所有可能的切割结果，保证结果合理性（无前导零，在0到255之间），所以切割的情况 1 - 3字符。<br>纵向递归遍历IP地址切割结果的所有段，当切割到最后了，且切割段数是4段即退出递归。<h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><h3 id="子集-1"><a href="#子集-1" class="headerlink" title="子集"></a>子集</h3><a href="https://leetcode-cn.com/problems/subsets/">78. 子集 - 力扣（LeetCode） (leetcode-cn.com)</a><br>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong><br>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</li></ul><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> be)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        re.<span class="built_in">push_back</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(be &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = be, len = nums.<span class="built_in">size</span>(); i &lt; len; i ++)</span><br><span class="line">        &#123; </span><br><span class="line">            t.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            t.<span class="built_in">pop_back</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h3><p><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II - 力扣（LeetCode） (leetcode-cn.com)</a><br>原集合中可能有重复元素，所以需要进行<strong>层内去重</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">15</span>]; <span class="comment">// false表示同一层， true表示上层</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        re.<span class="built_in">push_back</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(begin &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin, len = nums.<span class="built_in">size</span>(); i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; !used[i - <span class="number">1</span>])    </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            p.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            p.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递推子序列"><a href="#递推子序列" class="headerlink" title="递推子序列"></a>递推子序列</h3><p>在90.子集II (opens new window)中我们是通过排序，再加一个标记数组来达到去重的目的。<br>而本题求自增子序列，是<strong>不能对原数组经行排序的</strong>，排完序的数组都是自增子序列了。所以不能使用之前的去重逻辑！<br><img src="/2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_03%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-image-20220329134751926.png" alt="递推子序列"><br><strong>同一父节点下的同层上使用过的元素就不能在使用了</strong>。本题需要用一个set容器来存储同一层下已经被使用过的元素。<strong>这也是需要注意的点，<code>unordered_set&lt;int&gt; uset;</code> 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空）</strong>，所以要知道uset只负责本层，因此每次insert不需要erase！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; p; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">            re.<span class="built_in">push_back</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(begin == nums.<span class="built_in">size</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; uset; <span class="comment">// 每一层都会新建一个set，层内同set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin, len = nums.<span class="built_in">size</span>(); i &lt; len ; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p.<span class="built_in">empty</span>() &amp;&amp; p.<span class="built_in">back</span>() &gt; nums[i]) <span class="keyword">continue</span>; <span class="comment">// 层间数据递增</span></span><br><span class="line">            <span class="keyword">if</span>(uset.<span class="built_in">count</span>(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            p.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            p.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>#注意 报错：==42==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000dc at pc 0x00000034e126 bp 0x7ffc0e15b070 sp<br><code>if(!p.empty() &amp;&amp; p.back() &gt; nums[i]) continue;</code>这里之前没有写!p.empty()，所以可能导致p.back()函数从空集合中访问元素，所以注意加上!p.empty()！</p><blockquote><p>这里也有可能报错：Char 45: runtime error: applying non-zero offset 18446744073709551612 to null pointer (stl_iterator.h) SUMMARY: UndefinedBehaviorSanitizer …</p></blockquote><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>以上代码采用<code>unordered_set&lt;int&gt;</code>来记录本层元素是否重复使用。<br>其实用<strong>数组</strong>来做哈希，效率就高了很多。<br>注意题目中说了，数值范围[-100,100]，所以完全可以用数组来做哈希。<br>程序运行的时候对unordered_set 频繁的insert，unordered_set需要做哈希映射（也就是把key通过hash function映射为唯一的哈希值）相对费时间，insert的时候其底层的符号表也要做相应的扩充。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> used[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 这里使用数组来进行去重操作，题目说数值范围[-100, 100]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>())</span><br><span class="line">    || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    used[nums[i] + <span class="number">100</span>] = <span class="number">1</span>; <span class="comment">// 记录这个元素在本层用过了，本层后面不能再用了</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>#技巧 数组，set，map都可以做哈希表，而且数组干的活，map和set都能干，但如果<strong>数值范围小的话能用数组尽量用数组</strong>。注意，如果Hash的key值中存在负数，在使用数组做Hash表时，可以通过加上一个偏移量来处理负数（如上题）。</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列 - 力扣（LeetCode） (leetcode-cn.com)</a><br>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。<br>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。<br>但排列问题需要一个<strong>used数组，标记已经选择的元素</strong>，如图橘黄色部分所示:<br><img src="/2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_03%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-image-20220329140232852.png" alt="全排列"></p><h3 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h3><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。<br>这道题与上一题不同在于：这一道题集合中可能有重复元素，所以需要进行去重。<br><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(p.<span class="built_in">size</span>() == len)</span><br><span class="line">        &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(p);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>] <span class="comment">// 去重</span></span><br><span class="line">                || used[i]) <span class="comment">// 同一个元素一次路径不能用多次</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            p.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums);</span><br><span class="line">            p.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>#注意 在全排列、组合中，使用unordered_set进行去重时，要注意先要进行排序，然后在进入dfs()函数！否则可能去重结果还是有重复。</p><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p>本质上是<mark style="background: #FFB8EBA6;">一笔画</mark> 问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; re, tm;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">310</span>];</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets, string begin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tm.<span class="built_in">size</span>() == tickets.<span class="built_in">size</span>() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            re = tm;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = tickets.<span class="built_in">size</span>(); i &lt; len ; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">return</span>; <span class="comment">// 已经找到有效路径</span></span><br><span class="line">            <span class="keyword">if</span>(tickets[i][<span class="number">0</span>] != begin || used[i]) <span class="keyword">continue</span> ;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            tm.<span class="built_in">push_back</span>(tickets[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">dfs</span>(tickets, tickets[i][<span class="number">1</span>]);</span><br><span class="line">            tm.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(tickets.<span class="built_in">begin</span>(), tickets.<span class="built_in">end</span>());</span><br><span class="line">        tm.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(tickets, <span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>#知识点 sort函数对于二维数组<br>一个数组<code>vector&lt;vector&lt;string&gt;&gt; vv</code>，采用<code>sort(vv.begin(), vv.end())</code>进行排序，会按照优先级从开始向后每一项进行比较（默认字典序比较），例如{“abc”, “abc”} &lt; {“abc”, “def”} &lt; {“abc”, “def”, “abc”}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; s = &#123;&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;, &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; s[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// 输出： abc def</span></span><br></pre></td></tr></table></figure><p><a href="https://www.programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">代码随想录 (programmercarl.com)</a>的思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="keyword">int</span>&gt;&gt; targets;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pair&lt;<span class="keyword">const</span> string, <span class="keyword">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) &#123; <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">            target.second--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">            target.second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        targets.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">            targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>); <span class="comment">// 起始机场</span></span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个思路中，backtracking()函数的返回值可以起到的作用是，当找到目标排列方式以后直接结束回溯，而不会再找其他方案。<br>#注意 尽量不要用map和set的迭代器进行遍历然后删除操作<br>因为map和set的迭代器进行删除操作以后，该迭代器也会被删除，那么就会无法继续向下遍历。</p><h2 id="棋盘问题-1"><a href="#棋盘问题-1" class="headerlink" title="棋盘问题"></a>棋盘问题</h2><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; re;</span><br><span class="line">    vector&lt;string&gt; tm;</span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">30</span>], dia[<span class="number">30</span>], rdia[<span class="number">30</span>]; <span class="comment">// 标记哪些位置不可以用</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> be)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(be == n)</span><br><span class="line">        &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(tm);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(col[i] || dia[be + i] || rdia[be - i + n]) <span class="keyword">continue</span>;</span><br><span class="line">            col[i] = dia[be + i] = rdia[be - i + n] = <span class="literal">true</span>;</span><br><span class="line">            string t = s;</span><br><span class="line">            t[i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            tm.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="built_in">dfs</span>(n, be + <span class="number">1</span>);</span><br><span class="line">            col[i] = dia[be + i] = rdia[be - i + n] = <span class="literal">false</span>;</span><br><span class="line">            tm.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p><img src="/2022/03/28/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95_08%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-image-20220331100509216.png" alt="解数独"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> be)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(be == board.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 遍历列</span></span><br><span class="line">        <span class="keyword">if</span> (board[be][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;     <span class="comment">// (be, j) 这个位置放k是否合适</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(be, j, k, board)) &#123;</span><br><span class="line">                board[be][j] = k;                <span class="comment">// 放置k</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board, be)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// DFS同一行的下一列数据  如果找到合适一组立刻返回（不会再进行恢复现场）</span></span><br><span class="line">                board[be][j] = <span class="string">&#x27;.&#x27;</span>;              <span class="comment">// 回溯，撤销k</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">backtracking</span>(board, be + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// DFS下一行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> val, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">// 判断行里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123; <span class="comment">// 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[j][col] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; i++) &#123; <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == val ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">代码随想录 (programmercarl.com)</a>的思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;        <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 遍历列</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;     <span class="comment">// (i, j) 这个位置放k是否合适</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(i, j, k, board)) &#123;</span><br><span class="line">                    board[i][j] = k;                <span class="comment">// 放置k</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到合适一组立刻返回（不会再进行恢复现场）</span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;.&#x27;</span>;              <span class="comment">// 回溯，撤销k</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> val, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">// 判断行里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][i] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123; <span class="comment">// 判断列里是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (board[j][col] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; i++) &#123; <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == val ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-13DFS、2021年笔试真题</title>
      <link href="2022/03/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_13DFS_2021%E5%B9%B4%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/"/>
      <url>2022/03/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_13DFS_2021%E5%B9%B4%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="全排序"><a href="#全排序" class="headerlink" title="全排序"></a>全排序</h3><p><a href="https://www.acwing.com/activity/content/problem/content/4297/">AcWing 3429. 全排列 - AcWing</a><br>DFS实现</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[N], path[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n) cout &lt;&lt; path &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[i])</span><br><span class="line">            &#123;</span><br><span class="line">                path[u] = str[i];</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>next_permutation库函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">do</span>  cout &lt;&lt; s &lt;&lt; endl; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h3><p>#好题<br><a href="https://www.acwing.com/activity/content/problem/content/4298/">AcWing 3472. 八皇后 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( -- n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">                cout &lt;&lt; path[i];</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[u - i + <span class="number">8</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            col[i] = dg[u + i] = udg[u - i + <span class="number">8</span>] = <span class="literal">true</span>;</span><br><span class="line">            path[u] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[u - i + <span class="number">8</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T -- )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span> col);</span><br><span class="line">        <span class="built_in">memset</span>(dg, <span class="number">0</span>, <span class="keyword">sizeof</span> dg);</span><br><span class="line">        <span class="built_in">memset</span>(udg, <span class="number">0</span>, <span class="keyword">sizeof</span> udg);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="2021年真题"><a href="#2021年真题" class="headerlink" title="2021年真题"></a>2021年真题</h2><h3 id="2021-2"><a href="#2021-2" class="headerlink" title="2021-2"></a>2021-2</h3><p>已知初始为空的队列Q的一端既能入队又能出队，另一端只能入队，若入队序列是1、2、3、4、5，则不能得到的出队序列是（）<br>A. 5, 4, 3, 1, 2<br>B. 5, 3, 1, 2, 4<br>C. 4, 2, 1, 3, 5<br>D. 4, 1, 3, 2, 5<br>D</p><h3 id="2021-11"><a href="#2021-11" class="headerlink" title="2021-11"></a>2021-11</h3><p>#注意 注意题目中大根堆的建堆方式，是往初始为空的大根堆中依此插入，还是所有数据先加入大根堆再统一执行down操作。</p><h3 id="2021-41"><a href="#2021-41" class="headerlink" title="2021-41"></a>2021-41</h3><p>已知无向连通图G由顶点集V和边集E组成|E|&gt;0，当G中度为奇数的顶点个数为不大于2的偶数时，G存在包含所有边且长度为|E|的路径(称为EL路径)，设图G采用邻接矩阵存储，类型定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">// 图的定义</span></span><br><span class="line"><span class="keyword">int</span> numvertices, numEdges;  <span class="comment">// 图中实际的顶点数和边数</span></span><br><span class="line"><span class="keyword">char</span> verticesList[MAXV];  <span class="comment">//顶点表，MAXV为已定义常量</span></span><br><span class="line"><span class="keyword">int</span> Edge[MAXV][MAXV] ;  <span class="comment">//邻接矩阵</span></span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure><p>请设计算法:int IsExistEL (MGraph c)，判断G否存在EL路径，若存在，则返回1，否则，返回0，要求:<br>（1）给出算法的基本设计思想<br>（2）根据设计思想，采用C或C++描述算法，关键之处给出注释<br>（3）说明算法的时间复杂度和空间复杂度<br>题解：<br>#知识点 一个无向连通图存在欧拉路径 &lt;=&gt; 度数为奇数的点的个数为0或1<br>#TODO 判断欧拉回路 … 各种图（基础：了解无向连通图的判断方式）<br>#知识点 判断图的连通性可以通过DFS、BFS或并查集进行判断。</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-12桶排序、基数排序、外部排序，多路归并和摩尔投票法</title>
      <link href="2022/03/27/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/"/>
      <url>2022/03/27/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="桶排序（计数排序）"><a href="#桶排序（计数排序）" class="headerlink" title="桶排序（计数排序）"></a>桶排序（计数排序）</h2><p>基于比较的排序的下界是O(nlogn)，而桶排序不是基于比较的排序，所以时间复杂度可以是线性的O(n+m)。<br>桶排序中，相同元素的相对顺序不变。</p><span id="more"></span><p>则a<sub>i</sub>的位置 = 小于a<sub>i</sub>的元素数 + 排在a<sub>i</sub>的前面的等于a<sub>i</sub>的元素个数<br>为了保证相同元素之间的相对顺序不发生改变，所以一般可以将元素从后往前摆放。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], w[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucket_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每个桶里元素数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) s[q[i]] ++;</span><br><span class="line">    <span class="comment">// 桶里元素前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 倒序遍历每个元素并将其放到对应位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) w[ -- s[q[i]]] = q[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) q[i] = w[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">bucket_sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最好情况：O(n + m)，m是桶的个数<br>平均情况：O(n + m)<br>最坏情况：O(n + m)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(n + m)</p><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是桶排序的拓展。<br>基数排序流程：将序列中所有数据$(a_i)<em>{10}$转换为$(\overline{d_rd</em>{r-1}…d_{0}})_r$，然后其中每一位可以作为有序数组的元素进行多关键排序。<br>基数为r。这样每次的数据范围都在[0, r]上，即桶都只有r个。<br>从高位到低位进行排序：需要用到递归，效率相对低<br>从低位到高位进行排序：由于桶排序的稳定性，不需要递归，效率相对较高。r进制有几位，就进行几次桶排序。</p><blockquote><p>从低位到高位排序，实质含义是：当你排第i位的时候，第i位优先级最高，但是第i-1位数据之间的相对位置不变，即第i位相同时，按之前第i-1位已经排序好的结果进行排序，第i-2、…、0位的同理。最终结果就是所有数据排序关键字优先级最高位&gt;高位&gt;低位&gt;最低位，正好与数据比较结果相同。<br><img src="/2022/03/27/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/20190813135928746.gif" alt="从低位到高位进行排序"></p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], w[N], s[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> r)</span> <span class="comment">// d是r进制的最大位数，r是进制数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; ++ i) <span class="comment">// 从低位开始依此处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 置零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r; ++ j) s[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 桶排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) s[q[j] / radix % r] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; r; ++ j) s[j] += s[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; -- j) w[-- s[q[j] / radix % r]] = q[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) q[j] = w[j];</span><br><span class="line">        radix *= r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">radix_sort</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最好情况：O(n + r)，r是基数<br>平均情况：O(n + r)<br>最坏情况：O(n + r)</p><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(n + r)</p><h3 id="稳定-1"><a href="#稳定-1" class="headerlink" title="稳定"></a>稳定</h3><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>内排序一般瓶颈在于比较次数，而外排序一般瓶颈在于读写次数。<br>外排序过程：</p><ol><li>预处理。首先利用内存（如置换选择排序）生成m个有序的串（m很大）。</li><li>归并。将1.中生成串进行k-路归并（m很大，所以不能直接归并m个串）。归并过程中一个优化操作：利用Huffman思想每次选择最短的k个有序串。<br>所以需要读写$O(log_km)$轮<h3 id="1-置换选择排序"><a href="#1-置换选择排序" class="headerlink" title="1. 置换选择排序"></a>1. 置换选择排序</h3>在内存中进行，通过生成尽可能长的有序数串，从而减小m。<br>置换选择排序流程：</li><li>从要排序的目标数据中提取一些数来构建一个堆，例如说最小堆</li><li>再依此从目标数据中顺次选出其他的数，<ol><li>如果这个数大于等于最小堆的数，则将最小堆堆顶值放入到生成的有序数串中，然后把这个选出来的数加入堆堆顶并执行down操作；</li><li>如果这个数小于最小堆的数，则将最小堆堆顶值删除掉（用最后一个数覆盖掉堆顶元素，然后堆size - 1），然后将这个选出来的数插到堆末尾，再从头执行down操作。</li></ol></li><li>重复执行2.操作直到堆为空，则构建一个有序数串完成<h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h3>在1.中构建完成很多的m数序以后，会存储到外存中。接下来需要不断选择k个串在内存中通过k-路归并将每k个数序进行归并。<br>归并操作：维持k个指针，然后不断找出其中最小的值进行归并。<br>实现方式：</li><li>堆排序  每次插入新的元素，需要执行1次down操作、1次up操作</li><li>胜者树  对堆进行优化，可以省1次down操作<br><img src="/2022/03/27/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95-image-20220327203324302.png" alt="胜者树1"><br><img src="/2022/03/27/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95-image-20220327203419403.png" alt="胜者树2"></li><li>败者树  对胜者树进行优化，胜者数up时，比较不仅需要和父亲结点比较，还需要与兄弟结点比较，败者树对此进行优化，只需要和兄弟结点比较<br><img src="/2022/03/27/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95-image-20220327203859854.png" alt="败者树1"><br><img src="/2022/03/27/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_12%E6%A1%B6%E6%8E%92%E5%BA%8F_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F_%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F_%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%92%8C%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95-image-20220327204229700.png" alt="败者树2"><h3 id="3-Huffman树"><a href="#3-Huffman树" class="headerlink" title="3. Huffman树"></a>3. Huffman树</h3>在归并时，一共m段，每次归并k段，最终结果长度为k段长度之和，目的是比较次数最小。本质上就是Huffman树，所以每次选择长度最小的k段进行合并。<br>如果k - 1|m - 1不能整除，则需要补一些虚段（零段）。<h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2>2011-10、2011-11、2012-10、2012-11、2013-11、2014-10、2014-11、2015-9、2015-10、2015-11、2016-11、2016-43、2017-10、2017-11、2018-10、2018-11、2019-7、2019-10、2019-11、2020-9、2020-11<h3 id="2011-11"><a href="#2011-11" class="headerlink" title="2011-11"></a>2011-11</h3>已知序列25、13、10、12、9是大根堆，在序列尾部插入新元素18，将其再调整为大根堆，调整过程中元素之间进行的比较次数是（）<br>A. 1    B. 2    C. 4    D. 5<br>B<br>注：up操作直接与父元素进行比较即可，不需要与兄弟结点比较。<h3 id="2014-11"><a href="#2014-11" class="headerlink" title="2014-11"></a>2014-11</h3>下列选项中，不可能是快速排序第2趟排序结果的是（）<br>A. 2, 3, 5, 4, 6, 7, 9      B. 2, 7, 5, 6, 4, 3, 9<br>C. 3, 2, 5, 4, 7, 6, 9      D. 4, 2, 3, 5, 7, 6, 9<br>C<br>#知识点 解题方式：快速排序第i趟排序一定至少有i个元素在正确位置上（这个数左边数都比他小，右边都比他大，则在正确位置上）。<h3 id="2015-9"><a href="#2015-9" class="headerlink" title="2015-9"></a>2015-9</h3>#知识点 基数排序中元素移动次数与关键字的初始排列次序无关。最好最坏时间复杂度都是O(n + r)<h3 id="2015-10"><a href="#2015-10" class="headerlink" title="2015-10"></a>2015-10</h3>已知小根堆为8, 15, 10, 21, 34, 16, 12，删除关键字8之后需要重建堆，在此过程中，关键字之间的比较次数是：<br>3<h3 id="2015-11"><a href="#2015-11" class="headerlink" title="2015-11"></a>2015-11</h3>#知识点 希尔排序的组内排序采用的是：直接插入排序<h3 id="2016-11"><a href="#2016-11" class="headerlink" title="2016-11"></a>2016-11</h3>#知识点 对10TB的数据文件进行排序，应使用的方法是：归并排序<br>外部排序，最常用方法是多路归并排序。<h3 id="2016-43"><a href="#2016-43" class="headerlink" title="2016-43"></a>2016-43</h3><a href="https://www.acwing.com/activity/content/problem/content/5462/">AcWing 1603. 整数集合划分 - AcWing</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) s += q[l], l ++; </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[(l + r)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>); </span><br><span class="line">    cout &lt;&lt; n % <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">abs</span>(<span class="built_in">sum</span>(<span class="number">0</span>, n / <span class="number">2</span>) - <span class="built_in">sum</span>(n / <span class="number">2</span>, n)) &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2017-10"><a href="#2017-10" class="headerlink" title="2017-10"></a>2017-10</h3>在内部排序时，若选择了归并排序而没有选择插入排序，则可能的理由是<br>I.    归并排序的程序代码更短<br>Ⅱ.  归并排序的占用空间更少<br>Ⅲ. 归并排序的运行效率更高<br>A. 仅ⅡI    B. 仅Ⅲ    C．仅Ⅰ、II     D. 仅Ⅰ、III<br>B<br>代码长度不能作为主要考虑依据。<h3 id="2017-11"><a href="#2017-11" class="headerlink" title="2017-11"></a>2017-11</h3>下列排序方法中，若将顺序存储更换为链式存储，则算法的时间效率会降低的是<br>Ⅰ．插入排序    Ⅱ．选择排序    Ⅲ．起泡排序<br>Ⅳ．希尔排序    V．堆排序<br>A．仅Ⅰ、II    B.仅Ⅱ、III    C．仅Ⅲ、IV    D.仅Ⅳ、V<br>D<br>#疑问 链式存储包括树形结构吗？<br>#TODO 这道题I   III    IV   V  不理解<br>V堆排序 需要通过2p，2p+1来按照下标找左右儿子，所以链式效率下降。链式包括树吗？<h3 id="2019-10"><a href="#2019-10" class="headerlink" title="2019-10"></a>2019-10</h3>#好题<br>排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列排序中，不可能是快速排序第二趟结果的是（）<br>A. 5, 2, 16, 12, 28, 60, 32, 72<br>B. 2, 16, 5, 28, 12, 60, 32, 72<br>C. 2, 12, 16, 5, 28, 32, 72, 60<br>D. 5, 2, 12, 28, 16, 32, 72, 60<br>题解<br>答案：D，分析如下。<br>每经过一趟快排，轴点元素都必然就位。也就是说，一趟下来至少有1个元素在其最终位置。所以考察各个选项，看有几个元素就位即可。<br>最终排序位置是：2, 5, 12, 16, 28, 32, 60, 72，而选项中正确的位置有：<br>A. 5, 2, 16, 12, <strong>28</strong>, 60, 32, <strong>72</strong><br>B. <strong>2</strong>, 16, 5, 28, 12, 60, 32, <strong>72</strong><br>C. <strong>2</strong>, 12, 16, 5, <strong>28</strong>, <strong>32</strong>, 72, 60<br>D. 5, 2, <strong>12</strong>, 28, 16, <strong>32</strong>, 72, 60<br>第一趟排序，确定一个元素位置<br>第二趟排序，又确定一个或两个元素位置</li><li>当第一趟元素确认的位置为最左或最右时，第二趟排序只能确认一个位置（A，B选项情况）</li><li>当第一趟元素确认位置不是最左或最右时，第二趟能确认2个位置（C选项情况）<br>所以，两趟排序共确认2或3个元素位置。 <blockquote><p>注意：<strong>对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。</strong> 所以，如果分界点在中间，则下一趟，前后两端都要进行一次快排，所以会固定两个数据。</p></blockquote><h3 id="2020-9"><a href="#2020-9" class="headerlink" title="2020-9"></a>2020-9</h3>#知识点 堆具有以下特点：</li><li>完全二叉树</li><li>存储的值是偏序<br>一般采用数组（顺序结构）来表示堆<h3 id="2020-11"><a href="#2020-11" class="headerlink" title="2020-11"></a>2020-11</h3>#知识点 直接插入排序与简单选择排序相比：</li><li>直接插入排序元素比较次数少</li><li>简单选择排序移动的元素少</li><li>均为就地排序，空间复杂度均为O(1)<h3 id="2020-41"><a href="#2020-41" class="headerlink" title="2020-41"></a>2020-41</h3>#好题 没看懂，贪心？<br><a href="https://www.acwing.com/activity/content/problem/content/5464/">AcWing 3874. 三元组的最小距离 - AcWing</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> l, m, n;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cin &gt;&gt; c[i];</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; l &amp;&amp; j &lt; m &amp;&amp; k &lt; n; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[i], y = b[j], z = c[k];</span><br><span class="line">        res = <span class="built_in">min</span>(res, (LL)<span class="built_in">max</span>(<span class="built_in">max</span>(x, y), z) - <span class="built_in">min</span>(<span class="built_in">min</span>(x, y), z));</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= y &amp;&amp; x &lt;= z) ++ i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y &lt;= x &amp;&amp; y &lt;= z) ++ j;</span><br><span class="line">        <span class="keyword">else</span> ++ k;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res * <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h4>408真题 2013-41<br><a href="https://www.acwing.com/activity/content/problem/content/5463/">AcWing 52. 数组中出现次数超过一半的数字 - AcWing</a><h5 id="摩尔投票法-1"><a href="#摩尔投票法-1" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) val = x, cnt ++ ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == val) cnt ++ ;</span><br><span class="line">            <span class="keyword">else</span> cnt --;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == val) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt;= nums.<span class="built_in">size</span>() / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 无解</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h5>时间复杂度O(nlogn)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-11插入、冒泡、选择、希尔、快速、堆、归并排序</title>
      <link href="2022/03/26/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_11%E6%8F%92%E5%85%A5_%E5%86%92%E6%B3%A1_%E9%80%89%E6%8B%A9_%E5%B8%8C%E5%B0%94_%E5%BF%AB%E9%80%9F_%E5%A0%86_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>2022/03/26/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_11%E6%8F%92%E5%85%A5_%E5%86%92%E6%B3%A1_%E9%80%89%E6%8B%A9_%E5%B8%8C%E5%B0%94_%E5%BF%AB%E9%80%9F_%E5%A0%86_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><h3 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h3><p>内排序：排序的数据量不是很大，所有数据可以存到内存中。</p><blockquote><p>内部排序一般采用顺序存储结构效率更高。</p></blockquote><p>外排序：排序的数据量很大，数据需要存到外存中。</p><h3 id="算法的稳定性"><a href="#算法的稳定性" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h3><p>稳定：相同值的元素之间的相对位置在排序前后不会发生改变<br>不稳定：相同值的元素之间的相对位置在排序前后可能发生改变</p><span id="more"></span><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度主要取决于两个次数：比较次数、移动次数<br>基于比较的排序，时间复杂度有下界O(nlogn)</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>插入排序对于部分有序的序列效率很高</strong>。</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况：O(n)</p><blockquote><p>原数组直接有序</p></blockquote><p>平均情况：O(n^2)<br>最坏情况：O(n^2)</p><blockquote><p>原数组倒序</p></blockquote><h4 id="辅助空间复杂度"><a href="#辅助空间复杂度" class="headerlink" title="辅助空间复杂度"></a>辅助空间复杂度</h4><p>O(1)</p><h4 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">()</span> <span class="comment">// 插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[i], j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; q[j - <span class="number">1</span>] &gt; t)</span><br><span class="line">        &#123;</span><br><span class="line">            q[j] = q[j - <span class="number">1</span>];</span><br><span class="line">            -- j;</span><br><span class="line">        &#125;</span><br><span class="line">        q[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">insert_sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>二分出<strong>第一个大于</strong>插入值的位置</p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况：O(n)<br>平均情况：O(n^2)<br>最坏情况：O(n^2)</p><h4 id="辅助空间复杂度-1"><a href="#辅助空间复杂度-1" class="headerlink" title="辅助空间复杂度"></a>辅助空间复杂度</h4><p>O(1)</p><h4 id="稳定-1"><a href="#稳定-1" class="headerlink" title="稳定"></a>稳定</h4><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_search_insert_sort</span><span class="params">()</span> <span class="comment">// 折半插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 二分，找到第一个大于当前元素的值</span></span><br><span class="line">        <span class="comment">// 特判，前面所有元素都小于等于当前元素</span></span><br><span class="line">        <span class="keyword">if</span>(q[i - <span class="number">1</span>] &lt;= q[i])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t = q[i];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt; t) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">// 循环结束时，r的值即是第一个大于的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= r; j --)</span><br><span class="line">            q[j + <span class="number">1</span>] = q[j];</span><br><span class="line">        q[r] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">binary_search_insert_sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序（bubble-sort）"><a href="#冒泡排序（bubble-sort）" class="headerlink" title="冒泡排序（bubble sort）"></a>冒泡排序（bubble sort）</h2><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况：O(n)<br>平均情况：O(n^2)<br>最坏情况：O(n^2)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(1)</p><h4 id="稳定-2"><a href="#稳定-2" class="headerlink" title="稳定"></a>稳定</h4><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><blockquote><p>冒泡排序的优化：如果存在一次冒泡，其过程中没有交换过一次相邻数据，则说明已经有序可以直接退出排序了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">()</span> <span class="comment">// 冒泡排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) <span class="comment">// n - 1个排好，第n个就排好了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> has_swap = <span class="literal">false</span>; <span class="comment">// 这一轮有没有交换过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; -- j)</span><br><span class="line">            <span class="keyword">if</span>(q[j] &lt; q[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(q[j], q[j - <span class="number">1</span>]);</span><br><span class="line">                has_swap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(!has_swap) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">bubble_sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况：O(n^2)<br>平均情况：O(n^2)<br>最坏情况：O(n^2)</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(1)</p><h4 id="不稳定"><a href="#不稳定" class="headerlink" title="不稳定"></a>不稳定</h4><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">()</span> <span class="comment">// 简单选择排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i; <span class="comment">// 最小元素下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(q[j] &lt; q[k])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="built_in">swap</span>(q[i], q[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">select_sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序（shell-sort）"><a href="#希尔排序（shell-sort）" class="headerlink" title="希尔排序（shell sort）"></a>希尔排序（shell sort）</h2><p><strong>插入排序对于部分有序的序列效率很高</strong>。所以希尔排序就是利用这个思想进行改进的。</p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(n^(3/2))</p><h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(1)</p><h4 id="不稳定-1"><a href="#不稳定-1" class="headerlink" title="不稳定"></a>不稳定</h4><p>希尔排序过程中进行了分组</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>增量选择n/2，n/4，…  实际最坏时间复杂度是O(n^2)</p><blockquote><p>注意希尔排序必须保证最后一个增量为1，所以如果选择n/3，n/(3^2)，… 需要进行特判设置最后一个增量为1<br><code>for(int d = n / 3; d; d = d == 2 ? 1 : d/3)&#123; ... &#125;</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">()</span> <span class="comment">// 希尔排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = n/<span class="number">2</span>; d; d /= <span class="number">2</span>) <span class="comment">// n/2 n/4 ... </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; d; start ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start + d; i &lt; n; i += d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = q[i], j = i;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; start &amp;&amp; q[j - d] &gt; t)</span><br><span class="line">                &#123;</span><br><span class="line">                    q[j] = q[j - d];</span><br><span class="line">                    j -= d;</span><br><span class="line">                &#125;</span><br><span class="line">                q[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">shell_sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序和二路归并排序都是基于分治的思想。快排可以认为是现在排序最快的。<br>思路：</p><ol><li>找到分界点x</li><li>划分原数组为两端，一侧小于等于x，另一侧大于等于x （双指针实现）</li><li>递归排左右两端<blockquote><p>注意：教材中所提供的方式可以保证每一趟排序都可以使得分界点位于排序的最终位置。</p></blockquote><h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>最好情况：O(nlogn)<br>平均情况：O(nlogn)<br>最坏情况：O(n^2)<blockquote><p>如果分界点选择第一个元素（或最后一个元素），若原数组倒序，则每次划分的数组长度为(1，n-1)，((1), (1，n-2))，… 会划分n层，将导致时间复杂度达到O(n^2)。</p></blockquote><h4 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>O(logn)<h4 id="不稳定-2"><a href="#不稳定-2" class="headerlink" title="不稳定"></a>不稳定</h4><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4>分界点选择中间元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 快速排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[(l + r) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>链表的快排：<br><a href="https://www.acwing.com/problem/content/1453/">1451. 单链表快速排序 - AcWing题库</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3>堆，一般手动实现的时候会实现成完全二叉树，一般采用顺序存储效率较高（支持随机访问），采用树结构存储效率也较高，而采用链表效率低。<h4 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h4>大根堆：对于每个结点来说，根节点的值大于等于儿子的值。<br><img src="/2022/03/26/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_11%E6%8F%92%E5%85%A5_%E5%86%92%E6%B3%A1_%E9%80%89%E6%8B%A9_%E5%B8%8C%E5%B0%94_%E5%BF%AB%E9%80%9F_%E5%A0%86_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_11%E6%8F%92%E5%85%A5_%E5%86%92%E6%B3%A1_%E9%80%89%E6%8B%A9_%E5%B8%8C%E5%B0%94_%E5%BF%AB%E9%80%9F_%E5%A0%86_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-image-20220327130739945.png" alt="大根堆"><h5 id="大根堆的构建"><a href="#大根堆的构建" class="headerlink" title="大根堆的构建"></a>大根堆的构建</h5><blockquote><p>小根堆构建方式类似</p></blockquote></li></ol><p>存储在顺序结构中，会从下向上递归来构建。<br>down操作：时间复杂度O(logn)<br>一个堆的构建会从倒数第二层最后一个元素向上逐步构建，即：<br><code>for(int i = n/2; i &gt; 0; -- i) down(i);</code><br>构建的总时间复杂度：O(n)</p><blockquote><p>粗略计算时是O(nlogn)</p></blockquote><h5 id="堆的删除操作（特指删堆顶）"><a href="#堆的删除操作（特指删堆顶）" class="headerlink" title="堆的删除操作（特指删堆顶）"></a>堆的删除操作（特指删堆顶）</h5><p>将最后一个元素的值覆盖掉堆顶的值，删除最后一个元素，然后从堆顶开始进行down操作。<br>时间复杂度O(logn)</p><h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况：O(nlogn)<br>平均情况：O(nlogn)<br>最坏情况：O(nlogn)</p><h4 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(logn)</p><h4 id="不稳定-3"><a href="#不稳定-3" class="headerlink" title="不稳定"></a>不稳定</h4><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sz; <span class="comment">// size表示堆里有多少元素</span></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= sz &amp;&amp; q[u * <span class="number">2</span>] &gt; q[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= sz &amp;&amp; q[u * <span class="number">2</span> + <span class="number">1</span>] &gt; q[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(q[u], q[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">()</span> <span class="comment">// 堆排序，下标一定要从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz = n;</span><br><span class="line">    <span class="comment">// 构建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i --) <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="comment">// 获得排序的结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(q[<span class="number">1</span>], q[sz]);</span><br><span class="line">        sz --;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">heap_sort</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二路归并排序（merge-sort）"><a href="#二路归并排序（merge-sort）" class="headerlink" title="二路归并排序（merge sort）"></a>二路归并排序（merge sort）</h2><h4 id="时间复杂度-8"><a href="#时间复杂度-8" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好情况：O(nlogn)<br>平均情况：O(nlogn)<br>最坏情况：O(nlogn)</p><h4 id="空间复杂度-5"><a href="#空间复杂度-5" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>O(n)</p><h4 id="稳定-3"><a href="#稳定-3" class="headerlink" title="稳定"></a>稳定</h4><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>  <span class="comment">//归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid), <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 合并两个序列</span></span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) w[k ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span> w[k ++] = q[j ++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) w[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) w[k ++] = q[j ++];</span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; j &lt; k; i ++ , j ++) q[i] = w[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-10散列表(Hash表)、字符串模式匹配(KMP)</title>
      <link href="2022/03/26/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_10%E6%95%A3%E5%88%97%E8%A1%A8(Hash%E8%A1%A8)_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D(KMP)/"/>
      <url>2022/03/26/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_10%E6%95%A3%E5%88%97%E8%A1%A8(Hash%E8%A1%A8)_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D(KMP)/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="散列（Hash）表"><a href="#散列（Hash）表" class="headerlink" title="散列（Hash）表"></a>散列（Hash）表</h2><p>散列表主要是指将一个集合映射到0、1、2…的索引上，为了便于查找。<br>查找效率 == 时间复杂度          存储效率 == 负载因子</p><h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><p>$\text{负载因子} = \frac{\text{已有的元素数}}{\text{数组长度}}$<br>Hash表中一般每个索引对应一个数组，然后数组中存储对应元素，这个数组中存储元素个数决定了查找效率，即负载因子越小、查找效率越高。</p><span id="more"></span><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><h4 id="除余法"><a href="#除余法" class="headerlink" title="除余法"></a>除余法</h4><p>H(key) = key % p<br>或 H(key) = key % p + c 这里p为小于m的质数；<br>余数总在 0 ～ p-1 之间。</p><blockquote><p>为什么p选取为质数：因为如果p非质数，则key%p得到的结果取值是不均衡的，会导致有些空间被使用概率较小，最后空间利用率下降、发生冲突可能性较大。例如p为偶数，则偶数%偶数一定是偶数，奇数%偶数一定是奇数。</p></blockquote><h4 id="乘余取整法"><a href="#乘余取整法" class="headerlink" title="乘余取整法"></a>乘余取整法</h4><p>h(x) = floor(n * ((A * x)的小数部分))，0&lt;A&lt;1，n是hash表数组长度</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>先平方，然后取中间几位</p><h4 id="基数转换法"><a href="#基数转换法" class="headerlink" title="基数转换法"></a>基数转换法</h4><p>换成其他进制，然后取其中几位</p><h4 id="ELFhash字符串"><a href="#ELFhash字符串" class="headerlink" title="ELFhash字符串"></a>ELFhash字符串</h4><h3 id="解决冲突的方式"><a href="#解决冲突的方式" class="headerlink" title="解决冲突的方式"></a>解决冲突的方式</h3><p>主要解决不同的元素映射到相同位置的问题。</p><h4 id="开散列方法（拉链法）"><a href="#开散列方法（拉链法）" class="headerlink" title="开散列方法（拉链法）"></a>开散列方法（拉链法）</h4><p>如果一个索引对应多个数值，则用一个数组或链表存储当前索引对应的元素，然后用索引指向这个数组或链表。<br>经验上：上机题目中有n个元素要存储到数组中，则开2n大小的数组来存储数据。即保证负载因子大小为0.5，一般效率会比较高。<br><a href="https://www.acwing.com/activity/content/problem/content/4381/">AcWing 840. 模拟散列表 - AcWing</a><br>#TODO 没看懂  看算法基础课</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开散列方法 - Hash函数：取余法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (x % N + N) % N; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i]) <span class="comment">// ~i 当i = -1时中止循环</span></span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  <span class="comment">// 添加一条边 a -&gt; b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> t = (x % N + N) % N; <span class="comment">// 注意C++中取模运算结果正负号由被除数决定，要将其转为数学含义取模，则需要+N</span></span><br><span class="line">    <span class="built_in">add</span>(t, x);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h)); <span class="comment">// 初始化为 -1</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="闭散列方法（开放寻址法）"><a href="#闭散列方法（开放寻址法）" class="headerlink" title="闭散列方法（开放寻址法）"></a>闭散列方法（开放寻址法）</h4><h5 id="聚集和二级聚集"><a href="#聚集和二级聚集" class="headerlink" title="聚集和二级聚集"></a>聚集和二级聚集</h5><p>聚集：不同的hash值在进行探查时容易探查到同一部分的位置，即一直探查到相同部分，而其他部分空闲。<br>二次聚集：当表中i,i+1,i+2位置上已经填有记录时，下一个哈希地址为i,i+1,i+2和i+3的记录都将填入i+3的位置，这种在处理冲突过程中发生的两个第一个哈希地址不同的记录争夺同一个后继哈希地址的现象称为“ <strong>二次聚集</strong>”，即在处理同义词的冲突过程中又添加了非同义词的冲突。</p><h5 id="探查方法"><a href="#探查方法" class="headerlink" title="探查方法"></a>探查方法</h5><p>d(0) = hash(x)</p><ol><li>线性探查法 d(i) = (d(0) + i * c) % M。易产生聚集问题。 </li><li>二次探查法。易产生二级聚集问题。<br>$$<br> d(2i - 1) = (d(0) + i^2) % M<br>$$<br>$$<br> d(2i) = (d(0) - i ^2) % M<br>$$</li><li>随机探查法。易产生二级聚集问题。<br> 因为实际上是伪随机数，所以也会产生二次聚集。</li><li>双散列探查法<br>$$<br>d(i) = (d(0) + i * ReHash(key) ) % m, i =1, 2, …, m-1.<br>$$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性探查法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (x % N + N) % N; </span><br><span class="line">    <span class="keyword">while</span>(h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">t = (t + <span class="number">1</span>) % N;            </span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h)); <span class="comment">// 初始化为 0x3f3f3f3f</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题（408真题2018-41）"><a href="#例题（408真题2018-41）" class="headerlink" title="例题（408真题2018-41）"></a>例题（408真题2018-41）</h3><a href="https://www.acwing.com/activity/content/problem/content/4383/">AcWing 3820. 未出现过的最小正整数 - AcWing</a><h4 id="朴素写法"><a href="#朴素写法" class="headerlink" title="朴素写法"></a>朴素写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMissMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; hash; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">            hash.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; ; ++ i)</span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(i))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化写法"><a href="#优化写法" class="headerlink" title="优化写法"></a>优化写法</h4>分析：<br>因为nums中只有n个数，所以未出现的正整数只有两种情况。一种是nums中的数正好是1、2、…、n，然后未出现的正整数为n + 1；另一种情况是nums中的数有一部分数值范围不在[1, n]之间，那么未出现的正整数取值范围为[1, n]。<br>所以只要开大小为n的bool数组，如果1到n的数i在nums中出现就将bool数组对应位置为true，否则默认为false，然后最后输出bool数组中第一个为false的数即可，如果没有为false的，说明未出现的正整数为n + 1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMissMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">hash</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums)</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n)</span><br><span class="line">                hash[x - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span>(!hash[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h3>用平均搜索长度ASL (Averagy Search Length)衡量散列方法的搜索性能。<br>根据搜索成功与否，它又有搜索成功的平均搜索长度ASLsucc和搜索不成功的平均搜索长度ASLunsucc之分。<h4 id="搜索成功的平均搜索长度"><a href="#搜索成功的平均搜索长度" class="headerlink" title="搜索成功的平均搜索长度"></a>搜索成功的平均搜索长度</h4>搜索成功的平均搜索长度 ASLsucc 是指搜索到表中已有表项的平均探查次数。它是找到表中各个已有表项的探查次数的平均值。<h4 id="搜索不成功的平均搜索长度"><a href="#搜索不成功的平均搜索长度" class="headerlink" title="搜索不成功的平均搜索长度"></a>搜索不成功的平均搜索长度</h4>搜索不成功的平均搜索长度 ASLunsucc 是指在表中搜索不到待查的表项，但找到插入位置的平均探查次数。它是表中<strong>所有可能散列到的位置上</strong>要插入新元素时为找到<strong>空位置</strong>的探查次数的平均值。<blockquote><ol><li>针对的是所有可能散列到的位置，所以所有情况应该包括所有Hash值，默认每种情况概率相同；</li><li>找到空位置为止，如果碰到冲突则需要对应探查方式来继续探查直到找到空位置。</li></ol></blockquote><h2 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h2><h3 id="简单模式匹配算法"><a href="#简单模式匹配算法" class="headerlink" title="简单模式匹配算法"></a>简单模式匹配算法</h3>设目标T的长度为n,模式P 的长度为m,在最坏情况下，比较次数：(n-m+1) * m<br>在多数情况下，m远小于n, 因此算法的最坏的时间复杂性为$O(n * m)$。<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3>无回溯算法。KMP匹配算法的时间复杂度O(m+n)。</li></ol><ul><li>计算特征数的时间复杂度为O(m) 。<blockquote><p>KMP虽然有双重循环，但是时间复杂度是O(n)</p></blockquote></li></ul><p>前缀子串：模式串P开头的前k个字符，即$p_0, p_1, …, p_{k-1}$<br>i位置的后缀子串：在P第i位置的左边，取出k个字符，即$p_{i-k+1}, … , p_{i}$<br>第i位的最长前缀串：与i位置后缀子串相等的最长前缀子串。（非平凡的）</p><blockquote><p>这个串本身即是自己的前缀子串又是自己的后缀子串，这个前后缀称为平凡的前后缀，不在第i位的最长前缀串这个概念中考虑。例如abcabcd中第5位c的最长前缀串是abc，而不是abcabc。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#TODO 理解KMP原理，为什么可以这么做？</p><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2><p>2011-9、2014-8、2015-8、2018-9、2018-41、2019-8、2019-9</p><h3 id="2011-9"><a href="#2011-9" class="headerlink" title="2011-9"></a>2011-9</h3><p>为提高散列（Hash）表的查找效率，可以采用的正确措施是<br>I. 增加装填（载）因子<br>II. 设计冲突（碰撞）少的散列函数<br>III. 处理冲突（碰撞）使避免产生聚集（堆积）现象<br>A. 仅I         B. 仅II         C. 仅I、II         D. 仅II、III<br>B<br>题解：III出现“避免”，太绝对了。<br>#问题 不懂III<br>闭散列无法避免堆积、可以减少，开散列可以避免堆积？</p><h3 id="2019-9"><a href="#2019-9" class="headerlink" title="2019-9"></a>2019-9</h3><p>现有长度为11且初始为空的散列表HT，散例函数是H ( key ) = key%7 ,采用线性探查(线性探测再散列)法解决冲突，将关键字序列87，40，30，6，11，22，98，20依次插入到HT后，HT查找失败的平均查找长度是<br>A. 4     B. 5.25     C. 6     D. 6.29<br>C</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="2022/03/25/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>2022/03/25/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>向下取整：<br>$\lfloor x \rfloor$<br>向上取整：<br>$\lceil x \rceil$</p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-09查找基本概念、顺序、折半、分块查找法、B/B+树</title>
      <link href="2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/"/>
      <url>2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><h3 id="平均查找长度ASL"><a href="#平均查找长度ASL" class="headerlink" title="平均查找长度ASL"></a>平均查找长度ASL</h3><p>平均查找长度 ASL = 每个元素 查找概率 * 找到第i个元素需要进行的比较次数 的和。<br>ASL（成功） = $\sum_i{P_iC_i}$，其中每个<strong>元素查找概率</strong>$P_i = 1/n$，$C_i$表示查找成功需要的比较次数<br>ASL（失败） = $\sum_{\text{区间}}{P_iC_i}$，其中$P_i$表示<strong>查找区间找到的概率</strong>，所以$P_i=1/(n+1)$</p><span id="more"></span><blockquote><p>注，理论中查找的比较操作，一般得到三种情况：大于、等于、小于；也有两种的：相等、不相等。</p></blockquote><h3 id="决策树-判定树"><a href="#决策树-判定树" class="headerlink" title="决策树(判定树)"></a>决策树(判定树)</h3><h2 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h2><h3 id="一般线性表的顺序查找"><a href="#一般线性表的顺序查找" class="headerlink" title="一般线性表的顺序查找"></a>一般线性表的顺序查找</h3><ol><li>若每个元素查找概率相同，则 ASL(成功) = (1 + 2 + … + n) / n = (n + 1) / 2</li><li>ASL(失败) = n或n+1，取决于代码写法。</li></ol><p><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220325100402534.png" alt="一般线性表的顺序查找"></p><h3 id="有序表的顺序查找"><a href="#有序表的顺序查找" class="headerlink" title="有序表的顺序查找"></a>有序表的顺序查找</h3><ol><li>若每个元素查找概率相同，则 ASL(成功) = (1 + 2 + … + n) / n = (n + 1) / 2</li><li>ASL(失败) = (1 + 2 + … + n + n) / (n + 1) = n / 2 + n / (n + 1)</li></ol><p><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220325100301001.png" alt="有序表的顺序查找"></p><h2 id="折半查找法"><a href="#折半查找法" class="headerlink" title="折半查找法"></a>折半查找法</h2><p>折半查找法需要先保证<strong>序列有序</strong><br>折半查找中mid的取值方式有两种（下取整、上取整），对应的判断方式对应改变，如下：<br>$$<br>mid = \frac{low+high}{2}<br>$$<br>$$<br>mid = \frac{low+high+1}{2}<br>$$<br>一般笔试中采用：$mid = \lfloor{\frac{low+high}{2}}\rfloor$<br>ASL（成功） = log(n + 1) - 1        时间复杂度$O(log_2n)$</p><blockquote><p>链表不支持随机索引，所以不能用折半查找。</p></blockquote><h2 id="分块查找法"><a href="#分块查找法" class="headerlink" title="分块查找法"></a>分块查找法</h2><p>设共n个元素，每块s个元素，共b = n / s块。块内无序，块间有序。</p><ol><li>顺序查找确定块：<br> $ASL(\text{成功}) = \frac{\frac{n}{s}+1}{2}+\frac{s+1}{2}=\frac{s^2 + 2s + n}{2s}$，$s = \sqrt{n}$时取最小值</li><li>二分查找确定块：<br> $ASL(\text{成功}) = log(\frac{n}{s} + 1) -1 + \frac{s+1}{2}=log(\frac{n}{s} + 1) + \frac{s - 1}{2}$</li></ol><blockquote><p>块内无序，所以一般都用顺序查找</p></blockquote><h2 id="B-、B-树"><a href="#B-、B-树" class="headerlink" title="B 、B+树"></a>B 、B+树</h2><p>B树、B+树主要应用于硬盘（读写速度很慢），一般用于文件系统管理、数据库管理等数据量大的地方。</p><blockquote><p>一般来说，文件索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。而B-/B+/B* 树，经过改进可以有效的利用系统对磁盘的块读取特性，在读取相同磁盘块的同时，尽可能多的加载索引数据，来提高索引命中效率，从而达到减少磁盘IO的读取次数。<br>例如采用一个阶数很大的B树存储索引。</p></blockquote><p>B树、B+树是二叉搜索树BST的扩展。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ol><li>m阶B树，每个节点最多有m个孩子。m阶→最多有m个孩子</li><li>每个节点最多有m-1个关键字（可以存有的键值对）。</li><li>根节点要么是空，要么是独根，否则根节点最少只有1个关键字。</li><li>非根节点<strong>至少有$\lceil{m/2}\rceil$个子树</strong>，即至少有$\lceil{m/2}\rceil-1$个关键字。</li><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li><strong>每个节点都存有索引和数据</strong>，也就是对应的key和value。</li><li>所以，根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。<blockquote><p>保证树高度为log<sub>m</sub>级别</p></blockquote><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4>注意，插入、删除操作的分裂是递归的，要注意分裂后父节点是不是还需要递归地进行分裂<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5>插入操作是指插入一条记录，即(key, value)的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key,则一定是在叶子结点中进行插入操作。</li><li>根据要插入的key的值，<strong>找到叶子结点</strong>并插入。<blockquote><p>注意：只能在<strong>叶节点</strong>插入！</p></blockquote></li><li>判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。</li><li>以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，<strong>然后将当前结点指向父结点，递归进行第2、3步</strong>。<blockquote><p>当阶数m为偶数时，需要分裂时选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。</p></blockquote></li></ol><p>可以看出，如果B树的结点采用固定大小方式存储，最坏情况下每个结点会有50%的空置率，即所有节点都只有m/2的子树的情况。</p><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。</p><ol><li>如果当前需要删除的key位于非叶子结点上，则<strong>用后继key</strong>（这里的后继key均指后继记录的意思）<strong>覆盖要删除的key</strong>，然后在后继key（一般指第一个大于这个key的key值）所在的子支中删除该后继key。删除这个记录后执行第2步。</li><li>该结点key个数大于等于$\lceil{m/2}\rceil-1$，结束删除操作，否则执行第3步。</li><li>分为以下情况：<ol><li>如果兄弟结点key个数<strong>大于</strong>$\lceil{m/2}\rceil-1$，则父结点中的连接这两兄弟结点的key下移到该结点，兄弟结点中的一个key（最大或最小）上移，删除操作结束。</li><li>如果兄弟结点key个数<strong>小于或等于</strong>$\lceil{m/2}\rceil-1$，将父结点中的连接这两兄弟结点的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。</li></ol> 然后当前结点的指针指向父结点，重复上第2步。<blockquote><p>有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。</p></blockquote><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><blockquote><p>这里AcWing讲解中的定义与408教材的定义不同，所以以下内容采用了408的定义。</p></blockquote></li></ol><p>B树与B+树的相同之处：</p><ol><li>非根节点<strong>至少有$\lceil{m/2}\rceil$个子树</strong>；</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。<br>B树与B+树的不同之处：</li><li>有k个子结点的结点必有<strong>k个关键码</strong>。非根结点至少有$\lceil{m/2}\rceil$<strong>个关键码</strong>；</li><li>根节点要么是空，要么是独根，否则B+树的<strong>根结点</strong>至少有<strong>两个子结点</strong>；</li><li>B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li><li>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；<blockquote><p>数据都存储到叶节点可以很好利用局部性，从而提高读写效率、缓存命中率等。</p></blockquote></li><li>B+树叶子节点的关键字从小到大有序排列，<strong>左边结尾数据都会保存右边节点开始数据的指针</strong>，方便遍历。<br><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220325203550450.png" alt="B+树"><br>B+树的叶节点一般链接起来形成一个单链表/双链表。</li></ol><p>通常在B+树中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点。因此，可以对B+树进行两种查找运算：一种是从最小关键字开始的<strong>顺序查找</strong>（链表不适合二分查找），另一种是从根节点开始的<strong>多路查找</strong>。</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><p>B+树的查找、插入和删除操作和B树的基本类似，只是在查找过程中，非叶节点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶节点上的该关键字为止。所以，在B+树中查找时，无论查找成功与否，每次查找都是一条从根节点到叶节点的路径。</p><h5 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h5><p><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/B+%E6%A0%91%E6%8F%92%E5%85%A5.png" alt="B+树插入操作"></p><h5 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h5><p>当关键码不满时，与左右兄弟进行调整、合并的处理和B树类似。<br>关键码在叶结点层删除后,其在上层的复本可以保留，做为一个“分界关键码”存在，也可以替换为新的最大关键码(或最小关键码)<br><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A4.png" alt="B+树删除"></p><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2><p>2011-42、2012-9、2013-10、2013-42、2014-9、2015-7、2016-9、2016-10、2017-8、2017-9、2018-8、2020-10</p><h3 id="2011-42"><a href="#2011-42" class="headerlink" title="2011-42"></a>2011-42</h3><p>#好题<br><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220325230155191.png" alt="2011-42"><br>核心思想：中位数左边的数个数为L/2，右边的数个数为L/2。（考虑偶数，则需要由题目中中位数定义得到左右两边数的个数。）<br>（1）解答：求序列A和B的中位数过程如下：</p><ol><li>分别求序列A和B的中位数，设为a和b，若a=b，则a或b即为所求中位数，算法结束。</li><li>若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求舍弃的长度一致（可以只舍弃一部分）。</li><li>若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求舍弃的长度一致（可以只舍弃一部分）。<br>然后在保留的两个序列中重复1.2.3.步骤，直到两个序列中只保留一个元素或满足a=b即找到中位数。<br>（2）<br><a href="https://www.acwing.com/problem/content/3822/">3819. 求两升序序列的中位数 - AcWing题库</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">medianSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; S1 , vector&lt;<span class="keyword">int</span>&gt;&amp; S2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>, r1 = S1.<span class="built_in">size</span>() - <span class="number">1</span>, r2 = S2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m1 = (l1 + r1) &gt;&gt; <span class="number">1</span>, m2 = (l2 + r2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; r1 &amp;&amp; l2 &lt; r2)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span>(S1[m1] == S2[m2]) <span class="keyword">return</span> S1[m1];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S1[m1] &gt; S2[m2]) <span class="comment">// 小的舍弃掉左侧，大的舍弃掉右侧</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> bl = (r1 + l1) % <span class="number">2</span>;</span><br><span class="line">                r1 = m1;</span><br><span class="line">                l2 = m2 + bl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> bl = (r1 + l1) % <span class="number">2</span>;</span><br><span class="line">                r2 = m2;</span><br><span class="line">                l1 = m1 + bl;</span><br><span class="line">            &#125;</span><br><span class="line">            m1 = l1 + r1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            m2 = l2 + r2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> S1[m1] &lt; S2[m2] ? S1[m1] : S2[m2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>（3）解答：时间复杂度：$O(log_2n)$，空间复杂度$O(1)$。<h3 id="2013-42"><a href="#2013-42" class="headerlink" title="2013-42"></a>2013-42</h3>设包含 4 个数据元素的集合 S={ “ do”，” for”，” repeat”，” while”}，各元素的查找概率依次为 p1= 0.35，p2 = 0.15，p3=0. 15，p4=0.35。将S保存在一个长度为4的顺序表中，采用折半查找法，查找成功时的平均查找长度为 2.2 。请回答</li><li>若采用顺序存储结构保存 S ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？</li><li>若采用链式存储结构保存 S ，且要求平均查找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？<blockquote><p>注：第2问中，<strong>树</strong>和链表都属于链式存储结构！<br><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220326095753120.png" alt="2013-42"><br>#问题 折半查找的查找成功的平均查找长度如何计算？<br>一般笔试时采用$mid = \lfloor\frac{low+high}{2}\rfloor$，上面这题：<br><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220326104039457.png" alt="2013-42折半查找"><br>ACL(成功) = 0.35 * 2 + 0.15 * 1 + 0.15 * 2 + 0.35 * 3 = 2.2</p></blockquote><h3 id="2016-9"><a href="#2016-9" class="headerlink" title="2016-9"></a>2016-9</h3><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220326112902350.png" alt="2016-9"><br>B<blockquote><p>注意A选项，本算法的比较次数大概是O(n/3)，不是O(log<sub>3</sub>n)！而折半查找大概是O(logn)，所以折半更优。</p></blockquote><h3 id="2017-8"><a href="#2017-8" class="headerlink" title="2017-8"></a>2017-8</h3><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220326095641571.png" alt="2017-8"><br>A<br>题解：<br>首先要注意，mid的取法有两种，一种(low+high)/2上取整，一种(low+high)/2下取整，所以折半查找判定树满足一个即可。<br>#知识点 折半查找判定树属于平衡的二叉搜索树！<br>然后折半查找判定树需要满足，每个结点以他为根节点构成的树的最大最小key值（包括根节点）之和除以2按照mid取法上/下取整以后的值等于该节点key值，得到的值要和该结点的key值相同，如选项A：<br><img src="/2022/03/25/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_09%E6%9F%A5%E6%89%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E9%A1%BA%E5%BA%8F_%E6%8A%98%E5%8D%8A_%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E6%B3%95_B_B+%E6%A0%91-image-20220326113949388.png" alt="2017-8-A"><br>可以发现，该树mid取值方法为上去整，而对于每个结点而言，以他为根节点构成的树的最大最小key值（包括根节点）之和除以2上去整以后的值等于该节点key值。<br>B、C、D既有上取整又有下取整，所以不可能构成折半查找树。<h3 id="2017-9"><a href="#2017-9" class="headerlink" title="2017-9"></a>2017-9</h3>下列应用中，适合使用B+树的是：<br>A．编译器中的词法分析           B.关系数据库系统中的索引<br>C．网络中的路由表快速查找   D.操作系统的磁盘空闲块管理<br>B<br>题解：B+树一般用于磁盘、数据库等大容器的存储<br>A. 内存中的操作，一般不用B+树<br>B. 数据库一般很大，索引很多，所以一般采用B+树等<br>C. 路由表<strong>快速</strong>查找，所以一般也是内存中进行，一般不用B+树<br>D. 操作系统磁盘空闲块管理，管理的是索引，一般用链表等管理</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题_01数组</title>
      <link href="2022/03/24/LeetCode%E5%88%B7%E9%A2%98_01%E6%95%B0%E7%BB%84/"/>
      <url>2022/03/24/LeetCode%E5%88%B7%E9%A2%98_01%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><span id="more"></span><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><p><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123; <span class="comment">// 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                i--; <span class="comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">                size--; <span class="comment">// 此时数组的大小-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> LeetCode </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-08最小生成树、最短路、关键路径</title>
      <link href="2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
      <url>2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h2><p>有向图、无向图都有最小生成树，不过一般考研只考无向图的最小生成树。<br>生成树定义1：从图中选n-1条边使得整个图连通，同时<strong>总边权和最小</strong>。<br>生成树定义2：从图中选n-1条边使得整个图连通，同时<strong>最大边权最小</strong>。<br>以上两种定义方式求出来的生成树本质上是相同的。</p><span id="more"></span><p>最小生成树不一定唯一。最小生成树唯一的充分条件：将任意一个非树边加到最小生成树以后构成的环中，除了这个加入的边，其他树边都小于他。<br>可以构建生成树的算法：Prim、Kruskal</p><table><thead><tr><th>算法</th><th>说明</th><th>时间复杂度</th><th>适合</th></tr></thead><tbody><tr><td>Prim</td><td>朴素版</td><td>$O(n^2)$</td><td>稠密图</td></tr><tr><td></td><td>堆优化版</td><td>$O(mlogn)$</td><td>稀疏图</td></tr><tr><td>Kruskal</td><td></td><td>$O(mlogm)$</td><td></td></tr><tr><td>一般来说，题目是稠密图则采用Prim算法，是稀疏图则采用Kruskal算法</td><td></td><td></td><td></td></tr></tbody></table><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>图中可能存在重边和自环，边权可能为负数。</p><ol><li>选取一个起始节点加入到已连接的集合T中</li><li>考虑所有与集合T中节点相连的外部边（边的另一个节点不在集合T中），找到其中边权值最小的边（没有边相连的两个点之间边权默认为正无穷），将对应节点加入到集合T中</li><li>重复操作2共计节点数n次。如果最后边权和为正无穷，则说明存在孤立点，不能构成最小生成树，反之可以构成生成树。<br><a href="https://www.acwing.com/activity/content/problem/content/4366/">AcWing 858. Prim算法求最小生成树 - AcWing</a><br>朴素版，时间复杂度$O(n^2)$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">1e5</span>+<span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N], dist[N]; <span class="comment">// g存储所有边 dist</span></span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// 节点是否已经被放入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist)); <span class="comment">// 将数组所有元素置为正无穷</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="comment">// 总共n个点，所以循环n次就能把所有点加入进来</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>; <span class="comment">// 当前边权最小的点的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) <span class="comment">// 如果当前点不在生成树中，并且当前t不是点的下标或不是最好的点的下标</span></span><br><span class="line">                t = j;</span><br><span class="line">        <span class="keyword">if</span>(dist[t] == INF) <span class="comment">// 如果当前最好的边都是INF，说明不连通</span></span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="comment">// 更新其他节点到已构建树中节点的最小距离</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g)); <span class="comment">// 将每个字节设置为最大</span></span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], w);  <span class="comment">// 有重边的情况，只存最小的即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(res == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#技巧 0x3f3f3f3f近似int最大值<br>0x3f3f3f3f是一个很有用的数值，它是满足以下两个条件的最大整数。<br>1、整数的两倍不超过 0x7f7f7f7f，即int能表示的最大正整数。<br>2、整数的每8位（每个字节）都是相同的。<br>我们在程序设计中经常需要使用 memset(a, val, sizeof a) 初始化一个数组a，该语句把数值 val（0x00~0xFF）填充到数组a 的每个字节上，所以用memset只能赋值出“每8位都相同”的 int。<br>当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 <code>memset(a, 0x3f, sizeof(a))</code> 给数组赋 0x3f3f3f3f的值来代替。<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3></li><li>初始时默认所有节点各自为一个块</li><li>选取所有非同块边（即边的两个节点不在同一个块内）中边权最小的边，将两个节点合并到同一个块</li><li>重复操作2共节点数n次。如果最后只剩下一个块，说明存在最小生成树，否则不存在最小生成树。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">1e5</span>+<span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 查找并查集的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;e[i].a, &amp;e[i].b, &amp;e[i].c);</span><br><span class="line">    <span class="built_in">sort</span>(e, e + m); <span class="comment">// 将所有边排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = i; <span class="comment">// 初始化并查集的元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = n; <span class="comment">// cnt定义块的个数，初始为节点数n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = e[i].a, b = e[i].b, c = e[i].c;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a) != <span class="built_in">find</span>(b)) <span class="comment">// 如果两个块的根元素不是同一个，即不在同一个块</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += c;</span><br><span class="line">            cnt --;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); <span class="comment">// 将块a和块b合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// 最后还剩余多个块</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-image-20220323221127460.png" alt="最短路"><br>Floyd既可以处理正权，又可以处理负权。<h3 id="单源最短路-Dijkstra"><a href="#单源最短路-Dijkstra" class="headerlink" title="单源最短路 Dijkstra"></a>单源最短路 Dijkstra</h3>本质：贪心算法<br>求解给定点n<sub>1</sub>到其他所有节点的最短距离<blockquote><p>Dijkstra算法与Prim算法代码实现基本相同，除了<code>dist[j] = min(dist[j], dist[t] + g[t][j]); </code>计算距离方式不同。</p></blockquote></li></ol><p>#技巧 Dijkstra得到的节点距离序列一定是递增的<br><a href="https://www.acwing.com/activity/content/problem/content/4367/">AcWing 849. Dijkstra求最短路 I - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N], dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t == <span class="number">-1</span>||dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(!st[j])</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]); <span class="comment">// 与Prim算法的不同之处</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    <span class="keyword">while</span>(m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">if</span>(res == INF) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多源汇最短路-Floyd"><a href="#多源汇最短路-Floyd" class="headerlink" title="多源汇最短路 Floyd"></a>多源汇最短路 Floyd</h3><p>求解任意两个点之间的最短距离。<br><a href="https://www.acwing.com/activity/content/problem/content/4368/">AcWing 854. Floyd求最短路 - AcWing</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) d[i][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> c = d[a][b];</span><br><span class="line">        <span class="keyword">if</span>(c &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);  <span class="comment">// 因为可能存在负边，所以只要大于一个较大的数即说明不可达</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>工程网络图（AOE网络）  拓扑图<br>节点是事件，边是活动，边权是代价。这个有向图中不能有环。<br>关键路径表示了完成整个工程的最小代价，是从源点到汇点的最长路径。<br>关键路径不一定唯一。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>可以使用递推求解，即DP，时间复杂度$O(n + m)$<br>可以使用Floyd，时间复杂度$O(n^3)$<br>可以使用Bellman-Ford算法，时间复杂度$O(nm)$<br><strong>不可以</strong>用Dijkstra来求解正权图上最长路</p><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2><p>2011-41、2012-7、2012-8、2013-9、2015-6、2015-42、2016-8、2017-42、2018-42、2019-5、2020-7、2020-8</p><h3 id="2011-41"><a href="#2011-41" class="headerlink" title="2011-41"></a>2011-41</h3><p><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-image-20220324204720638.png" alt="2011-41"><br>#知识点 上三角矩阵<br>上三角矩阵：包含对角线。<br>#TODO ==那这道题为什么邻接矩阵这么画？==<br>#问题 邻接矩阵的对角线元素应该填写什么？没有边连的地方值应该是什么？<br>无权图中：所有元素都是0表示无边，1表示有边，所以一般元素或对角线元素默认为0<br>有权图中：</p><h3 id="2017-42"><a href="#2017-42" class="headerlink" title="2017-42"></a>2017-42</h3><p>#知识点 对任意的带权连通图，满足什么条件时，其MST是唯一的？<br>充分条件1：当带权连通图的任意一个环中所包含的边的权值均不相同时，其MST是唯一的<br>充分条件2：带权连通图的所有边的权值均不相同</p><h3 id="2018-42"><a href="#2018-42" class="headerlink" title="2018-42"></a>2018-42</h3><p><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/2018_42.png" alt="2018-42"><br>#问题 如果TTL正好与跳数相同，那么数据会被接收吗？还是说数据直接被抛弃？如上题</p><h3 id="2019-5"><a href="#2019-5" class="headerlink" title="2019-5"></a>2019-5</h3><p>下图所示的AOE网表示一项包含8个活动的工程，活动d的最早开始时间和最迟开始时间分别是：<br><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_08%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-image-20220324215726709.png" alt="2019-5"><br>C<br>#注意 事件与活动之间的关系<br>设活动a关联的前后事件分别是v<sub>i</sub>，v<sub>j</sub>，则有<br>$$<br>a\text{的最早开始时间} = v_i\text{的最早开始时间}<br>$$<br>$$<br>a\text{的最晚开始时间} = v_j\text{的最晚开始时间} - a\text{的工作长度}<br>$$<br>#TODO 学习并练一下关键路径问题</p><h3 id="2020-8"><a href="#2020-8" class="headerlink" title="2020-8"></a>2020-8</h3><ol><li>关键路径是从原点到汇点路径长度最长的路径</li><li>增加任一关键活动的时间一定会延长工程的工期</li><li>缩短任一关键活动的时间不一定会缩短工程的工期，因为关键路径不一定只有一条</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-07图的基本概念、存储、遍历、拓扑排序</title>
      <link href="2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="有向图、无向图"><a href="#有向图、无向图" class="headerlink" title="有向图、无向图"></a>有向图、无向图</h3><p>树是特殊的图。<br>图G=&lt;V, E&gt;。<br>有向图：边有方向的图<br>无向图：边没有方向的图。很多算法中，无向边可以看作两个有向边进行处理。</p><span id="more"></span><p>混合图：有的边有方向，有的边没有方向构成的图。</p><h3 id="度数（出度、入度）"><a href="#度数（出度、入度）" class="headerlink" title="度数（出度、入度）"></a>度数（出度、入度）</h3><p>无向图中，度数指节点连接的边的数量。<br>有向图中，度数等于入度加出度。出度指从节点出发指向其他节点的边数，入度指从其他节点出发指向该节点的边数。</p><h3 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h3><p>简单图：没有自环（不存在顶点到其自身的边），没有重边（且同一条边不重复出现）。</p><h3 id="路径、环、简单路径"><a href="#路径、环、简单路径" class="headerlink" title="路径、环、简单路径"></a>路径、环、简单路径</h3><p>路径<br>环：路径起点和终点一致<br>简单路径：路径中不包含重复节点</p><h3 id="无向完全图"><a href="#无向完全图" class="headerlink" title="无向完全图"></a>无向完全图</h3><p>任意两个顶点之间都存在边，有n个顶点的无向完全图有 n × (n - 1) / 2条边</p><h3 id="有向完全图"><a href="#有向完全图" class="headerlink" title="有向完全图"></a>有向完全图</h3><p>任意两个顶点之间都存在方向相反的两条弧，有n个顶点的无向完全图有 n × (n - 1) 条弧</p><h3 id="稀疏图-amp-稠密图"><a href="#稀疏图-amp-稠密图" class="headerlink" title="稀疏图&amp;稠密图"></a>稀疏图&amp;稠密图</h3><p>有很少条边或弧的图称为稀疏图，反之称为稠密图，相对的概念。</p><h2 id="图的存储及基本操作"><a href="#图的存储及基本操作" class="headerlink" title="图的存储及基本操作"></a>图的存储及基本操作</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>适用于稠密图（点数较少的稀疏图也可以用邻接矩阵存储），可存有向图（对称矩阵）、无向图。常用。空间复杂度：$O(n^2)$。无法存重边。<br>适用算法：Floyd算法等</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表：每个节点存储一个包含可以到达的节点的集合（无向图中即两点间有边，有向图中即有该点指向对应点的边）。存储方式：单链表、vector、数组、set、queue、stack等。<br>适用于稀疏图（稠密图也可以用，空间复杂度$O(n^2)$），可存有向图、无向图。常用。空间复杂度：$O(n + m)$。可存重边。<br><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-image-20220323134801566.png" alt="邻接表"><br>邻接表可以存储重边。<br><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-image-20220323135327887.png" alt="邻接表存储重边"></p><blockquote><p>邻接表比较常用，因为空间复杂度相对小。</p></blockquote><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接表存储无向图时，删除边不容易操作，因为要删除两个存储的数据，比如1到3之间删除边，既要删除1中存储的3，还要删除3中存储的1。但是已知一个边找反向边是困难的，所以邻接多重表针对这个问题进行了改进，比较方便找反向边。<br>适用于稀疏图，可<strong>存无向图</strong>。不常用。空间复杂度：$O(n + m)$。可存重边。<br><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-image-20220323140645010.png" alt="无向图及其对应的邻接多重表"></p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>十字链表是对邻接矩阵的优化。</p><blockquote><p>实际上，十字链表是对矩阵的操作，对矩阵进行压缩存储。</p></blockquote><p>适用于稀疏图，可存有向图、无向图。不常用。空间复杂度：$O(n + m)$。无法存重边。<br><img src="/2022/03/23/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_07%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E5%AD%98%E5%82%A8_%E9%81%8D%E5%8E%86_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-image-20220323141112397.png" alt="十字链表"></p><blockquote><p>十字链表常用于Dancing Linksing算法，Dancing Linksing求解数独、八皇后等精确覆盖或重复覆盖类型的问题。</p></blockquote><h3 id="三元组表"><a href="#三元组表" class="headerlink" title="三元组表"></a>三元组表</h3><p>适用于稀疏图，可存有向图，无向图。空间复杂度：$O(m)$。可存重边。<br>常用于Bellman-Ford算法、Kruskal算法。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h3><p>邻接表存储的时间复杂度：$O(n + m)$。邻接矩阵存储的时间复杂度：$O(n^2)$<br>DFS的到达顺序称为DFS序列。递归在开头写。</p><blockquote><p>DFS的回溯顺序是拓扑排序。递归在结尾写。</p></blockquote><p>#注意 DFS时注意<strong>遍历所有点</strong>，以防遗漏孤立点。<br>#注意 因为DFS实现是通过递归实现的，所以需要用到大量的栈空间。但是有的OJ平台栈空间设定的很小，所以有可能出现问题。因此拓扑排序问题尽量用BFS。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> _id): <span class="built_in">id</span>(_id), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;*head[N];</span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// 判重数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Node</span>(b);</span><br><span class="line">p -&gt; next = head[a];</span><br><span class="line">head[a] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[u] = <span class="literal">true</span>;  <span class="comment">// 注意记录是否被遍历过</span></span><br><span class="line">cin &lt;&lt; u &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = head[u]; p; p = p -&gt; next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = p -&gt; id;</span><br><span class="line"><span class="keyword">if</span>(!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS一定要枚举所有点，防止有孤立点被遗忘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span>(!st[i])</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h3><p>邻接表存储的时间复杂度：$O(n + m)$。邻接矩阵存储的时间复杂度：$O(n^2)$</p><blockquote><p>无论是DFS还是BFS进行遍历的时候都要记得判重。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS通过queue实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> _id): <span class="built_in">id</span>(_id), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;*head[N];</span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">// 判重数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Node</span>(b);</span><br><span class="line">p -&gt; next = head[a];</span><br><span class="line">head[a] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(u);</span><br><span class="line">st[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = head[t]; p; p = p -&gt; next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = p -&gt; id;</span><br><span class="line"><span class="keyword">if</span>(!st[j])</span><br><span class="line">&#123;</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// DFS要枚举所有点，防止有孤立点被遗忘</span></span><br><span class="line"><span class="comment">for(int i = 1; i &lt;= n; ++ i)</span></span><br><span class="line"><span class="comment">if(!st[i])</span></span><br><span class="line"><span class="comment">bfs(i);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不过一般DFS题目中不存在孤立点或最后答案不受孤立点影响</span></span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#知识点 BFS第一次找到节点一定是通过最短路径找到的，所以BFS可以用来求最短路。</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>若一个由图中所有点构成的序列A满足：对于图中的每条边(x,y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。<br>一个图的拓扑排序==可能==<strong>不唯一</strong>。<br>不是所有图都有拓扑排序，可能有的图没有拓扑排序（例如图内有环）。有向图存在拓扑排序 充要条件 这个图没有环。可以有重边，但是不能有自环。<br>拓扑排序既可以用DFS实现，也可以用BFS实现。<br>#注意 因为DFS实现是通过递归实现的，所以需要用到大量的栈空间。但是有的OJ平台栈空间设定的很小，所以有可能出现问题。因此拓扑排序问题尽量用BFS。</p><h3 id="BFS实现拓扑排序"><a href="#BFS实现拓扑排序" class="headerlink" title="BFS实现拓扑排序"></a>BFS实现拓扑排序</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>先将所有入度为0的点放入队列</li><li>取出队列里的一个点，访问一下，再将这个点和相连的边从图中删去</li><li>如果这点去除以后他的相邻节点中出现了入度为0的点，则也放入队列</li><li>循环2、3操作直到队列为空即可实现拓扑排序<br>时间复杂度：O(n + m)<h4 id="判定图是否存在拓扑排序"><a href="#判定图是否存在拓扑排序" class="headerlink" title="判定图是否存在拓扑排序"></a>判定图是否存在拓扑排序</h4>通过上述遍历思路进行遍历，然后判断是否所有节点都被遍历过，如果存在节点没有被遍历过，说明图不存在拓扑排序。<br><a href="https://www.acwing.com/activity/content/problem/content/4356/">AcWing 848. 有向图的拓扑序列 - AcWing</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS实现拓扑排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> _id): <span class="built_in">id</span>(_id), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;*head[N];</span><br><span class="line"><span class="keyword">int</span> d[N], q[N]; <span class="comment">// d 存储节点入度数  q 模拟队列，这样遍历完以后，队列中数据就是拓扑排序的序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Node</span>(b);</span><br><span class="line">p -&gt; next = head[a];</span><br><span class="line">head[a] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span>(!d[i])</span><br><span class="line">q[++ tt] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t = q[hh ++]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = head[t]; p; p = p -&gt; next)</span><br><span class="line"><span class="keyword">if</span>(-- d[p -&gt; id] == <span class="number">0</span>)</span><br><span class="line">q[++ tt] = p -&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">d[b] ++; <span class="comment">// 入度+1</span></span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);  <span class="comment">// 如果没有拓扑排序</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS实现拓扑排序"><a href="#DFS实现拓扑排序" class="headerlink" title="DFS实现拓扑排序"></a>DFS实现拓扑排序</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4>DFS只需要将访问操作放到dfs函数的尾部输出的即是拓扑排序的逆序。<br>理解：将访问操作放到dfs递归入口的后面，说明当前元素的访问将会在他可以深度遍历到的元素的后面执行，这样与拓扑排序的说法正好相反。<h4 id="判定图是否存在拓扑排序-1"><a href="#判定图是否存在拓扑排序-1" class="headerlink" title="判定图是否存在拓扑排序"></a>判定图是否存在拓扑排序</h4>有向图存在拓扑排序 充要条件 这个图没有环。DFS可以判断图中是否存在环，即递归过程中访问到同一个元素即说明图中有环。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS实现拓扑排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> _id): <span class="built_in">id</span>(_id), <span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;*head[N];</span><br><span class="line"><span class="keyword">int</span> st[N]; <span class="comment">// 0表示未遍历过 1表示节点在递归中 2表示已经遍历过</span></span><br><span class="line"><span class="keyword">int</span> q[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">Node</span>(b);</span><br><span class="line">p -&gt; next = head[a];</span><br><span class="line">head[a] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[u] = <span class="number">1</span>;  <span class="comment">// u在递归中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = head[u]; p; p = p -&gt; next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = p -&gt; id;</span><br><span class="line"><span class="keyword">if</span>(!st[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(j)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// dfs同时如果有环返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(st[j] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果已在递归中说明有环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问操作</span></span><br><span class="line">q[top ++ ] = u;</span><br><span class="line">st[u] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// DFS一定要枚举所有点，防止有孤立点被遗忘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">if</span>(!st[i] &amp;&amp; !<span class="built_in">dfs</span>(i))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2>2011-8、2012-5、2012-6、2013-7、2013-8、2014-7、2015-5、2016-6、2016-7、2017-3、2017-7、2018-7、2020-6</li></ol><p>#知识点 时/空复杂度</p><table><thead><tr><th>算法</th><th>描述</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>深度优先遍历/拓扑排序</td><td>邻接矩阵</td><td>$O(n^2)$</td><td>$O(n^2)$</td></tr><tr><td>深度优先遍历/拓扑排序</td><td>邻接表</td><td>$O(n+m)$</td><td>$O(n+m)$</td></tr><tr><td>广度优先遍历/拓扑排序</td><td>邻接矩阵</td><td>$O(n^2)$</td><td>$O(n^2)$</td></tr><tr><td>广度优先遍历/拓扑排序</td><td>邻接表</td><td>$O(n+m)$</td><td>$O(n+m)$</td></tr><tr><td>#技巧 广度优先遍历得到的序列一定是按照最短距离排序的，凭借此可以快速判断哪些不是广度优先遍历。</td><td></td><td></td><td></td></tr><tr><td>#知识点 适用于压缩存储稀疏矩阵的存储结构：三元组表、十字链表</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础知识</title>
      <link href="2022/03/22/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2022/03/22/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="argument"><a href="#argument" class="headerlink" title="argument"></a>argument</h2><p>JavaScript函数可以接受任意个数的参数，通过arguments可以访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>] != <span class="string">&quot;Hello&quot;</span>)&#123;</span><br><span class="line">alert(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">alert(<span class="built_in">arguments</span>.length); <span class="comment">// 返回参数类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>arguments对象代表正在执行的函数和调用它的参数</p><ul><li>函数对象的length属性说明函数定义时指定的参数个数</li><li>arguments对象的length属性说明调用函数时实际传递的参数个数<br>arguments对象不能显式创建，函数在运行时并被调用时由JavaScript运行时环境创建并设定各个属性值，其中包括各个参数的值。<br>通常使用arguments对象来验证所传递的参数是否符合函数要求<h2 id="函数返回类型"><a href="#函数返回类型" class="headerlink" title="函数返回类型"></a>函数返回类型</h2><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3>将表面值返回<h3 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h3>当对象是通过new创建的时候，返回这个对象时，返回的是引用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> List = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;lili&quot;</span>, <span class="string">&quot;petter&quot;</span>)l</span><br><span class="line"><span class="keyword">return</span> List;  <span class="comment">// 返回的是引用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = get()</span><br><span class="line">name = <span class="literal">null</span>;  <span class="comment">// 删除引用</span></span><br></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2>将字符串当作JavaScript语句进行执行<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2>JavaScript中数组底层实现，实际上存储的是引用，而不是值。所以JavaScript的数组的元素类型可以不同。<br>JavaScript的数组是<strong>变长的</strong>。<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4>方法一：<br>arr.push();<br>方法二：<br>arr[下标] = 值;<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4>delete arr[下标]</li></ul><h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><p>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：<br><code>var person=&#123;firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566&#125;;</code></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-06Huffman树</title>
      <link href="2022/03/22/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_06Huffman%E6%A0%91/"/>
      <url>2022/03/22/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_06Huffman%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="Huffman编码和Huffman树"><a href="#Huffman编码和Huffman树" class="headerlink" title="Huffman编码和Huffman树"></a>Huffman编码和Huffman树</h2><h3 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h3><h4 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h4><p>前缀编码是指对字符集进行编码时，要求字符集中<strong>任一字符的编码都不是其它字符的编码的前缀</strong>。<br>编码的总长度 = SUM（被编码的字符对应的编码长度 * 字符出现次数有关）</p><span id="more"></span><p>当字符集实现了前缀编码，那么解码结果是唯一的不会有歧义。<br>前缀编码 &lt;=&gt;所有编码均对应树的<strong>叶节点</strong></p><h4 id="树的带权路径长度-WPL"><a href="#树的带权路径长度-WPL" class="headerlink" title="树的带权路径长度(WPL)"></a>树的带权路径长度(WPL)</h4><p>带权路径长度 = SUM（边长度 * 叶节点权重）<br>在前缀编码中，叶节点权重为字符出现次数，树的带权路径长度等于编码的总长度。</p><h5 id="满足WPL最小的树的性质"><a href="#满足WPL最小的树的性质" class="headerlink" title="满足WPL最小的树的性质"></a>满足WPL最小的树的性质</h5><ol><li>所有结点的度数必不为1</li><li>一定存在一个最优解（WPL最小树），使得权最小的两个点互为兄弟</li><li>权值最小的点一定在最下边<h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><h4 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h4>从下往上构建，每次选择权重最小的两个结点作为兄弟节点，根节点的权重为两个结点的权重和，不断迭代，即可构建Huffman树。<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3>Huffman可以应用于每次合并两个、然后合并代价为线性的问题，例如合并果子。<br><a href="https://www.acwing.com/problem/content/150/">148. 合并果子 - AcWing题库</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += a + b;</span><br><span class="line">        heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>#知识点 堆实现<br>priority_queue 默认是大根堆，优先向外弹出最大值<br><code>priority_queue&lt;int&gt; q</code><br><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; b;</code> // 小根堆，优先弹出最小值<br><a href="https://www.acwing.com/problem/content/151/">149. 荷马史诗 - AcWing题库</a><br>总共需要合并次数m满足，如果恰好能够合并完：<br>(k - 1)m + k = n 即 (k - 1)(m + 1) = n -1<br>#注意 如何处理n-1不能被k-1整除的问题？<br>因为，数的编码要尽可能地短，所以如果不处理n-1不能被k-1整除的问题直接从下向上进行合并，最后一次合并时数的个数小于k，这会导致结果不是最优解。此时合并次数与数的个数关系：<br>(k - 1)(m + 1) = n - 1 + d<br>d = (k - 1) - (n - 1) % (k - 1)<br>解决方案：不足k-1的整数倍的部分<strong>用权值为0的数补齐</strong>，这样既不影响最后结果，也能实现最优解。<blockquote><p>二进制不需要考虑不能被整除问题，因为最后结果为0或1个数不用再合并。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, <span class="keyword">int</span>&gt; PLI;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;PLI, vector&lt;PLI&gt;, greater&lt;PLI&gt;&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL w;</span><br><span class="line">        cin &gt;&gt; w;</span><br><span class="line">        head.<span class="built_in">push</span>(&#123;w, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((n - <span class="number">1</span>) % (k - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = k - <span class="number">1</span> - (n - <span class="number">1</span>) % (k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r -- )</span><br><span class="line">        &#123;</span><br><span class="line">            head.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LL s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            PLI wc = head.<span class="built_in">top</span>(); </span><br><span class="line">            head.<span class="built_in">pop</span>();</span><br><span class="line">            s += wc.first;</span><br><span class="line">            <span class="keyword">if</span>(wc.second &gt; dep)</span><br><span class="line">                dep = wc.second;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += s;</span><br><span class="line">        head.<span class="built_in">push</span>(&#123;s, dep + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    PLI wc = head.<span class="built_in">top</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n%d&quot;</span>, sum, wc.second);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2>2012-41、2013-4、2014-6、2015-3、2017-6、2018-5、2019-3、2020-42<br>#知识点 归并算法的最坏情况复杂度为：n + m - 1    其中n，m分别为两个已经排好序的数组的长度。<h3 id="2013-4"><a href="#2013-4" class="headerlink" title="2013-4"></a>2013-4</h3>题目：已知三叉树T中6个叶节点的权分别是2、3、4、5、6、7，T的带权（外部）路径长度最小是<br>46<br>#注意 注意题目要求：<strong>三叉树</strong><br>Huffman编码对于k叉树进行时，如果(<strong>k-1|n - 1</strong>)不成立，需要先补零使他成立！<h3 id="2020-42"><a href="#2020-42" class="headerlink" title="2020-42"></a>2020-42</h3>#知识点 如何判定某个字符集的0/1不等长编码是否具有前缀特性？<br>采用二叉树/哈夫曼树保存其不等长编码，只需要判断<strong>存储有字符信息的节点是否全部为叶节点</strong>即可。<br>若存储有某个字符信息的节点非叶节点，即有子节点，那么它的0/1编码一定是它孩子节点0/1编码的前缀，违反了前缀特性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-05二叉排序树、平衡树、表达式树</title>
      <link href="2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
      <url>2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="二叉搜索树（二叉排序树）BST"><a href="#二叉搜索树（二叉排序树）BST" class="headerlink" title="二叉搜索树（二叉排序树）BST"></a>二叉搜索树（二叉排序树）BST</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>中序遍历有序（一般是从小到大排序）的二叉树</strong>为二叉排序树。<br>递归定义：若左子树非空，则左子树的节点都小于根节点，若右子树非空，则右子树的节点都大于根节点，左右子树同样如此。</p><span id="more"></span><blockquote><p>对于节点值相等的情况，可以存到左子树，也可以存到右子树，也可以在节点加一个计数器。笔试题目一般都是严格大于或小于，不考虑等于。</p></blockquote><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>二叉排序树的插入、删除、查找的时间复杂度都是**O(h)**，h为树的高度。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>每次插入，必然插入到叶节点上。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol><li>如果是叶节点，直接删除</li><li>如果是非叶节点，且只有一个孩子，直接用这个孩子的根节点替换掉该节点</li><li>如果是非叶节点，且有两个孩子，直接用左子树的最大值（或右子树的最小值）覆盖这个结点的值，然后删除左子树的最大值（或右子树的最小值）对应结点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left, *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> _val): <span class="built_in">val</span>(_val), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;*root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TreeNode* &amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;val) <span class="built_in">insert</span>(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(root-&gt;right, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(TreeNode* &amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;val) <span class="built_in">remove</span>(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val) <span class="built_in">remove</span>(root-&gt;right, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;right) root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;right) p = p-&gt;right;</span><br><span class="line">            root-&gt;val = p-&gt;val;</span><br><span class="line">            <span class="built_in">remove</span>(root-&gt;left, p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pre</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt;= x) <span class="keyword">return</span> <span class="built_in">get_pre</span>(root-&gt;left, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(root-&gt;val, <span class="built_in">get_pre</span>(root-&gt;right, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_suc</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt;= x) <span class="keyword">return</span> <span class="built_in">get_suc</span>(root-&gt;right, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(root-&gt;val, <span class="built_in">get_suc</span>(root-&gt;left, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t, x;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">insert</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) <span class="built_in">remove</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">3</span>) cout &lt;&lt; <span class="built_in">get_pre</span>(root, x) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">get_suc</span>(root, x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>满足如下条件的树：</p><ol><li>是一个二叉搜索树</li><li>每个节点的左子树和右子树的高度差最多为1<br>平衡因子：一个结点的左子树的高度减去右子树的高度，可取值为-1、0、1三种值<br>平衡树的高度h = O(log<sub>2</sub>n)<br>所以由于二叉搜索树的操作时间复杂度为O(h)，所以平衡树的操作时间复杂度O(logn)<h3 id="平衡操作"><a href="#平衡操作" class="headerlink" title="平衡操作"></a>平衡操作</h3>左旋操作、右旋操作<strong>不改变中序遍历</strong>，只会改变两边树的高度。<br><img src="/2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-image-20220321190230679.png" alt="左旋操作、右旋操作"><br>中序遍历：DBEAC<br>平衡树：每次插入或者删除一个结点以后，只会改变一个结点的信息。<br>平衡操作：<strong>从下往上</strong>找，找到最小的一个不平衡的子树。会有四种情况：<br><img src="/2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-image-20220321205648773.png" alt="最小不平衡子树"><h2 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h2>表达式树，叶节点为变量或值，分支结点/根节点是运算符。<br>前缀表达式 对应 表达式树的前序遍历<br>中缀表达式 对应 表示式树的中序遍历<br>后缀表达式 对应 表达式树的后序遍历<br><a href="https://www.acwing.com/problem/content/description/3768/">3765. 表达式树 - AcWing题库</a><br>时间复杂度：O(n<sup>2</sup>)<blockquote><p>原因：C++中return string语句会将string进行复制一遍，所以复杂度为1+2+3+…+n，所以复杂度O(n<sup>2</sup>)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     string val；</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">expressionTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left) + root-&gt;val + <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">dfs</span>(root -&gt; left) + root -&gt; val + <span class="built_in">dfs</span>(root -&gt; right) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>优化方案：不进行return<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     string val；</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="function">string <span class="title">expressionTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left), ans += root-&gt;val, <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) ans += root-&gt;val;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(root -&gt; left), ans += root -&gt; val, <span class="built_in">dfs</span>(root -&gt; right);</span><br><span class="line">            ans += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>#知识点 段错误<br>段错误也有可能是由于本来有返回值的，然后忘记return了，在外部调用这个函数并访问了返回值导致。所以要注意是否忘记写返回值了！<h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2>2011-7、2012-4、2013-3(PDF中的分析有误，以上课讲解为准)、2013-6、2015-4、2018-6、2019-4、2019-6、2020-5、2017-41<br>#注意<br>注意题目中所问是什么结点，分支节点、叶节点还是其他。<br>度为零的结点称为叶子(Leaf)或终端结点。 度不为零的结点称分支结点或非终端结点。<br>如果该二叉树只有根节点，那么显然不是分支结点，如果不是只有根节点，那就是分支结点。<h3 id="2012-4"><a href="#2012-4" class="headerlink" title="2012-4"></a>2012-4</h3>题目：若平衡二叉树的高度为6，且所有非叶节点的平衡因子均为1，则该平衡二叉树的结点总数为<br>20<br>解：题目本质为递推<br>f(h) 表示高度为h且所有非叶节点的平衡因子均为1的平衡二叉树的结点总数。则左子树为f(h-1)，右子树为f(h-2)，所以f(h) = f(h-1) + f(h-2) + 1<br>易得：f(0) = 0，f(1) = 1<h3 id="2019-6"><a href="#2019-6" class="headerlink" title="2019-6"></a>2019-6</h3>题目：用有向无环图描述表达式(x+y)*((x+y)/x)，需要的顶点个数至少是<br>5<br><img src="/2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-image-20220321212226899.png" alt="2019-6"><br>#知识点 有向无环图<br>有向无环图指的是一个无回路的有向图。如果有一个非有向无环图，且A点出发向B经C可回到A，形成一个环。<strong>将从C到A的边方向改为从A到C，则变成有向无环图</strong>。有向无环图的生成树个数等于入度非零的节点的入度积。<br><img src="/2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-image-20220321211304404.png" alt="有向无环图"><h3 id="注意题目差异"><a href="#注意题目差异" class="headerlink" title="注意题目差异"></a>注意题目差异</h3><img src="/2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-image-20220321221206809.png" alt="二叉排序树"><br><img src="/2022/03/21/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_05%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_5%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%B9%B3%E8%A1%A1%E6%A0%91_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91-image-20220321221220489.png" alt="平衡树"><br>4这道题答案：A<br>解：T1删除过结点后，形成T2时可能会进行左旋或右旋操作，所以再加回来v后T3可能和T1不同。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研-计算机网络02物理层</title>
      <link href="2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-物理层基础概念"><a href="#2-1-物理层基础概念" class="headerlink" title="2.1 物理层基础概念"></a>2.1 物理层基础概念</h1><h2 id="物理层接口特性"><a href="#物理层接口特性" class="headerlink" title="物理层接口特性"></a>物理层接口特性</h2><p>物理层解决的是如何在连接各种计算机的传输媒体上==传输数据比特流==，而不是指具体的传输媒体。</p><blockquote><p>传输介质不属于物理层！</p></blockquote><p>物理层主要任务：确定与传输媒体==接口==有关的一些特性。 ==定义标准==</p><span id="more"></span><h3 id="机械特性"><a href="#机械特性" class="headerlink" title="机械特性"></a>机械特性</h3><p>物理连接的特性，规定物理连接的规格、接口形状、引线数量、引脚数量和排列情况</p><h3 id="电气接口"><a href="#电气接口" class="headerlink" title="电气接口"></a>电气接口</h3><p>规定传输二进制位时，线路上信号的电压范围、传输速率和距离限制等</p><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>某一电平表示何种意义、接口部件信号线的用途</p><h3 id="规程特性"><a href="#规程特性" class="headerlink" title="规程特性"></a>规程特性</h3><p>过程特性，线路的工作规程和时序关系</p><h1 id="2-2-数据通信基础知识"><a href="#2-2-数据通信基础知识" class="headerlink" title="2.2 数据通信基础知识"></a>2.2 数据通信基础知识</h1><p><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317194825276.png" alt="典型的数据通信模型"><br>数据首先翻译成数字信号，再通过调制解调器转换成模拟信号，（这样才能通过广域网上的模拟信道进行传输），之后再通过调制解调器转为数据信号，传给计算机转为人类可以理解的数据。<br>通信的目的是传送<strong>消息</strong>。<br><strong>数据Data</strong>：传送信息的实体，通常是有意义的符号序列。<br><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的存在形式。</p><ul><li>数字信号/离散信号</li><li>模拟信号/连续信号<br>数据通信指在不同计算机之间传输表示信息的二进制数0、1序列的过程。</li><li><strong>信源</strong> <strong>信宿</strong></li><li><strong>信道</strong>：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一个发送信道和一个接收信道。<strong>信道具有方向性</strong><br><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317200159770.png" alt="信道"><h2 id="数据通信系统要考虑的3个问题"><a href="#数据通信系统要考虑的3个问题" class="headerlink" title="数据通信系统要考虑的3个问题"></a>数据通信系统要考虑的3个问题</h2><h3 id="三种数据通信方式"><a href="#三种数据通信方式" class="headerlink" title="三种数据通信方式"></a>三种数据通信方式</h3>单工：仅需要<strong>一条</strong>信道<br>半双工：需要<strong>两条</strong>信道<br>双工：需要<strong>两条</strong>信道<h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3>串行传输</li><li>将表示一个字符的8位二进制数按从低位到高位顺序依此发送</li><li>速度慢、费用低、适合远距离传输<br>并行传输</li><li>将表示一个字符的8位二进制同时通过8条信道发送</li><li>数据快、费用高、适合近距离传输<ul><li>例如用于计算机内部数据传输<h3 id="实现同步的传输-通信方式"><a href="#实现同步的传输-通信方式" class="headerlink" title="实现同步的传输/通信方式"></a>实现同步的传输/通信方式</h3>在计算机网络中，定时的因素称为位同步。同步是要接收方按照发送方发送的每个位的起止时刻和速率来接收数据，否则会产生误差。通常可以采用同步或异步的传输方式对位进行同步处理。<br>同步传输</li></ul></li><li>在同步传输的模式下，数据传输是以一个<strong>数据区块</strong>为单位，因此同步传输又称为区块传输。传输数据时需先送出1个或多个同步字符SYN，再传输整批的数据。<br>异步传输</li><li>异步传输将比特分为小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任意时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位。<ul><li>例如计算机键盘信号传输<blockquote><p>1.对象不同 异步传输是面向字符的传输,而同步传输是面向比特的传输。<br>2.传输单位不同 异步传输的单位是字符,而同步传输的单位是桢。<br>3.过程不同 异步传输通过字符起止的开始和停止码抓住再同步的机会,而同步传输则是以数据中抽取同步信息。<br>4.公共时钟不同 同步传输有公共时钟,总线上的所有设备按统一的传输周期进行信息传输,发送方和接收方通信双方是否按约定好的时序进行联络。 异步传输没有公共时钟,没有固定的传输周期,采用应答方式通信。</p></blockquote></li></ul></li></ul><h2 id="数据传输速率的术语"><a href="#数据传输速率的术语" class="headerlink" title="数据传输速率的术语"></a>数据传输速率的术语</h2><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><p><strong>码元</strong>是指一个<strong>固定时长</strong>的<strong>信号波形</strong>（数字脉冲）。时长称为码元宽度。码元离散状态数为M（M &gt; 2）时，码元称为M进制码元。<br>1码元可以携带多个比特的信息量。</p><h3 id="数字通信系统数据传输速率的两种表达形式"><a href="#数字通信系统数据传输速率的两种表达形式" class="headerlink" title="数字通信系统数据传输速率的两种表达形式"></a>数字通信系统数据传输速率的两种表达形式</h3><p>速率也叫数据率，是指数据的<strong>传输速率</strong>，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>来表示。<br><strong>码元传输速率</strong><br>单位时间传输的码元个数（或称为脉冲个数或信号变化次数），单位为<strong>波特</strong>（Baud）</p><blockquote><p>注意，连续两个低电平（高电平）也叫信号变化了</p></blockquote><p>数字信号有进制之分，但是<strong>码元速率与进制数无关，只与码元长度T有关</strong>。<br>$$<br>R_B = \frac{1}{T}(B)<br>$$<br><strong>信息传输速率</strong><br>别名信息速率、比特率等，表示单位时间传输的<strong>二进制码元个数</strong>（即比特数），单位比特/秒（b/s）</p><blockquote><p>关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M * n bit/s</p></blockquote><p><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317205246254.png" alt="数字通信系统数据传输速率的两种表达形式思考题1"><br><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317205435523.png" alt="数字通信系统数据传输速率的两种表达形式思考题2"></p><h3 id="带宽-Bandwidth"><a href="#带宽-Bandwidth" class="headerlink" title="带宽 Bandwidth"></a>带宽 Bandwidth</h3><p><strong>模拟信号系统</strong>中，信号最高频率和最低频率之间的差值就是系统的通频带宽，单位是<strong>赫兹（Hz）</strong>。<br><strong>数字设备</strong>中，单位时间内从网络中某一点到另一点所能通过的“<strong>最高数据率</strong>”/单位时间内通过链路的数量，体现了最高传输能力。单位<strong>比特每秒（bps）</strong>。</p><h1 id="2-3-奈式准则和香农定理"><a href="#2-3-奈式准则和香农定理" class="headerlink" title="2.3 奈式准则和香农定理"></a>2.3 奈式准则和香农定理</h1><h2 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h2><p>信号在现实信道中因为带宽受限、有噪声、干扰等而发生波形扭曲等。失真过大则无法识别实际波形。<br>影响失真程度的因素：</p><ol><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量<h3 id="失真的一种现象–码间串扰"><a href="#失真的一种现象–码间串扰" class="headerlink" title="失真的一种现象–码间串扰"></a>失真的一种现象–码间串扰</h3></li></ol><p><strong>信道带宽</strong>是信道能通过的最高频率和最低频率之差。<br>码间串扰：<strong>接收端</strong>收到的信号波形<strong>失去了码元之间清晰界限</strong>的现象。</p><blockquote><p>频率过低的无法通过信道原因：震动过低，在信道传输的时候非常容易衰减，最后无法辨别波形。<br>频率过高的无法通过信道原因：震动过快，接收端无法辨别波形的界限。码间串扰</p></blockquote><p>码元传输频率对应的是信号传输频率。</p><h2 id="奈式准则（奈奎斯特定理）"><a href="#奈式准则（奈奎斯特定理）" class="headerlink" title="奈式准则（奈奎斯特定理）"></a>奈式准则（奈奎斯特定理）</h2><p>为了解决码间串扰问题，提出的奈式准则。<br><strong>奈式准则</strong>：在理想（无噪声）低通（带宽受限，低通-低于最高频率可以通过信道）条件下，为了避免码间串扰，极限<strong>码元传输速率</strong>为2W Baud，W是信道带宽，单位是Hz。</p><blockquote><p>注意，带宽的单位一般是b/s，只有在奈式准则和香农定理中采用Hz作为单位。</p></blockquote><p>常见题型：求解理想低通信道下的极限数据传输率 = 2Wlog<sub>2</sub>V (b/s)<br>W指带宽（Hz），V指几种码元/码元的离散电平数目</p><ol><li><strong>在任何信道中，码元传输的速率是有上限的</strong>。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li><li>信道的<strong>频带越宽</strong>（即能通过的信号高频分量越多)，就可以用<strong>更高的速率</strong>进行码元的有效传输。</li><li><strong>奈氏准则</strong>给出了码元传输速率的限制，但并<strong>没有对信息传输速率给出限制。</strong></li><li>由于码元的传输速率受奈氏准则的制约，所以**要提高==数据的传输速率==**，就必须设法使每个码元能携带更多个比特的信息量，这就需要==<strong>采用多元制的调制方法</strong>==。或者通过提高==<strong>带宽</strong>==。<br><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317213340793.png" alt="奈式准则题1"><br><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317213533423.png" alt="奈式准则题1解"><h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2>奈式准则只提供了码元传输速率的最高限制，没有提出数据传输率的限制，而香农定理提出这两个的最高值，还考虑了信道中实际存在的噪声干扰。<br>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，<strong>信噪比</strong>就很重要。<br>信噪比 = 信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即：<br>$$<br>\text{信噪比}(dB) = 10\log_{10}(S/N)<br>$$<br>公式前后数值等价，前者有单位dB，后者没有单位</li></ol><p><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的<strong>数据传输速率</strong>有上限值。<br>$$<br>\text{信道的极限数据传播速率} = W\log_2(1+S/N)(b/s)<br>$$<br>信噪比S/N，S是信道所传信号的平均功率，N是信道内的高斯噪声功率</p><blockquote><p>注意解题时题目给的信噪比是否有单位dB，如果有要记得转换</p></blockquote><ol><li>信道的==<strong>带宽</strong>==或信道中的==<strong>信噪比</strong>==越大，则信息的==极限传输速率==就<strong>越高</strong>。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</li><li>只要信息的传输速率低于信道的极限传输速率，就<strong>一定</strong>能找到某种方法来<strong>实现无差错的传输</strong>。</li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li><li>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能)，那么信道的极限信息传输速率也就没有上限。</li></ol><p><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317215125830.png" alt="香农定理题1"><br><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317215305315.png" alt="香农定理题1解"></p><blockquote><p>如果题目中既给了信噪比，又给了码元对应的比特V，则两个公式都要计算一下，然后求最小值。<br><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317220140106.png" alt="题2"></p></blockquote><h1 id="2-5-编码与调制"><a href="#2-5-编码与调制" class="headerlink" title="2.5 编码与调制"></a>2.5 编码与调制</h1><p><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220329211319383.png"><br>数据：运送消息的实体<br>信号：数据的电磁表现<br>基带信号：<strong>信源发出</strong>的原始电信号。基带信号分为数字基带信号和模拟基带信号。<br>信道：信号通过信道传输。信道可分为数字信道和模拟信道。<br>编码：不改变信号的性质，仅对数字基带信号的波形进行变换，称为编码。以太网采用曼彻斯特编码、4B/5B、8B/10B等编码。<br>调制：把数字频段搬移到较高的范围，并转换为模拟信号，称为调制。</p><h2 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h2><p>信道：信号的传输媒介。<br>信道上传输的信号可以分为模拟信号和数字信号，也可以划分为基带信号和宽带信号。<br><strong>基带信号</strong><br>将数字信号1和0直接用两种不同的电压表示，然后再送到==数字信道==上去传输（基带传输）。</p><blockquote><p>==来自信源==的信号，像计算机输出的代表各种文字和图像文件的数据信号都属于基带信号。基带信号就是<strong>直接表达了要传输的信息的信号</strong>，比如我们说话的声波就是基带信号。<br>基带信号可以是数字信号，也可以是模拟信号，但是在计算机中一般指数字信号。</p></blockquote><p><strong>宽带信号</strong><br>将基带信号进行<strong>调制</strong>后形成的频分复用模拟信号，再传送到==模拟信道==上去传输（宽带传输）。<br>把基带信号进行<strong>载波调制</strong>后，把信号的<strong>频率范围</strong>搬移到<strong>较高的频段</strong>以便于在信道上传输，因为仅在一段频率范围内信号能够通过信道，较低频率信号衰减过快，不能在信道上传播。</p><ul><li>在传输距离较近时，计算机网络采用<strong>基带传输</strong>方式（近距离衰减小，从而信号内容不易发生改变）</li><li>在传输距离较远时，计算机网络采用<strong>宽带传输</strong>方式（远距离衰减大，即使信号变化大也能最后过滤出来基带信号）<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2></li><li><em>信息</em>*<br>是数据的内容和解释。  </li><li><em>信号*</em><br>是数据的<strong>电子或电磁编码</strong>。对应于模拟数据和数字数据,信号也可分为模拟信号和数字信号。<br>模拟信号是随时间连续变化的电流、电压或电磁波,可以利用其某个参量(如幅度、频率或相位等)来表示要传输的数据;数字信号则是一系列离散的电脉冲,可以利用其某一瞬间的状态来表示要传输的数据  </li><li><em>数据</em>*<br>可定义为有意义的实体,它涉及到事物的存在形式。数据可分为模拟数据和数字数据两大类。<br>模拟数据是在某个区间内连续变化的植,例如声音和视频都是幅度连续变化的波形,又如温度和压力也都是连续变化的值;数字数据是离散的值,例如文本信息和整数。<h3 id="数据与信号之间转换"><a href="#数据与信号之间转换" class="headerlink" title="数据与信号之间转换"></a>数据与信号之间转换</h3><img src="/2022/03/17/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C02%E7%89%A9%E7%90%86%E5%B1%82-image-20220317222623012.png" alt="数据与信号之间转换"><blockquote><p>放大器调制器，为了将模拟数据从低频调制到高频，防止传输过程中由于噪声等影响而失真。</p></blockquote><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h4><h5 id="非归零编码【NRZ】"><a href="#非归零编码【NRZ】" class="headerlink" title="非归零编码【NRZ】"></a>非归零编码【NRZ】</h5>高1低0，不用归零</li></ul><ol><li>编码易实现</li><li>没有检错功能</li><li>无法判断码元的开始和结束，以至于收发双方<strong>难以保持同步</strong><h5 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h5>将一个码元分为两个相等的间隔，前低后高为1，前高后低为0，也可相反。<br>每个码元中间出现一次电平跳变，跳变可以作为时钟信号，也可作为数据信号。<br>但是他所占的频带宽度是原始的基带宽度的两倍，每个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2。</li></ol><p><strong>传统以太网10Mb/s就是采用的曼彻斯特编码。</strong><br>10BaseT：</p><ul><li>10表示传输速率10Mb/s</li><li>Base表示基带传输</li><li>T表示双绞线<h5 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h5>中间跳变仅表示时钟。<br>码元开始处电平是否发生变化表示数据。变化表示0，不变化表示1。<br>差分曼彻斯特编码比曼彻斯特编码变化少，更适合较高的传输速率。<h5 id="归零编码【RZ】"><a href="#归零编码【RZ】" class="headerlink" title="归零编码【RZ】"></a>归零编码【RZ】</h5>高1低0，同时信号电平在一个码元之内都要恢复到零。接收方根据跳变调整时钟基准，实现自同步机制。</li></ul><ol><li>信号更长时间在低电平状态</li><li>归零需要占用一部分带宽，因此传输速率受到限制。<h5 id="反向不归零编码【NRZI】"><a href="#反向不归零编码【NRZI】" class="headerlink" title="反向不归零编码【NRZI】"></a>反向不归零编码【NRZI】</h5>码元开始处信号电平翻转表示0，信号电平不变表示1</li><li>可以同步，但是对于全1的信号不好同步<blockquote><p>USB 2.0通信的编码方式</p></blockquote><h5 id="4B-5B编码"><a href="#4B-5B编码" class="headerlink" title="4B/5B编码"></a>4B/5B编码</h5></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 408 </tag>
            
            <tag> 王道 </tag>
            
            <tag> 湖科大 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-19推公式、最短路、思维题</title>
      <link href="2022/03/17/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_19%E6%8E%A8%E5%85%AC%E5%BC%8F_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E6%80%9D%E7%BB%B4%E9%A2%98/"/>
      <url>2022/03/17/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_19%E6%8E%A8%E5%85%AC%E5%BC%8F_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E6%80%9D%E7%BB%B4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h2><p>本质是找规律问题，注意题目中所给的数据变化规律，比如坐标轴上的y与x之间映射关系、数据变化是否符合等比数列、等差数列等等。</p><span id="more"></span><p>#知识点<br>等比数列求和公式<br>$$<br>S_n = na_1,(q = 1)<br>$$<br>$$<br>S_n = \frac{a_1 \times (1-q^n)}{1-q}=\frac{a_1-a_nq}{1-q},(q \neq 1)<br>$$<br>等差数列求和公式<br>$$<br>s_n = a_0n + \frac{d}{2}(n+n^2)=\frac{n(a_1+a_n)}{2}<br>$$</p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p><img src="/2022/03/17/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_19%E6%8E%A8%E5%85%AC%E5%BC%8F_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E6%80%9D%E7%BB%B4%E9%A2%98/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_19%E6%8E%A8%E5%85%AC%E5%BC%8F_%E6%9C%80%E7%9F%AD%E8%B7%AF_%E6%80%9D%E7%BB%B4%E9%A2%98-image-20220318202526353.png" alt="最短路"></p><blockquote><p>Floyd算法代码比较好实现，所以如果单源最短路问题，但是数据范围较小，也可以采用Floyd算法。<br>Dijkstra算法原理是贪心算法。注意朴素Dijkstra算法不一定比堆优化版的好，当图是稠密图时采用朴素Dijkstra算法，如果是稀疏图才采用堆优化版Dijkstra算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-18矩阵、计算几何和前缀和</title>
      <link href="2022/03/17/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_18%E7%9F%A9%E9%98%B5_%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95_%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>2022/03/17/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_18%E7%9F%A9%E9%98%B5_%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95_%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p><a href="https://www.acwing.com/problem/content/3530/">3527. 旋转矩阵 - AcWing题库</a><br>#技巧 判断矩阵是否相同<br><code>vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(n));</code><br>含义：创建一个n*n空的数组，之后可以直接用a[i][j]进行访问和赋值。<br>利用vector自带的判断是否相等的方法<code>==</code>来判断矩阵是否相同：<code>if(a == b) &#123;...&#125;</code></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">rotate</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> res = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, k = n - <span class="number">1</span>; j &lt; n; j ++, k -- )</span><br><span class="line">            res[i][j] = a[k][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">a</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">auto</span> b = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; b[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i * <span class="number">90</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">rotate</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h3><p><a href="https://www.acwing.com/problem/content/3537/">3534. 矩阵幂 - AcWing题库</a><br>#知识点 C++不支持直接返回完整的数组<br>但是可以通过指定不带索引的数组名来返回一个指向数组的指针（注意，数组需要声明为static类型或者是通过new创建的堆上的数组）。<br>也可以通过传递数组名作为函数参数，然后函数中将需要返回的数组内容存储到这个数组参数中。（如下文代码）<br>另外可以使用STL的vector创建数组，然后进行返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过传入数组C的指针来实现函数变相返回数组</span></span><br><span class="line"><span class="comment">// C = A * B  注意这个时候本质都是指针，sizeof时返回的是指针的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> c[][N], <span class="keyword">int</span> a[][N], <span class="keyword">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tmp[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp); <span class="comment">// 矩阵全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line">                tmp[i][j] += a[i][k] * b[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(c, tmp, <span class="keyword">sizeof</span> tmp); <span class="comment">// 这里必须是sizeof(tmp)返回的才是数组的大小，而sizeof(c)返回的将是指针的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- ) <span class="built_in">mul</span>(res, res, w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>#知识点 memset、memcpy用法<br><strong>memcpy</strong><br>memcpy用来做内存拷贝，可以用它拷贝任何数据类型的对象，可以指定拷贝的数据长度。<br><code>void *memcpy(void *dest, const void *src, size_t n);</code><br>含义：从源src所指向的内存空间地址的起始位置开始拷贝n个<strong>字节</strong>到目标dest所指的内存地址的起始位置。<br><strong>memset</strong><br>memset的作用是对一段内存空间每个<strong>字节</strong>全部设置为某个值，常用于内存空间的初始化。<br><code>void *memset(void *s, int c, size_t n);</code><br>含义：把已开辟的内存空间s的前n个<strong>字节</strong>设置为c。</p><h3 id="C翻转"><a href="#C翻转" class="headerlink" title="C翻转"></a>C翻转</h3><p><a href="https://www.acwing.com/problem/content/3538/">3535. C翻转 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">m1</span>(N, vector&lt;<span class="keyword">int</span>&gt;(N));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++ j)</span><br><span class="line">            cin &gt;&gt; m1[i][j];</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> m2 = m1;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>) <span class="comment">// 先考虑不进行设置x和y的情况，之后再将偏移量添加进来</span></span><br><span class="line">    &#123; <span class="comment">// 顺时针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b; ++ j)</span><br><span class="line">                m2[x - <span class="number">1</span> + j][y - <span class="number">1</span> +  b - i - <span class="number">1</span>] = m1[x - <span class="number">1</span> + i][y - <span class="number">1</span> + j];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>)</span><br><span class="line">    &#123; <span class="comment">// 逆时针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b; ++ j)</span><br><span class="line">                m2[x - <span class="number">1</span> + b - j - <span class="number">1</span>][y - <span class="number">1</span> + i] = m1[x - <span class="number">1</span> + i][y - <span class="number">1</span> +  j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++ j)</span><br><span class="line">            cout &lt;&lt; m2[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><p>#知识点<br>如何求PI值：<code>const double PI = acos(-1);</code><br>另外注意，如果除法是两个整数在运算，那么返回值会是截取小数位的整数，所以如果要获得精确的值，要把两个整数中一个转换为小数。例如<code>4/3</code>写成<code>4.0/3</code>。<br>#知识点<br>注意：类的定义后面要加分号<code>;</code><br>类构造函数可以写成<code>ClassName(int _x, int _y):x(_x), y(_y)&#123;&#125;</code><br>#知识点 浮点数是否相等的判断<br>因为浮点数存储有误差存在，所以一般比较时只需要两个数差值绝对值小于ε即可，一般ε取$10^{-8}$。例如比较a和b的差值可以写成：<br>$$<br>|a - b | &lt; 10^{-8}<br>$$<br>代码：<code>fabs(a - b) &lt; 1e-8</code></p><blockquote><p>fabs()返回<strong>浮点数</strong>的绝对值，abs()返回<strong>整数</strong>的绝对值。</p></blockquote><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="最长平衡串"><a href="#最长平衡串" class="headerlink" title="最长平衡串"></a>最长平衡串</h3><p>#好题<br><a href="https://www.acwing.com/problem/content/description/3556/">3553. 最长平衡串 - AcWing题库</a><br>分析：用$a_i$和$b_i$分别表示前i个字符中1的个数和0的个数，子串$s_{ij}$表示第i到第j个字符构成的串，如果$s_{ij}$为平衡串，则$a_j - a_{i-1} = b_j - b_{i-1}$，即$a_{i-1} - b_{i-1} = a_j - b_j$，令$t_i = a_i - b_i$，则$s_{ij}$为平衡串等价于$t_{i-1} = t_j$成立。<br><strong>注意特殊情况，特别是边界情况，例如本题目中<code>m[0] = 0</code>的情况不要忘记！</strong></p><blockquote><p>注意：子串不一定从开头算起，也可能是中间的子串</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m; <span class="comment">// 存储s[i]值第一次出现时的下标，求最大子串时直接查表找到第一次出现的位置相减即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">m[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 这个别忘记了！ 子串为空时，f[0] = 0，且下标为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, len = s.<span class="built_in">size</span>(); i &lt; len; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">f[i] = f[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!m.<span class="built_in">count</span>(f[i]))</span><br><span class="line">&#123;</span><br><span class="line">m[f[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ml = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; -- j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tem = j - m[f[j]]; <span class="comment">// 不用加1</span></span><br><span class="line"><span class="keyword">if</span>(tem &gt; ml)</span><br><span class="line">ml = tem;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ml &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研-计算机网络01概论</title>
      <link href="2022/03/16/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01%E6%A6%82%E8%AE%BA/"/>
      <url>2022/03/16/%E8%80%83%E7%A0%94_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 408 </tag>
            
            <tag> 王道 </tag>
            
            <tag> 湖科大 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-16高精度和因式分解</title>
      <link href="2022/03/16/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_16%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%92%8C%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/"/>
      <url>2022/03/16/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_16%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%92%8C%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="N的阶乘"><a href="#N的阶乘" class="headerlink" title="N的阶乘"></a>N的阶乘</h4><p><a href="https://www.acwing.com/problem/content/3392/">3389. N 的阶乘 - AcWing题库</a><br>观察题目的数值范围，很明显long long类型的变量也不能够存储下，所以需要用string来进行存储，即大数乘法。</p><blockquote><p>下面这种解法虽然正确，但是由于计算量大所以会超时，因此需要优化。</p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这道题关键是 long long 也会溢出，所以要考虑用string存储</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大数乘法</span></span><br><span class="line"><span class="function">string <span class="title">times</span><span class="params">(string s, <span class="keyword">int</span> it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = s.<span class="built_in">size</span>(); i &lt; len; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (s[i] - <span class="string">&#x27;0&#x27;</span>) * it + r;</span><br><span class="line">        res += <span class="built_in">to_string</span>(t % <span class="number">10</span>);</span><br><span class="line">        r = t / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后一个余数</span></span><br><span class="line">    <span class="keyword">while</span>(r)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">to_string</span>(r % <span class="number">10</span>);</span><br><span class="line">        r = r / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">jc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="comment">// 0阶乘</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    string res = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        res = <span class="built_in">times</span>(res, i);</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 翻转字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">jc</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由题目，n的范围是1-1000，而根据阶乘的性质，n的阶乘是n-1的阶乘再乘以n。如果多次输入n并分开计算n的阶乘，每次计算&gt;m的数的阶乘的时候，都需要再次计算m的阶乘，所以<strong>考虑一次计算完所有1-1000数据的阶乘并存储到f[N]中</strong>，然后求n的阶乘即返回f[n]，这样只需要计算一次1000!即可，而不用重复计算。<br>#技巧 预处理“打表”<br>如果输入是多种情况，而这些情况的结果互相关联，比如大数由小数经过某些计算获得，那么可以通过直接计算一遍所给数据最大值的情况，同时将计算过程中的小数对应输出结果进行存储，即构成一个表。那么实际输入获得输出时，只需要查表即可，避免了重复计算而超时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这道题关键是 long long 也会溢出，所以要考虑用string存储</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; F;  <span class="comment">// 存储已经计算好的阶乘值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大数乘法</span></span><br><span class="line"><span class="function">string <span class="title">times</span><span class="params">(string s, <span class="keyword">int</span> it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = s.<span class="built_in">size</span>(); i &lt; len; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (s[i] - <span class="string">&#x27;0&#x27;</span>) * it + r;</span><br><span class="line">        res += <span class="built_in">to_string</span>(t % <span class="number">10</span>);</span><br><span class="line">        r = t / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后一个余数</span></span><br><span class="line">    <span class="keyword">while</span>(r)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">to_string</span>(r % <span class="number">10</span>);</span><br><span class="line">        r = r / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    F.<span class="built_in">push_back</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">// 0! = 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i) <span class="comment">// 一次计算N阶乘，并将中间值（即小于N的阶乘数）存储起来</span></span><br><span class="line">        F.<span class="built_in">push_back</span>(<span class="built_in">times</span>(F[i - <span class="number">1</span>], i));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        string res;</span><br><span class="line">        res = F[n];</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h4><p><a href="https://www.acwing.com/problem/content/3451/">3448. 基本算术 - AcWing题库</a><br>#知识点<br>因为题目是英文输出，所以一定要注意输出时<strong>名词单复数的要求</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b, a != <span class="string">&quot;0&quot;</span> || b != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, i = <span class="number">0</span>, la = a.<span class="built_in">size</span>(), lb = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; la &amp;&amp; i &lt; lb; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = (a[i] - <span class="string">&#x27;0&#x27;</span>) + (b[i] - <span class="string">&#x27;0&#x27;</span>) + r;</span><br><span class="line">            r = s / <span class="number">10</span>;</span><br><span class="line">            cnt += r;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(; i &lt; la; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = (a[i] - <span class="string">&#x27;0&#x27;</span>) + r;</span><br><span class="line">            r = s / <span class="number">10</span>;</span><br><span class="line">            cnt += r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; lb; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = (b[i] - <span class="string">&#x27;0&#x27;</span>) + r;</span><br><span class="line">            r = s / <span class="number">10</span>;</span><br><span class="line">            cnt += r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r)</span><br><span class="line">        &#123;        </span><br><span class="line">            r = r / <span class="number">10</span>;</span><br><span class="line">            cnt += r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="comment">// 名词单复数的要求</span></span><br><span class="line">            cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; carry operation.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; carry operations.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No carry operation.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整数查询"><a href="#整数查询" class="headerlink" title="整数查询"></a>整数查询</h4><p><a href="https://www.acwing.com/problem/content/3456/">3453. 整数查询 - AcWing题库</a><br>#知识点 大数加法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; res, vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, lr = res.<span class="built_in">size</span>(), la = a.<span class="built_in">size</span>(), r = <span class="number">0</span>; i &lt; lr || i &lt; la || r; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; lr) r += res[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; la) r += a[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(r % <span class="number">10</span>);</span><br><span class="line">        r /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s, s != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            a.<span class="built_in">push_back</span>(s[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 注意，这里不要忘记 - &#x27;0&#x27;</span></span><br><span class="line">            </span><br><span class="line">        <span class="built_in">add</span>(res, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理前导零</span></span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">size</span>() &gt; <span class="number">1</span>&amp;&amp;!res.<span class="built_in">back</span>())</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="因式分解"><a href="#因式分解" class="headerlink" title="因式分解"></a>因式分解</h2><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="质因数的个数"><a href="#质因数的个数" class="headerlink" title="质因数的个数"></a>质因数的个数</h4><p><a href="https://www.acwing.com/problem/content/3383/">3380. 质因数的个数 - AcWing题库</a><br>质因数(或质因子)在数论里是指能整除给定正整数的质数。两个没有共同质因子的正整数 称为互质。因为 1 没有质因子,1 与任何正整数(包括 1 本身)都是互质。正整数的因数分 解可将正整数表示为一连串的质因子相乘, 质因子如重复可以指数表示。 根据算术基本定理, 任何正整数皆有独一无二的质因子分解式。只有一个质因子的正整数为质数。<br>#知识点<br>质因子分解的时候，n中最多包含一个大于$\sqrt{n}$的质因子。</p><blockquote><p>证明：如果n有两个质因子q和p，那么q*p *其他质因子 &gt; n显然不合理。</p></blockquote><p>同时，如果n没有小于等于$sqrt(n)$的质因子，那么他的质因子是他本身。<br>结论：1到n中的质数个数大概在$\frac{n}{\ln{n}}$个。<br>筛选质数的复杂度大概为O(n)<br>#好题 这个求解质因子的方法很好！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) <span class="comment">// 参与循环的i必然是一个质数，是n的质因子</span></span><br><span class="line">            &#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                ++ cnt; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>)  <span class="comment">// 得出n中大于i*i的那一个质因子（最多一个）</span></span><br><span class="line">            ++ cnt;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h4><p>约数，又称因数。整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为b的倍数，b称为a的约数。<br><a href="https://www.acwing.com/problem/content/3380/">3377. 约数的个数 - AcWing题库</a><br>解法一<br>直接遍历1到$\sqrt{n}$的数，看哪些数是n的因数，然后就加2。（因数除了i*i=n以外都是两两对应出现，所以加2）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j * j &lt;= x; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(!(x % j))</span><br><span class="line">            &#123;</span><br><span class="line">                cnt += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        j --;</span><br><span class="line">        <span class="keyword">if</span>(j * j == x) -- cnt;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二<br>#技巧<br>通过<strong>计算</strong>获得约数的个数。<br>已知数n，那么n可以被分解为k个质因子$p_i$的$m_i$次幂的和。<br>$$<br>n = p_1^{m_1}<em>p_2^{m_2}</em>…<em>p_k^{m_k}<br>$$<br>那么，n的约数个数为：$(m_1+1)</em>(m_2+1)<em>…</em>(m_k+1)$<br>因此问题转换为求解数n的质因子以及对应的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ c;</span><br><span class="line">                x /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt *= c + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>)</span><br><span class="line">            cnt *= <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阶乘末尾的零"><a href="#阶乘末尾的零" class="headerlink" title="阶乘末尾的零"></a>阶乘末尾的零</h4><p><a href="https://www.acwing.com/problem/content/3510/">3507. 阶乘的末尾0 - AcWing题库</a><br>$1 * 2 * … * n = 2^a  * 5^b * c$，则末尾零的个数为$\min{a, b}$<br>对于一个数的阶乘，5这个因子一定是每隔5个数就至少出现一次，即：<br><code>n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) * ... * n</code><br>即每隔<code>5</code>个数出现一个<code>5</code>，所以计算<code>n/5</code>（下取整）即可得到每隔5个数出现的5的个数。<br>然后继续观察发现，每隔<code>25</code>出现的是两个 <code>5</code>，所以除了每隔5个数算了一个 5，每隔25个数，还需要多算一个 5。也就是我们需要再加上 <code>n / 25</code> （下取整）个 5。<br>同理继续分析5<sup>3</sup>、5<sup>4</sup>、… 即可得到n!的因子5出现的个数：(都是下取整)<br>$$<br>n/5 + n / 5^2 + n/ 5^3 + …<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">cnt += n / <span class="number">5</span>;</span><br><span class="line">n = n / <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> #好题 推论：计算阶乘n!中质因子p的个数<br>$$<br>num_p = n/p + n/p^2 + n/p^3 + …<br>$$<br>如果所求因子为合数c，可以将这个合数c拆分为质数的乘积（即求出其质因子$a_i$和质因子的幂次$b_i$），c的在n!中出现的个数就是<br>$$<br>num_c = \min(num_{a_1}/b_1, num_{a_2}/b_2,…, num_{a_i}/b_i)<br>$$<br>如下题：<br><a href="https://www.acwing.com/problem/content/3487/">3484. 整除问题 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">get_ds</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i, s ++ ;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;i, s&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) res.<span class="built_in">push_back</span>(&#123;n, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_p</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n / p) res += n / p, n /= p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ds = <span class="built_in">get_ds</span>(m);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ds.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = ds[i][<span class="number">0</span>], s = ds[i][<span class="number">1</span>];</span><br><span class="line">        res = <span class="built_in">min</span>(res, (<span class="built_in">get_p</span>(n, p) / s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化-Echarts使用</title>
      <link href="2022/03/15/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_Echarts%E4%BD%BF%E7%94%A8/"/>
      <url>2022/03/15/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_Echarts%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>#知识点<br>一般后端采用json文件来存储数据，json相当于是js类型文件的子集，所以各种语言多采用json文件存储数据，这样便于前端处理。<br>#知识点<br>世界上五大浏览器<br>google、FireFox、IE、Opera、Safari</p><span id="more"></span><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>结构：HTML(内容)  + CSS(样式) + JS(动态)<br>#知识点<br>脚本语言，不会进行编译，而是直接运行，运行到哪里出了问题就停止在哪里，之前的渲染效果还是起作用。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>其中进行声明</p><ul><li>meta  charset 设置编码格式</li><li>icon 设置页面icon图标</li><li>title 设置页面标题</li><li>script 引入script文件<h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4></li><li>id标签  是唯一的<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2>var 声明变量，具体类型由其自动判定<br>document  是dom对象，其中getElementById(id)函数可以通过id来获得对应标签。<br>js对象，用大括号{}括起来，然后其中都是key:value类型，然后value类型随意。<h3 id="矢量图和位图"><a href="#矢量图和位图" class="headerlink" title="矢量图和位图"></a>矢量图和位图</h3><h4 id="矢量图svg"><a href="#矢量图svg" class="headerlink" title="矢量图svg"></a>矢量图svg</h4>图片大小变化时清晰度不变<br>单个html可以绘制多个图形元素<br>高保真<h4 id="位图canvas"><a href="#位图canvas" class="headerlink" title="位图canvas"></a>位图canvas</h4>图由像素绘制，图片变化时清晰度会变化<br>单个html，类似于画笔在画布上画画<br>Echarts基于canvas画图<h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h2>是一个javascript库，使用时需要引入js文件<br>创建一个简单表格的过程：</li><li>调用echarts.init(document.getElementById…)来初始化echarts对象</li><li>变量option指定图表的数据和配置项<ul><li>title 设置表格标题</li><li>toolbox 工具箱</li><li>legend 图例</li><li>xAxis、yAxis  x轴、y轴</li><li>series[] 是一个数组  <ul><li>其中type指定图标的类型</li><li>其中data可以通过js、axios、java、hadoop、mysql等从后端获取</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
          <category> Echarts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
            <tag> HTML </tag>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-15字符串处理、递归和背包问题</title>
      <link href="2022/03/15/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_15%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86_%E9%80%92%E5%BD%92%E5%92%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>2022/03/15/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_15%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86_%E9%80%92%E5%BD%92%E5%92%8C%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>#知识点 OJ平台报错：Presentation Error。<br>1.思路是对的，且运行时间符合要求<br>2.答案和标准结果非常接近，也就是说最可能是因为，在输出结果中，多了或少了不必要的空格或者回车或者其他，总而言之，OJ平台对格式的检查非常严格，所以一定要认真检查程序的输出结果是否与标准一致。</p><span id="more"></span><p>#知识点 climits库<br>其中包含了INT_MAX、INT_MIN等类型最值<br>#知识点 函数sscanf<br><code>sscanf(ca, &quot;%lf(s)&quot;, &amp;ia)</code><br>表示将char[]类型的ca中的数据按照””中格式进行解析（类似于scanf从控制台读数据），然后赋值给ia<br>这个函数一般用来获得字符串中的特定格式数据，比如”199.203(s)”获得其中的数字部分。<br>#知识点 匿名函数<br>一般写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](参数)&#123;函数代码 <span class="keyword">return</span> ...;&#125;  <span class="comment">// 匿名函数可以不指定返回值类型</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html">C++11中的匿名函数(lambda函数,lambda表达式) - 缘来是梦 - 博客园</a></p><ul><li>函数中可以访问全局变量（相对而言的外部变量）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string logs[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, logs[n]))</span><br><span class="line">        <span class="keyword">if</span> (logs[n].<span class="built_in">size</span>()) n ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(logs, logs + n, [](string&amp; a, string &amp;b) &#123; <span class="comment">// 匿名函数用法</span></span><br><span class="line">        stringstream <span class="built_in">ssina</span>(a), <span class="built_in">ssinb</span>(b); <span class="comment">// stringstream用法</span></span><br><span class="line">        string sa[<span class="number">4</span>], sb[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            ssina &gt;&gt; sa[i];</span><br><span class="line">            ssinb &gt;&gt; sb[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sa[<span class="number">3</span>] == sb[<span class="number">3</span>]) <span class="keyword">return</span> sa[<span class="number">1</span>] + sa[<span class="number">2</span>] &lt; sb[<span class="number">1</span>] + sb[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ta, tb;</span><br><span class="line">        <span class="built_in">sscanf</span>(sa[<span class="number">3</span>].<span class="built_in">c_str</span>(), <span class="string">&quot;%lf(s)&quot;</span>, &amp;ta); <span class="comment">// scanf用法</span></span><br><span class="line">        <span class="built_in">sscanf</span>(sb[<span class="number">3</span>].<span class="built_in">c_str</span>(), <span class="string">&quot;%lf(s)&quot;</span>, &amp;tb);</span><br><span class="line">        <span class="keyword">return</span> ta &lt; tb;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        cout &lt;&lt; logs[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2>#好题 <a href="https://www.acwing.com/problem/content/3444/">3441. 重复者 - AcWing题库</a><br>#知识点 string的构造函数之一<br><code>inline string(std::size_t __n, char __c, const std::allocator&lt;char&gt; &amp;__a = std::allocator&lt;char&gt;())</code><br>Construct string as multiple characters. 即构造一个string，并且以重复__n次的__c来进行赋值。例如：<br><code>res[i] = string(n*m, &#39; &#39;)</code><br><code>string str(10, &#39;a&#39;);</code><br>#知识点 段错误<br>一定要仔细查看边界问题，是否有越界访问。<br>vector之间可以直接相互赋值，不过vector数组不可以（数组都不可以直接相互赋值）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;string&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">g</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">g</span>(k - <span class="number">1</span>); <span class="comment">// 获得上一层的图形</span></span><br><span class="line">    <span class="keyword">int</span> m = s.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(n * m)</span></span>;  <span class="comment">// 声明一个n*m大小的vector，每一项值为默认值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i ++ )</span><br><span class="line">        res[i] = <span class="built_in">string</span>(n * m, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (p[i][j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; x ++ )</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; m; y ++ )</span><br><span class="line">                        res[i * m + x][j * m + y] = s[x][y];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        p.<span class="built_in">clear</span>();  <span class="comment">// 清楚上个模板</span></span><br><span class="line">        <span class="built_in">getchar</span>();  <span class="comment">// 注意这里cin与getline()有回车，要用getchar()读掉n后的回车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            string line;</span><br><span class="line">            <span class="built_in">getline</span>(cin, line);</span><br><span class="line">            p.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">g</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s: res) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="点菜问题"><a href="#点菜问题" class="headerlink" title="点菜问题"></a>点菜问题</h3><p><a href="https://www.acwing.com/problem/content/3448/">3445. 点菜问题 - AcWing题库</a><br>#知识点<br>注意，这道题的不超过P和下面那道题的总和必须为40构成对比，注意比对代码实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> C = <span class="number">1010</span>, N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> f[C];</span><br><span class="line"><span class="keyword">int</span> v[N], p[N];</span><br><span class="line"><span class="comment">// f[N][C] = max(f[N - 1][C], f[N - 1][C - p[i]] + v[i])</span></span><br><span class="line"><span class="comment">// f[C] = max(f[C], f[C - p[i]] + v[i])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; c &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; p[i] &gt;&gt; v[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = c; j &gt;= p[i]; -- j) <span class="comment">// 因为j-p[i] &gt;= 0 所以即使p总和小于P也符合题意，与下题构成对比</span></span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - p[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[c] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="神奇的口袋"><a href="#神奇的口袋" class="headerlink" title="神奇的口袋"></a>神奇的口袋</h3><p><a href="https://www.acwing.com/problem/content/3445/">3442. 神奇的口袋 - AcWing题库</a><br>DP：</p><ul><li>状态表示f(i, j)<ul><li>集合：所有从前i个物品中选，且总体积<strong>恰好等于</strong>j的选法的集合</li><li>属性：<strong>数量</strong></li></ul></li><li>状态计算<ul><li>集合划分<ul><li>不选物品i且总体积恰好等于j         f(i - 1, j)</li><li>选物品i，且总体积恰好等于j         f(i - 1, j - v[i])<br>注意这道题<mark style="background: #FF5582A6;">关键是对f(i, j)的初始化体现出来了总体积恰好等于j，而不是上一题的小于等于j</mark> 。f(0, 0) = 1含义：选前0个物品且总体积恰好等于0，则选法为1种；什么都不选；f(0, 1) = 0含义：选前0个物品且总体积恰好等于1，则选法为1种 ；f(0, 2) = 0…<br>而上一题如果改为计算个数，则f(0, 0) = 1，f(0, 1) = 1 ，…<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 初始化决定了是小于等于v还是等于v</span></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">40</span>; i &gt;= v; i -- )</span><br><span class="line">            f[i] += f[i - v];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">40</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="https://www.acwing.com/problem/content/3385/">3382. 整数拆分 - AcWing题库</a><br>#疑问<br>为什么初始化f[0][0] = 1？<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/3405/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="comment">// f[i][j] 表示只选前i种2的次幂的，结果等于j的选法数量</span></span><br><span class="line"><span class="comment">// f[i][j] 可以划分为不选i  选一个i   选两个i ...</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j] + f[i-1][j - w[i]] + f[i-1][j - 2 * w[i]] + ...</span></span><br><span class="line"><span class="comment">// f[i][j - w[i]] = f[i - 1][j - w[i]] + f[i-1][j - 2 * w[i]] + ...</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j] + f[i][j - w[i]]</span></span><br><span class="line"><span class="comment">// f[j] = f[j] + f[j - w[i]] // i, j从小到大列举</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    w[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="comment">// 为什么错了？ f[0][j]  对应 w[0]限制j</span></span><br><span class="line">        f[j] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// f[0][0]  这里不知道为什么要等于1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; w[i - <span class="number">1</span>] &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] = w[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 本来段错误 j 可能小于零！ 因为int i溢出了，所以加了w[i-1] &lt; n的限制</span></span><br><span class="line">            f[j] =(f[j] + f[j - w[i]])% <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法TIPS-整除、取模运算讨论</title>
      <link href="2022/03/14/%E7%AE%97%E6%B3%95TIPS_%E6%95%B4%E9%99%A4%E4%B8%8E%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E8%AE%A8%E8%AE%BA/"/>
      <url>2022/03/14/%E7%AE%97%E6%B3%95TIPS_%E6%95%B4%E9%99%A4%E4%B8%8E%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>当余数不为0的时候，取整除<code>\</code>可能有多种方式。<br><strong>向上取整</strong>，向+∞方向取最接近精确值的整数，Ceiling取整。</p><blockquote><p>17/10 = 2,  5/2 = 3, -9 / 4 = -2, 3/-4 = 0</p></blockquote><span id="more"></span><p><strong>向下取整</strong>，向-∞方向取最接近精确值的整数，Floor取整。</p><blockquote><p>17/10 = 1, 5/2 = 2, -9 / 4 = -3, 3/-4 = -1</p></blockquote><p><strong>向零取整</strong>，向0方向取最接近精确值的整数，换言之就是舍去小数部分，截断取整truncate。</p><blockquote><p>17/10 = 1, 5/2 = 2, -9 /4 = -2, 3/-4 = 0</p></blockquote><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><p>取模运算的结果正是和上面整除运算一一对应的，而计算机语言常用的是truncate除法（向零取整）和floor除法（向下取整）。<br>Java、C\C++等采用的是truncate除法，而Python采用的是floor除法。除法和取模一一对应，而且被除数a、除数（模）d、商q和余数r一定满足：<br>$$<br>a = q*d + r\tag{1}<br>$$<br>$$<br>|r| \leq|d|\tag{2}<br>$$<br>那么借此即可得到取模运算的结果。</p><blockquote><p>Java、C\C++的truncate除法对应取模：<br>17%10 = 7, 5%2 = 1, -9%4 = -1, 3%-4 = 3</p><blockquote><p>本质可以理解为：两数绝对值进行取模操作，然后符号位由被除数决定。</p></blockquote><p>Python的floor除法对应取模（数学含义的取模）：<br>17%10 = 7, 5%2 = 1, -9%4 = -3, 3%-4 = -1</p></blockquote><p><strong>一般而言，题目中所说的都是数学含义的取模</strong>，数学含义的取模运算采用的也是floor除法对应取模，取值一定大于0。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>C++代码实现时，</p><ol><li>如果想要实现i减减，但是保证处于[0, n-1]区间，那么可以写成：<br>  <code>i = (i - 1 + n)%n</code></li><li>另外，如果需要判断两数a和b模x是否相等，判断语句不能写为<code>a % x == b % x</code>，建议写成两数相减再取模：<code>(a - b) % x == 0</code>。否则可能与数学含义的取模结果不同。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法TIPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法TIPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-14模拟、递推和BFS</title>
      <link href="2022/03/14/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_14%E6%A8%A1%E6%8B%9F_%E9%80%92%E6%8E%A8%E5%92%8CBFS/"/>
      <url>2022/03/14/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_14%E6%A8%A1%E6%8B%9F_%E9%80%92%E6%8E%A8%E5%92%8CBFS/</url>
      
        <content type="html"><![CDATA[<h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>DP、DFS、贪心等一般都是最优化问题，从大量方案中找出最优解。<br>而模拟一般只有一种方案，解法就是按照题意模拟出来方案即可，然后数据结构一般会用来优化。</p><span id="more"></span><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h4><blockquote><p>踩坑记录：sort()函数不能用来对map、unordered_map、set、unordered_set进行排序，因为这些容器迭代器都是双向迭代器，而sort函数要求迭代器类型是随机访问迭代器。同样stack、queue等不支持迭代器，也不可以用sort排序。<br>对于unordered_map等，可以将元素取出放入vector，排完序以后再放回。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second &lt; b.second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.second == b.second) <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string, <span class="keyword">int</span>&gt; msi;</span><br><span class="line">    msi[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    msi[<span class="string">&quot;watermelon&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    msi[<span class="string">&quot;pear&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    msi[<span class="string">&quot;peach&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    msi[<span class="string">&quot;cherry&quot;</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt; <span class="built_in">vpi</span>(msi.<span class="built_in">begin</span>(), msi.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(vpi.<span class="built_in">begin</span>(), vpi.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item: vpi)&#123;</span><br><span class="line">        cout &lt;&lt; item.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">watermelon 2</span></span><br><span class="line"><span class="comment">pear 3</span></span><br><span class="line"><span class="comment">apple 5</span></span><br><span class="line"><span class="comment">peach 5</span></span><br><span class="line"><span class="comment">cherry 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>vector&lt;pair&lt;string, int&gt;&gt; vpi(msi.begin(), msi.end());</code><br>初始化vector时，直接通过首尾两个迭代器进行赋值。</p><h5 id="本题解法"><a href="#本题解法" class="headerlink" title="本题解法"></a>本题解法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second == b.second)</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++ k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ cnt[num[i] % <span class="number">10</span>];</span><br><span class="line">            num[i] /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cp);</span><br><span class="line">        cout &lt;&lt; (*(vec.<span class="built_in">begin</span>())).first &lt;&lt; endl;</span><br><span class="line">        cnt.<span class="built_in">clear</span>();</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>y总方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">6</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            s[i][x % <span class="number">10</span>] ++ ;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (s[i][k] &lt; s[i][j])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sort对二维数组进行排序"><a href="#sort对二维数组进行排序" class="headerlink" title="sort对二维数组进行排序"></a>sort对二维数组进行排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a[i], a[i] + <span class="number">10</span>); <span class="comment">// 对数组的第i行进行排序</span></span><br></pre></td></tr></table></figure><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><p>递推是DP的特例，即DP的状态方程。解决问题，推导出公式。<br>一般是第n个结果由前面的n-1个结果的部分数据或全部数据的公式推导。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="递推数列"><a href="#递推数列" class="headerlink" title="递推数列"></a>递推数列</h4><p><a href="https://www.acwing.com/problem/content/3395/">3392. 递推数列 - AcWing题库</a><br>#知识点<br>取模运算%，可以将%展开到+、-、*括号内，但是<strong>这个操作对/不成立</strong>。例如：<br>$$<br>(a<em>b)%d=(a%d</em>b%d)%d<br>$$</p><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a0, a1, p, q, k, ak, d = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a0 &gt;&gt; a1 &gt;&gt; p &gt;&gt; q &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    a0 %= d, a1 %= d, p %= d, q %= d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(--k)</span><br><span class="line">    &#123;</span><br><span class="line">        ak = (p*a1%d + q*a0%d)%d;</span><br><span class="line">        a0 = a1;</span><br><span class="line">        a1 = ak;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ak &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="吃糖果"><a href="#吃糖果" class="headerlink" title="吃糖果"></a>吃糖果</h4><p><a href="https://www.acwing.com/problem/content/3436/">3433. 吃糖果 - AcWing题库</a><br>实质：斐波那契数列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    n -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(--n)</span><br><span class="line">    &#123;</span><br><span class="line">        f[<span class="number">3</span>] = f[<span class="number">1</span>] + f[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">1</span>] = f[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">2</span>] = f[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>BFS相对于DFS的最大优势在于，它可以求<strong>最短路或者最小步数</strong>。<br><a href="https://www.acwing.com/problem/content/3388/">3385. 玛雅人的密码 - AcWing题库</a><br>#知识点<br>BFS通过队列比较好实现，而其中可能出现元素的最短距离可以通过map来存储，然后向map中添加最短距离时具体数值可以通过上一层元素距离+1计算获得。</p><blockquote><p>通过一个count变量来维持一个层数计算是困难的，因为每层元素个数不同。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; dist;  <span class="comment">// 存储string的最短距离</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (t.<span class="built_in">substr</span>(i, <span class="number">4</span>) == <span class="string">&quot;2012&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> dist[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            string r = t;</span><br><span class="line">            <span class="built_in">swap</span>(r[i], r[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(r))</span><br><span class="line">            &#123;</span><br><span class="line">                dist[r] = dist[t] + <span class="number">1</span>; <span class="comment">// 相对t距离多1</span></span><br><span class="line">                q.<span class="built_in">push</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; start;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(start) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/3405/">3402. 等差数列 - AcWing题库</a></p><blockquote><p>这道题开始时有思路，但是没有想好如何用代码实现。一些细节，比如如何存储被更新的数据然后才能像题目要求一样存储（用pair数组），比如没有想到用队列来存储数据（注意这种题目的形式，一个数据集每个数据每次都通过一些操作产生新的数据集，从上向下不断数据集变大，就可以考虑为BFS类型题，用queue）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次有思路  但是犹豫了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, N2 = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> row[N], col[N]; <span class="comment">// 存储每行（列）的有效数据量</span></span><br><span class="line"><span class="keyword">int</span> q[N2], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">bool</span> st[N2]; <span class="comment">// 存储行与列的状态，是否被填满了</span></span><br><span class="line">PII ans[N * N];  <span class="comment">// 存储最后输出的答案</span></span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">// ans的最后一个有效元素下标</span></span><br><span class="line"><span class="keyword">int</span> g[N][N]; <span class="comment">// 存储数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (g[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                row[i] ++ ;</span><br><span class="line">                col[j] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (row[i] &gt;= <span class="number">2</span> &amp;&amp; row[i] &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (col[i] &gt;= <span class="number">2</span> &amp;&amp; col[i] &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            q[ ++ tt] = i + n;</span><br><span class="line">            st[i + n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">if</span> (t &lt; n)  <span class="comment">// 行</span></span><br><span class="line">        &#123;</span><br><span class="line">            PII p[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[t][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    p[cnt ++ ] = &#123;i, g[t][i]&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">int</span> d = (p[<span class="number">1</span>].y - p[<span class="number">0</span>].y) / (p[<span class="number">1</span>].x - p[<span class="number">0</span>].x);  <span class="comment">// 题目中给了元素都是正整数，所以可以用int来接收增量</span></span><br><span class="line">            <span class="keyword">int</span> a = p[<span class="number">1</span>].y - d * p[<span class="number">1</span>].x;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">                <span class="keyword">if</span> (!g[t][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    g[t][i] = a + d * i;</span><br><span class="line">                    ans[top ++ ] = &#123;t, i&#125;;</span><br><span class="line">                    col[i] ++ ;</span><br><span class="line">                    <span class="keyword">if</span> (col[i] &gt;= <span class="number">2</span> &amp;&amp; col[i] &lt; m &amp;&amp; !st[i + n])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q[ ++ tt] = i + n;</span><br><span class="line">                        st[i + n] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 列</span></span><br><span class="line">        &#123;</span><br><span class="line">            t -= n;</span><br><span class="line">            PII p[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[i][t])</span><br><span class="line">                &#123;</span><br><span class="line">                    p[cnt ++ ] = &#123;i, g[i][t]&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (cnt == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">int</span> d = (p[<span class="number">1</span>].y - p[<span class="number">0</span>].y) / (p[<span class="number">1</span>].x - p[<span class="number">0</span>].x);</span><br><span class="line">            <span class="keyword">int</span> a = p[<span class="number">1</span>].y - d * p[<span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">                <span class="keyword">if</span> (!g[i][t])</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][t] = a + d * i;</span><br><span class="line">                    ans[top ++ ] = &#123;i, t&#125;;</span><br><span class="line">                    row[i] ++ ;</span><br><span class="line">                    <span class="keyword">if</span> (row[i] &gt;= <span class="number">2</span> &amp;&amp; row[i] &lt; n &amp;&amp; !st[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q[ ++ tt] = i;</span><br><span class="line">                        st[i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ans, ans + top);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; p = ans[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, p.x + <span class="number">1</span>, p.y + <span class="number">1</span>, g[p.x][p.y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#知识点<br>代码提交后返回状态：Float Point Exception<br>可能原因：分母为0，注意看/或%操作的分母是否可能取到0。</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-17枚举和位运算</title>
      <link href="2022/03/13/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_17%E6%9E%9A%E4%B8%BE%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>2022/03/13/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_17%E6%9E%9A%E4%B8%BE%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>一般解决的问题：寻找特殊的数或者计算这些数的个数。往往数据范围比较小，可以穷举。<br>枚举，顾名思义就是将所有符合条件的数穷举出来。</p><span id="more"></span><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="与7无关的数"><a href="#与7无关的数" class="headerlink" title="与7无关的数"></a>与7无关的数</h4><p><a href="https://www.acwing.com/problem/content/3437/">3434. 与7无关的数 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">notSevenRe</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tem = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        tem = i%<span class="number">10</span>;</span><br><span class="line">        i /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(tem == <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">notSevenRe</span>(i))</span><br><span class="line">            res += i*i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>y总方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span> || <span class="built_in">to_string</span>(i).<span class="built_in">find</span>(<span class="string">&#x27;7&#x27;</span>) != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">res += i*i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最简真分数"><a href="#最简真分数" class="headerlink" title="最简真分数"></a>最简真分数</h4><p><a href="https://www.acwing.com/problem/content/3411/">3408. 最简真分数 - AcWing题库</a></p><blockquote><p>真分数是指分子小于分母的分数，最简真分数是指分子和分母没有共同公约数的分数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">        &#123;</span><br><span class="line">            x ^= y;</span><br><span class="line">            y ^= x;</span><br><span class="line">            x ^= y;</span><br><span class="line">        &#125;</span><br><span class="line">        x -= y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i)</span><br><span class="line">            cin &gt;&gt; num[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;++ j)</span><br><span class="line">                x += num[i]&lt;num[j] &amp;&amp; <span class="built_in">judge</span>(num[i], num[j]);</span><br><span class="line">                </span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大公约数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  <span class="comment">// 欧几里得算法  </span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 注意  a &gt;= b</span></span><br><span class="line"><span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Special数"><a href="#Special数" class="headerlink" title="Special数"></a>Special数</h4><p><a href="https://www.acwing.com/problem/content/3553/">3550. Special数 - AcWing题库</a><br>由于原题中n的最大$10^9$，所以有可能超时，所以需要考虑优化。然后因为立方数一定小于等于$n^{\frac{1}{3}}$，所以遍历的边界条件可以是$i<em>i</em>i&lt;n$，这样穷举范围就限制在$10^3$以内，需要判定的就是$i<em>i</em>i$这个立方数是不是平方数。<br>判定平方数，可以利用库函数sqrt()来获得他的因子，然后因子再求平方，看看是否与原来一致即可。（因为，sqrt返回的是浮点数，用int接受他的返回值会截断小数，这样不是平方数的因子再求平方就会小于原来的数。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i * i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * i * i;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="built_in">sqrt</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(r * r == x)</span><br><span class="line">                ++ c;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="位操作练习"><a href="#位操作练习" class="headerlink" title="位操作练习"></a>位操作练习</h4><p>循环左移可以得到的串，也可以通过循环右移进行获得，而这里用位操作右移比较方便，可以直接截断溢出的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> one = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n == m)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n = (n &gt;&gt; <span class="number">1</span>) + one;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>y总方法<br>循环左移/右移操作得到的字符串，其实都包含在将这个字符串复制两边再拼接到一起的字符串中。所以判断x能不能左移得到y，可以将x复制一份，拼接到原x后面，然后判断x.find(y)是否成立，如果成立，说明可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        string sn, sm;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sn = <span class="built_in">to_string</span>(n &amp; <span class="number">1</span>) + sn;     </span><br><span class="line">            sm = <span class="built_in">to_string</span>(m &amp; <span class="number">1</span>) + sm;   </span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            m = m&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sn += sn;</span><br><span class="line">        <span class="keyword">if</span>(sn.<span class="built_in">find</span>(sm) != sn.npos)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二进制数"><a href="#二进制数" class="headerlink" title="二进制数"></a>二进制数</h4><p><a href="https://www.acwing.com/problem/content/3533/">3530. 二进制数 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="built_in">to_string</span>(n &amp; <span class="number">1</span>) + s;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-20哈希表、双指针、序列型DP</title>
      <link href="2022/03/12/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_20%E5%93%88%E5%B8%8C%E8%A1%A8_%E5%8F%8C%E6%8C%87%E9%92%88_%E5%BA%8F%E5%88%97%E5%9E%8BDP/"/>
      <url>2022/03/12/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_20%E5%93%88%E5%B8%8C%E8%A1%A8_%E5%8F%8C%E6%8C%87%E9%92%88_%E5%BA%8F%E5%88%97%E5%9E%8BDP/</url>
      
        <content type="html"><![CDATA[<h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><a href="https://www.acwing.com/problem/content/3450/">3447. 子串计算 - AcWing题库</a></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/3450/</span></span><br><span class="line"><span class="comment">// 子串计算</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, <span class="keyword">int</span>&gt; map; <span class="comment">// 默认从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = s.<span class="built_in">size</span>(); i &lt; len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            string t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                t += s[j];</span><br><span class="line">                ++ map[t]; <span class="comment">// 如果没有这个数，会默认value为0 然后执行++操作                </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [k, v]:map) </span><br><span class="line">            <span class="keyword">if</span>(v &gt; <span class="number">1</span>)</span><br><span class="line">                cout &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://www.acwing.com/problem/content/3490/">3487. 最小面积子矩阵 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, INF = <span class="number">1e10</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][N]; <span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; s[i][j], s[i][j] += s[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c1 = <span class="number">1</span>; c1 &lt;= n; ++c1)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c2 = c1; c2 &lt;= n; ++c2)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= m; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += s[c2][j] - s[c1 - <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt;= k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>((c2 - c1 + <span class="number">1</span>)*(j - i + <span class="number">1</span>) &lt; res)</span><br><span class="line">                            res = (c2 - c1 + <span class="number">1</span>)*(j - i + <span class="number">1</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == INF)</span><br><span class="line">        res = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列型DP"><a href="#序列型DP" class="headerlink" title="序列型DP"></a>序列型DP</h2><h3 id="最大序列和"><a href="#最大序列和" class="headerlink" title="最大序列和"></a>最大序列和</h3><p><a href="https://www.acwing.com/problem/content/3396/">3393. 最大序列和</a><br>题目关键元素：最大<strong>连续</strong>子序列<br>划分子集：f(i)表示以第i个元素结尾的所有可能的非空连续子序列，返回值是这些子序列的最大的序列和。<br>则子集可以划分为两种：</p><ol><li>只包含第i个元素的子序列构成的集，即$f(i) = w_i$</li><li>元素不止第i个元素的子序列构成的集，即$f(i) = f(i-1) +w_i$<br>$$<br>f(i) = max(w_i, f(i-1)+w_i)<br>$$<br>所以，最后根据问题可知，S整数序列中所有非空连续子序列的最大序列和为：<br>$$<br>res = max(f(1), f(2), … f(n))<br>$$<h4 id="朴素型解法"><a href="#朴素型解法" class="headerlink" title="朴素型解法"></a>朴素型解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/3396/</span></span><br><span class="line"><span class="comment">// 最大序列和</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">LL sum[N];</span><br><span class="line">LL f[N];</span><br><span class="line">LL res = <span class="number">-1e16</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="built_in">max</span>(f[i<span class="number">-1</span>]+sum[i], sum[i]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化型解法"><a href="#优化型解法" class="headerlink" title="优化型解法"></a>优化型解法</h4>观察等式可以知道，每次的f(i)值只依赖于前一个f(i-1)的值，所以可以优化为一个long long型数据存储其值，以此节约空间大小。<br>$$<br>f = max(f+w_i,w_i)<br>$$<br>$$<br>res = max (res, f)<br>$$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/3396/</span></span><br><span class="line"><span class="comment">// 最大序列和</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">LL sum;</span><br><span class="line">LL f;</span><br><span class="line">LL res = <span class="number">-1e16</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;sum);</span><br><span class="line">        f = <span class="built_in">max</span>(f+sum, sum);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长ZigZag子序列"><a href="#最长ZigZag子序列" class="headerlink" title="最长ZigZag子序列"></a>最长ZigZag子序列</h3><a href="https://www.acwing.com/problem/content/3508/">3505. 最长ZigZag子序列 - AcWing</a><br>划分子集：由题意，可以划分为两个情况，一种情况是所有以第i个元素结尾的ZigZag子序列，同时最后第i个元素小于第i-1个元素，设他们的集合为f(i)；另一种情况是所有以第i个元素结尾的ZigZag子序列，同时最后第i个元素大于第i-1个元素，设他们的集合为g(i)。<br>所以可以得到，f(i)和g(i)都可以划分为i-1个情况，即ZigZag子序列的第i个元素的前一个元素是第j个元素（j可以取到1、2、…、i-1）的i-1种情况。<br>同时，可以发现ZigZag子序列的第i个元素如果大于第i-1个元素，那么第i-1个元素一定小于第i-2个元素，反之同理。所以可以得到f(i)和g(i)的推导公式：<br>$$<br>f(i) = max(g(i-1)+1, g(i-2)+1, …, g(1)+1, 1)<br>$$<br>$$<br>g(i)=max(f(i-1)+1, f(i-2)+1,…,f(1)+1, 1)<br>$$<br>所以最后求解结果：<br>$$<br>res = \max()<br>$$<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> f[N], g[N];</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; num[i];</span><br><span class="line">f[i] = <span class="number">1</span>, g[i] = <span class="number">1</span>; <span class="comment">// 这个初始化不要忘记，只有自己本身，则长度为1；否则最后长度不会将自己算入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num[j] &gt; num[i])</span><br><span class="line">f[i] = <span class="built_in">max</span>(g[j]+<span class="number">1</span>, f[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num[j] &lt; num[i])</span><br><span class="line">g[i] = <span class="built_in">max</span>(f[j]+<span class="number">1</span>, g[i]);</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(f[i], g[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing算法题-闫式DP法</title>
      <link href="2022/03/11/AcWing%E7%AE%97%E6%B3%95%E9%A2%98_%E9%97%AB%E5%BC%8FDP%E6%B3%95/"/>
      <url>2022/03/11/AcWing%E7%AE%97%E6%B3%95%E9%A2%98_%E9%97%AB%E5%BC%8FDP%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="闫式DP法"><a href="#闫式DP法" class="headerlink" title="闫式DP法"></a>闫式DP法</h1><p>动态规划问题本质：==有限集==中==最值==问题。<br>动态规划：</p><ul><li>状态表示 - 化零为整<ul><li>集合 f(i, j)<ul><li>一般描述：所有只考虑前i个物品，且总体积不超过j的<strong>选法</strong>的集合</li></ul></li><li>属性：集合中每个方案的 max / min / count 值</li></ul></li><li>状态计算 - 化整为零<ul><li>划分为若干个不重复、不遗漏的子集来求解<blockquote><p>划分依据：寻找最后一个不同点</p></blockquote></li></ul></li></ul><span id="more"></span><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p><a href="https://www.acwing.com/problem/content/description/2/">2. 01背包问题 - AcWing题库</a></p><h3 id="朴素版本"><a href="#朴素版本" class="headerlink" title="朴素版本"></a>朴素版本</h3><p>动态规划过程：</p><ul><li>状态表示 - 化零为整<ul><li>集合 f(i, j)<ul><li>一般描述：所有只考虑前i个物品，且总体积不超过j的<strong>选法</strong>的集合</li></ul></li><li>属性：max，当前情况下背包内物品价值<br>所以集合f(i, j)划分为：<ol><li>所有不选第i个物品的方案 – 1到i-1物品，总体积不超过j。f(i, j) = f(i-1, j)</li><li>所有选择第i个物品的方案 – 1到i物品，总体积不超过j。因为1到i-1已经不变了，所以关键是选出第i个使得值最大f(i, j) = f(i-1, j-v<sub>i</sub>) + w<sub>i</sub><br>即二维数组迭代公式1：$$f(i, j) = max (f(i-1, j), f(i-1, j-v_i) + w_i)$$</li></ol></li></ul></li><li>状态计算 - 化整为零<ul><li>划分为若干个不重复、不遗漏的子集来求解<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) <span class="comment">// j表示已经容纳物品的体积&lt;=j</span></span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - v[i] &gt;= <span class="number">0</span>)</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化方法（空间优化）"><a href="#优化方法（空间优化）" class="headerlink" title="优化方法（空间优化）"></a>优化方法（空间优化）</h3>优化方式：f(i, j)的二维数组可以优化成一维数组<br>观察式子可以发现，第i行的值只依赖于第i-1行的数据，所以可以采用滚动数组的方式（通过一维数组更新存储数据）。<br>同时可以发现，第j列的值依赖于第j列和第j-v<sub>i</sub>列的数据，那么j可以从大到小遍历，这样由于滚动数组更新从大到小进行，所以遍历到j的时候，j-v<sub>i</sub>列的数据还是第i-1行时的数据。<br>优化后方程$f[j] = max(f[j], f[j-v[i]] + w[i]);$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; j--) <span class="comment">// j表示已经容纳物品的体积&lt;=j</span></span><br><span class="line">&#123;</span><br><span class="line">f[j] = f[j];</span><br><span class="line"><span class="keyword">if</span> (j - v[i] &gt;= <span class="number">0</span>)</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[V] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><a href="https://www.acwing.com/problem/content/description/3/">3. 完全背包问题 - AcWing题库</a></li></ul></li><li>状态表示 - 化零为整<ul><li>集合 f(i, j)<ul><li>一般描述：所有只考虑前i个物品，且总体积不超过j的<strong>选法</strong>的集合</li></ul></li><li>属性：max，当前情况下背包内物品价值<br>所以集合f(i, j)划分为：<ol><li>所有不选第i个物品的方案 – 1到i-1物品，总体积不超过j。f(i, j) = f(i-1, j)</li><li>选择1个第i个物品的方案 – 1到i物品，总体积不超过j。因为1到i-1已经不变了，所以关键是选出第i个使得值最大f(i, j) = f(i-1, j-v<sub>i</sub>) + w<sub>i</sub></li><li>选择2个第i个物品的方案</li><li>选择3个第i个物品的方案</li><li> …</li><li>选择k个第i个物品的方案<br>即二维数组迭代公式2：<br>$$<br>f(i, j) = max (f(i-1, j), f(i-1, j-v_i) + w_i, f(i-1, j-2<em>v_i) + 2</em>w_i), …, f(i-1, j-k<em>v_i) + k</em>w_i)<br>$$</li></ol></li></ul></li><li>状态计算 - 化整为零<ul><li>划分为若干个不重复、不遗漏的子集来求解<blockquote><p>由于存在三重循环，估算可知，可能会TLE，所以需要优化时间。</p></blockquote><h3 id="优化时间"><a href="#优化时间" class="headerlink" title="优化时间"></a>优化时间</h3>由二维数组迭代公式可以，当j = j - v时，可以得到公式3：<br>$$<br>f(i, j - v_i)=max(f(i-1, j-v_i), f(i-1, j-2<em>v_i) + w_i), …, f(i-1, j-(k+1)<em>v_i) + k</em>w_i)<br>$$<br>由于，由公式3得到$j - k * v_i&gt;0$，所以$f(i-1, j-(k+1)<em>v_i) + k</em>w_i$最后一项不用考虑，因此这个公式变为：<br>$$<br>f(i, j - v_i)=max(f(i-1, j-v_i), f(i-1, j-2</em>v_i) + w_i), …, f(i-1, j-k*v_i) + (k-1)*w_i)<br>$$<br>可以发现，他与公式2后半部分只差了一个$w_i$，所以可以优化公式3得到公式4：<br>$$<br>f(i, j)=max(f(i-1, j), f(i, j - v_i) + w_i)<br>$$<blockquote><p>公式表面意思是：划分为两个子集，第一个子集不取第i个物品，第二个子集表示至少取一个第i个物品。</p></blockquote></li></ul></li></ul><p>同时近似01背包问题，优化空间以后可以得到最终公式5：<br>$$<br>f(j) = max(f(j), f(j-v_i)+w_i)<br>$$<br>不过，此时的j要从小到大遍历，因为第二项是$f(i, j-v_i)$即更新后的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, V;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = v[i]; j &lt;= V; j++) <span class="comment">// j表示已经容纳物品的体积&lt;=j</span></span><br><span class="line">&#123;</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j- v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[V] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="石子合并问题（区间型DP）"><a href="#石子合并问题（区间型DP）" class="headerlink" title="石子合并问题（区间型DP）"></a>石子合并问题（区间型DP）</h2><p><a href="https://www.acwing.com/problem/content/description/284/">282. 石子合并 - AcWing题库</a><br>题目分析：</p><ol><li>由于所有中合并情况共计!n种方法，即是有限的（虽然很大），而问题求解的是最小代价。所以有限集的最值问题 —&gt;DP</li><li>由于每次只能合并相邻的两堆石子，所以对于一个区间而言，最后一次合并一定是左右两个区间进行合并，DP要从这里入手。<br>DP：</li></ol><ul><li>状态表示 - 化零为整（用一个集合包含非常多的情况）<ul><li>集合 f(i, j)<ul><li>一般描述：所有将[i, j]这个区间内的石子合并成一堆的方案的集合</li></ul></li><li>属性：min</li></ul></li><li>状态计算 - 化整为零（对集合中情况分为不同子集来计算）<ul><li>划分为若干个不重复、不遗漏的子集来求解。以分解点为划分依据：</li></ul><ol><li>最后合并的两堆：[i, i+1] [i+1, j] </li><li>最后合并的两堆：[i, i+2] [i+2, j]</li><li>…</li><li>最后合并的两堆：[i, j-1] [j-1, j]<br>即我们的任务是让最后合并的两堆分别求min，然后最后整体min即为其之和。<blockquote><p>区间型DP问题：<br>一般来说，两个循环，第一层循环遍历区间长度，第二层循环从区间最左侧元素开始往后遍历。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/description/284/</span></span><br><span class="line"><span class="comment">// 石子合并</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">340</span>;</span><br><span class="line"><span class="keyword">int</span> s[N]; <span class="comment">// 质量前缀和</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; s[i], s[i] += s[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            f[i][j] = INT_MAX;</span><br><span class="line">            <span class="comment">// 分界点 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + s[j] - s[i - <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// s[i]为前i个元素质量之和   s[j] - s[i-1]可以得到合并 i到k 和 k+1到j 两堆的代价</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><a href="https://leetcode-cn.com/problems/qJnOS7/">剑指 Offer II 095. 最长公共子序列 - 力扣（LeetCode） (leetcode-cn.com)</a><br>DP：</li></ol></li><li>状态表示 f(i, j)<ul><li>集合<br>所有A[1到i]与B[1到j]的公共子序列的集合</li></ul><ol><li>A[i-1]和B[j-1]的最大公共子序列  不包含A的第i个元素和B的第j个元素情况</li><li>A[i-1]和B[j]的最大公共子序列  不包含A的第i个元素</li><li>A[i]和B[j-1]的最大公共子序列  不包含B的第j个元素</li><li>A[i]和B[j]的一定包含A的第i个元素和B的第j个元素的最大公共子序列  if(A[i] ==B[j]) A[i-1]和B[j-1] + 1</li></ol><ul><li>属性 max</li></ul></li><li>状态计算</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法上机刷题笔记</title>
      <link href="2022/03/10/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>2022/03/10/%E7%AE%97%E6%B3%95%E4%B8%8A%E6%9C%BA%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h1><h2 id="英文单词"><a href="#英文单词" class="headerlink" title="英文单词"></a>英文单词</h2><p>comma  逗号<br>polynomial 表达式<br>exponent  幂<br>coefficient 系数<br>decimal place 小数位</p><span id="more"></span><p>in constant time 在常数时间内<br>continuous 连续<br>in ascending order 升序<br>distinct 不同的，有差异的<br>occurrence 发生;发生的事情;存在的事物;出现;存在<br>in-place 原地<br><strong>palindrome</strong> 回文</p><h2 id="记录问题"><a href="#记录问题" class="headerlink" title="记录问题"></a>记录问题</h2><h3 id="STL中size-的返回值类型（坑）"><a href="#STL中size-的返回值类型（坑）" class="headerlink" title="STL中size()的返回值类型（坑）"></a>STL中size()的返回值类型（坑）</h3><p>size()返回值类型为无符号整型（std::size_t），如果要与int等计算，注意一定要强制类型转换，否则结果不对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>)str.<span class="built_in">size</span>() - <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="好题目"><a href="#好题目" class="headerlink" title="好题目"></a>好题目</h2>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> PAT </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-04树的基本概念、二叉树、树和森林</title>
      <link href="2022/03/10/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_04%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E4%BA%8C%E5%8F%89%E6%A0%91_%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
      <url>2022/03/10/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_04%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E4%BA%8C%E5%8F%89%E6%A0%91_%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>(1) 树是由根节点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的节点，所定义的关系称为父子关系。父子关系在树的节点之间建立了一个层次结构。在这种层次结构中有一个节点具有特殊的地位，这个节点称为该树的根节点，或称为树根。</p><span id="more"></span><p>(2) 空集合也是树，称为空树。空树中没有节点；<br>(3) 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；<br>(4) 节点的度：一个节点含有的子节点的个数称为该节点的度；</p><blockquote><p>注意和图的度区别</p></blockquote><p>(5) 叶节点或终端节点：度为0的节点称为叶节点；<br>(6) 非终端节点或分支节点：度不为0的节点；</p><p>(7) 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</p><p>(8) 兄弟节点：具有相同父节点的节点互称为兄弟节点；</p><p>(9) 树的度：一棵树中，最大的节点的度称为树的度；</p><p>(10) 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</p><p>(11) 树的高度或深度：树中节点的最大层次；</p><p>(12) 节点的祖先：从根到该节点所经分支上的所有节点；</p><p>(13) 子孙：以某节点为根的子树中任一节点都称为该节点的子孙；</p><p>(14) 森林：由棵==互不相交的树的集合==称为森林。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义及其主要特征"><a href="#二叉树的定义及其主要特征" class="headerlink" title="二叉树的定义及其主要特征"></a>二叉树的定义及其主要特征</h3><ul><li><p>二叉树的基本形态：空二叉树、单节点二叉树、左子树、右子树</p></li><li><p>==性质==：</p><ul><li><p>n个节点的二叉树的边数等于n - 1</p></li><li><p>在非空二叉树中，第i层上至多有$2^{i-1}$ 个结点</p></li><li><p>深度为k的二叉树至多有$2^k - 1$个结点</p></li><li><p>对任何一棵二叉树，若其叶子结点数为n0，度为2的结点数为n2，则n0 = n2 + 1</p></li><li><p>完全二叉树的n1只能为0或1</p></li><li><p>n个结点的完全二叉树深度为：log2(n)向下取整 + 1</p></li><li><p>二叉树的堆式存储: 节点p的左儿子：2x，右儿子：2x+1；节点p的父节点：(x/2)向下取整</p><blockquote><p>堆式存储，可以通过数组存储，但是稀疏的树会浪费很多空间</p></blockquote></li><li><p>二叉树的链式存储</p></li></ul></li><li><p>两种特殊的二叉树</p><ul><li>满二叉树：一颗深度为k且有$2^k-1$个结点的二叉树</li><li>如果深度为k,有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号从1到n的结点一一对应，该二叉树称为完全二叉树</li></ul></li></ul><h3 id="二叉树的顺序存储结构和链式存储结构"><a href="#二叉树的顺序存储结构和链式存储结构" class="headerlink" title="二叉树的顺序存储结构和链式存储结构"></a>二叉树的顺序存储结构和链式存储结构</h3><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li>前序遍历</li><li>中序遍历</li></ul><blockquote><p>中序遍历，前驱：中序遍历中的该节点的前一个节点  后继：中序遍历中的该节点的后一个节点</p></blockquote><ul><li>后序遍历</li></ul><blockquote><p>根据前序 + 中序重建二叉树（AcWing 18)</p><p>根据中序 + 后序重构二叉树</p><p>根据层序 + 中序重构二叉树</p></blockquote><blockquote><p>已知前序遍历和后序遍历，只有当所有节点都是两个儿子或零个儿子的情况，才能唯一确定树，否则单个儿子的不知道这个儿子是左还是右儿子。</p></blockquote><ul><li>层次遍历</li></ul><h3 id="线索二叉树的基本概念和构造"><a href="#线索二叉树的基本概念和构造" class="headerlink" title="线索二叉树的基本概念和构造"></a>线索二叉树的基本概念和构造</h3><p>对于不同的遍历方法，线索二叉树构造结果不同。</p><p>对二叉树节点的指针域做如下规定：</p><ul><li><p>若节点有左孩子，则Lchild指向左孩子，否则指向直接前驱；右孩子同理；</p></li><li><p>增加两个标志域，Ltag表示指向的是子节点还是前驱；Rtag同理</p></li><li><p>指向前驱和后继的指针叫做线索。按照某种次序遍历，加上线索的二叉树称之为线索二叉树</p></li></ul><h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ul><li><p>只存父节点  例如：并查集</p></li><li><p>邻接表存储所有子节点<br><img src="/2022/03/10/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_04%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E4%BA%8C%E5%8F%89%E6%A0%91_%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220311154255299.png" alt="邻接表"></p></li><li><p>左儿子右兄弟<br><img src="/2022/03/10/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_04%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E4%BA%8C%E5%8F%89%E6%A0%91_%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220311154551048.png" alt="左儿子右兄弟"></p></li></ul><h3 id="森林F与二叉树T的转换"><a href="#森林F与二叉树T的转换" class="headerlink" title="森林F与二叉树T的转换"></a>森林F与二叉树T的转换</h3><ul><li>原森林中叶子节点数 = 转换后的树中有右儿子的节点数 + 1</li><li>原森林中叶子节点数 = 转换后的树中没有左儿子的节点数</li><li>F的前序遍历就是T的前序遍历</li><li>F的后序遍历就是T的中序遍历</li></ul><h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p>对于普通的树，只有前序遍历和后序遍历，没有中序遍历。<br><img src="/2022/03/10/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_04%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5_%E4%BA%8C%E5%8F%89%E6%A0%91_%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/image-20220311160026637.png" alt="普通树遍历"></p><ul><li>前序遍历</li><li>后序遍历</li></ul><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2><p>2011-4、2011-5、2011-6、2012-3、2013-5、2014-4、2014-5、2014-41、2015-2、2016-5、2016-42、2017-4、2017-5、2018-4、2019-2、2020-3、2020-4</p><h3 id="2014-41"><a href="#2014-41" class="headerlink" title="2014-41"></a>2014-41</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/description/3769/</span></span><br><span class="line"><span class="comment">// 二叉树的带权路径长度</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;  <span class="comment">// 不需要声明为静态，因为每次都返回了r</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val * level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)  <span class="comment">// 注意判定条件的书写 root-&gt;left不为NULL时才执行下面语句！</span></span><br><span class="line">            r += <span class="built_in">sum</span>(root-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            r += <span class="built_in">sum</span>(root-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>  r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h3 id="2015-2"><a href="#2015-2" class="headerlink" title="2015-2"></a>2015-2</h3><p><strong>题目：先序遍历为a，b，c，d的不同二叉树的个数是？</strong><br>14<br>当树的形态确定以后，前序遍历已知，则节点分布也是确定的，所以已知前序遍历的不同二叉树数量等于包含n个点的二叉树形态的数量。<br>#知识点 卡特兰数<br>包含n个点的二叉树形态的数量，就是第n个卡特兰数，<br>$$<br>C_n = \frac{C^n_{2n}}{n+1}<br>$$</p><blockquote><p>卡特兰数相关问题</p><ol><li>给定n个左括号和n个右括号，求可以构成多少个合法的括号序列。</li><li>给定n个数的序列和一个栈（即已知入栈顺序），求可能存在的出栈序列的个数。</li></ol></blockquote><h3 id="2016-42"><a href="#2016-42" class="headerlink" title="2016-42"></a>2016-42</h3><p>#技巧 求解节点数/边数并证明<br>两种思路</p><ol><li>数学归纳法</li><li>边与节点数的相互关系，n = xxxxx，e = xxxxx，n = e + 1，…<h3 id="2017-4"><a href="#2017-4" class="headerlink" title="2017-4"></a>2017-4</h3>前序与中序相同，则非叶节点无左子树<br>中序与后序相同，则非叶节点无右子树<br>前序与后序相同，则树只有根节点<h3 id="2020-3"><a href="#2020-3" class="headerlink" title="2020-3"></a>2020-3</h3>题目：对于任意一棵高度为5且有10个节点的二叉树，若采用顺序存储结构保存，每个节点占1个存储单元（仅存放节点的数据信息），则存放该二叉树需要的存储单位数量至少为：<br>31<br>本二叉树为任意二叉树，所以需要考虑最坏情况，即最后一个节点位于二叉树的右下角，所以1到5层所有节点（包括空节点）都要存储起来。</li></ol><h2 id="押题"><a href="#押题" class="headerlink" title="押题"></a>押题</h2><p>AcWing 18、AcWing 19</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-03栈与队列</title>
      <link href="2022/03/09/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_03%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>2022/03/09/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_03%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="栈和队列的基本概念"><a href="#栈和队列的基本概念" class="headerlink" title="栈和队列的基本概念"></a>栈和队列的基本概念</h2><h2 id="栈和队列的顺序存储结构"><a href="#栈和队列的顺序存储结构" class="headerlink" title="栈和队列的顺序存储结构"></a>栈和队列的顺序存储结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈顶元素位置（两种情况）：指向最后一个元素、指向最后一个元素的下一个位置</p><span id="more"></span><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>一般采用循环队列。</p><h4 id="四种写法-两两组合"><a href="#四种写法-两两组合" class="headerlink" title="四种写法 两两组合"></a>四种写法 两两组合</h4><blockquote><p>一般通过牺牲一个空间避免队满队空判断条件重复</p></blockquote><blockquote><p>初始化和判定条件，普通队列和双端队列是一样的</p></blockquote><p>队头元素位置：指向第一个元素、指向第一个元素的前一个位置。</p><p>队尾元素位置：指向队尾元素、指向队尾元素的下一个位置。</p><h5 id="常用-队头指向第一个元素，队尾指向最后一个元素的下一个位置"><a href="#常用-队头指向第一个元素，队尾指向最后一个元素的下一个位置" class="headerlink" title="常用-队头指向第一个元素，队尾指向最后一个元素的下一个位置"></a>常用-队头指向第一个元素，队尾指向最后一个元素的下一个位置</h5><p>初始：front = rear = 0</p><p>队空：front == rear</p><p>队满：front == (rear + 1) % MaxSize</p><p>队长：(rear - front + MaxSize) % MaxSize</p><h5 id="队头指向第一个元素，队尾指向最后一个元素"><a href="#队头指向第一个元素，队尾指向最后一个元素" class="headerlink" title="队头指向第一个元素，队尾指向最后一个元素"></a>队头指向第一个元素，队尾指向最后一个元素</h5><p>初始：front = 0  rear = MaxSize-1</p><p>队空：front == (rear + 1) % MaxSize</p><p>队满：front == (rear + 2) % MaxSize</p><p>队长：(rear - front + 1 + MaxSize) % MaxSize</p><h5 id="队头指向第一个元素前一个位置，队尾指向最后一个元素下一个位置"><a href="#队头指向第一个元素前一个位置，队尾指向最后一个元素下一个位置" class="headerlink" title="队头指向第一个元素前一个位置，队尾指向最后一个元素下一个位置"></a>队头指向第一个元素前一个位置，队尾指向最后一个元素下一个位置</h5><p>初始：front = MaxSize-1  rear = 0</p><p>队空：front == (rear - 1) % MaxSize</p><p>队满：front == rear</p><p>队长：(rear - front - 1 + MaxSize) % MaxSize</p><h5 id="队尾指向第一个元素前一个位置，队尾指向最后一个元素"><a href="#队尾指向第一个元素前一个位置，队尾指向最后一个元素" class="headerlink" title="队尾指向第一个元素前一个位置，队尾指向最后一个元素"></a>队尾指向第一个元素前一个位置，队尾指向最后一个元素</h5><p>初始：front = MaxSize-1 rear = MaxSize-1</p><p>队空：front == rear</p><p>队满：front == (rear + 1) % MaxSize</p><p>队长：(rear - front + MaxSize) % MaxSize</p><h2 id="栈和队列的链式存储结构"><a href="#栈和队列的链式存储结构" class="headerlink" title="栈和队列的链式存储结构"></a>栈和队列的链式存储结构</h2><h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><blockquote><p>注意：栈的链式存储一般设置头节点为栈顶，方便出栈入栈</p></blockquote><p>两种方式：</p><p><img src="/2022/03/09/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_03%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220309115912182.png" alt="方式一"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node* top = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">a -&gt; next = top;</span><br><span class="line">top = a;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/09/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_03%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220309115938730.png" alt="方式二"></p><h3 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h3><img src="/2022/03/09/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_03%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220309120022938.png" alt="队列-链式存储" style="zoom:80%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node *front = <span class="keyword">new</span> <span class="built_in">Node</span>(), *rear = front; <span class="comment">// front == rear 空</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">rear -&gt; val = <span class="number">1</span>; </span><br><span class="line">rear = rear -&gt; next = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line"><span class="keyword">auto</span> p = front;</span><br><span class="line">front = front -&gt; next;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 注意释放空间</span></span><br></pre></td></tr></table></figure><h2 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h2><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>C++中函数调用的维护是通过栈来实现的，不过不是所有函数调用都需要，比如尾递归就不需要（不需要维护现场）。</p><h4 id="表达式求值（蕴含中缀表达式转后缀表达式、括号匹配）"><a href="#表达式求值（蕴含中缀表达式转后缀表达式、括号匹配）" class="headerlink" title="表达式求值（蕴含中缀表达式转后缀表达式、括号匹配）"></a>表达式求值（蕴含中缀表达式转后缀表达式、括号匹配）</h4><p>给定一个表达式，其中运算符仅包含+、-、*、/（加、减、乘、整除），可能包含括号，请你计算表达式的最终值。</p><p>题目保证符号-只会作为减号出现，表达式中所有数字均为正整数。</p><p>注意题目中整除是向0取整，而不是向下取整，也就是说对于大于 0 的结果向下取整，例如 5/3=15/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。<strong>C++中就是向0取整</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个栈  符号栈 数值栈</span></span><br><span class="line"><span class="comment">// 优先级 + 1 - 1 x 2 / 2</span></span><br><span class="line"><span class="comment">// 数压入   (压入  )操作到&quot;(&quot;  </span></span><br><span class="line"><span class="comment">// +-x/ 1. 操作到&quot;(&quot;或操作到栈顶符号优先级&lt;当前符号优先级  </span></span><br><span class="line"><span class="comment">// 操作完运算符栈，数栈栈顶为答案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; op;   <span class="comment">// 操作符栈</span></span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt; nums; <span class="comment">// 数栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意后进先出  所以先弹出来的是右边的操作数</span></span><br><span class="line">    <span class="keyword">auto</span> b = nums.<span class="built_in">top</span>();</span><br><span class="line">    nums.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> a = nums.<span class="built_in">top</span>();</span><br><span class="line">    nums.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>();</span><br><span class="line">    op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        x = a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        x = a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        x = a * b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = a / b;</span><br><span class="line">    nums.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;; <span class="comment">// 算法优先级</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) <span class="comment">// isdigit() 函数  判断string是不是数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i, x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; <span class="built_in">isdigit</span>(s[j]))</span><br><span class="line">                x = x * <span class="number">10</span> + s[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            nums.<span class="built_in">push</span>(x);</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 弹出到左括号为止</span></span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="built_in">eval</span>(); <span class="comment">// 进行相应操作</span></span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 操作符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[s[i]]) <span class="comment">// 注意这里是大于号pr[op.top()] &gt;= pr[s[i]]</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (op.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">eval</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h5><p>后缀表达式，遇到运算符直接计算，无需括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个栈  符号栈</span></span><br><span class="line"><span class="comment">// 优先级 + 1 - 1 x 2 / 2</span></span><br><span class="line"><span class="comment">// 数输出   (压入  )操作到&quot;(&quot;  </span></span><br><span class="line"><span class="comment">// +-x/ 1. 操作到&quot;(&quot;或操作到栈顶符号优先级&lt;当前符号优先级  </span></span><br><span class="line"><span class="comment">// 操作完运算符栈，数栈栈顶为答案</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt; op;   <span class="comment">// 操作符栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>();</span><br><span class="line">    op.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;; <span class="comment">// 算法优先级</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) <span class="comment">// isdigit() 函数  判断string是不是数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i, x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len &amp;&amp; <span class="built_in">isdigit</span>(s[j]))</span><br><span class="line">                x = x * <span class="number">10</span> + s[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 弹出到左括号为止</span></span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="built_in">eval</span>(); <span class="comment">// 进行相应操作</span></span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 操作符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[s[i]]) <span class="comment">// 注意这里是大于号pr[op.top()] &gt;= pr[s[i]]</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (op.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">eval</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h5><p>遇到(入栈，遇到)弹栈</p><p>遇到)的时候，栈顶元素就是与他匹配的(</p><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><h3 id="队列的应用-BFS"><a href="#队列的应用-BFS" class="headerlink" title="队列的应用-BFS"></a>队列的应用-BFS</h3><h2 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h2><p>2011-2、2011-3、2012-2、2013-2、2014-2、2014-3、2015-1、2016-3、2017-2、2018-1、2018-2、2019-42、2020-2</p><h2 id="押题"><a href="#押题" class="headerlink" title="押题"></a>押题</h2><p>AcWing 3302 表达式求值</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-00基础知识</title>
      <link href="2022/03/02/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_00%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2022/03/02/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_00%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing语法基础课-基础知识"><a href="#AcWing语法基础课-基础知识" class="headerlink" title="AcWing语法基础课-基础知识"></a>AcWing语法基础课-基础知识</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="字符char的输入"><a href="#字符char的输入" class="headerlink" title="字符char的输入"></a>字符char的输入</h3><p>cin &gt;&gt; c;                    不会读入空格<br>scanf(“%c”, &amp;c);         会读入空格</p><h3 id="输入输出-1"><a href="#输入输出-1" class="headerlink" title="输入输出"></a>输入输出</h3><p>%lf         double<br>%lld       long long</p><span id="more"></span><h3 id="printf的输出"><a href="#printf的输出" class="headerlink" title="printf的输出"></a>printf的输出</h3><p><code>%.2f</code> 保留两位小数输出</p><h2 id><a href="#" class="headerlink" title="%"></a>%</h2><p>取模运算的结果正负完全取决于被除数。被除数正则除数正，被除数负则除数负。<br>注意：C++中取模运算本质相当于先对被除数的绝对值和除数的绝对值进行取模运算，然后再加上被除数的符号。<br>C++取模运算和实际数学中（很多题目中都是要求的数学取余）是不一样的，C++要实现数学的取余运算是**((x%mod)+mod) % mod**。</p><h2 id="变量类型转换"><a href="#变量类型转换" class="headerlink" title="变量类型转换"></a>变量类型转换</h2><p><code>对应类型 变量 = (类型)变量;</code><br>float转为double  没有问题<br>double转为float   损失一些精度<br>int转为浮点数      没问题<br>浮点数转为int      下取整<br>int与char之间       ASCII码</p><h3 id="强制类型准换"><a href="#强制类型准换" class="headerlink" title="强制类型准换"></a>强制类型准换</h3><p>向精度比较高的方向转换。<br>int向浮点数转换，char向int，int向long long等等</p><h2 id="用曼哈顿距离解决菱形输出问题"><a href="#用曼哈顿距离解决菱形输出问题" class="headerlink" title="用曼哈顿距离解决菱形输出问题"></a>用曼哈顿距离解决菱形输出问题</h2><p><img src="/2022/03/02/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_00%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20220302220738070.png" alt="用曼哈顿距离解决菱形输出问题"></p><h2 id="判断条件特殊用法"><a href="#判断条件特殊用法" class="headerlink" title="判断条件特殊用法"></a>判断条件特殊用法</h2><p>cin本身有返回值，例如读文件，如果读到文件末尾EOF会返回0，表示没有读到信息。<br>scanf本身有返回值，例如读文件，如果读到文件末尾EOF会返回-1，表示没有读到信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x)!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~ 按位取反 </span></span><br><span class="line"><span class="comment">// -1二进制是1111 ... 1111 取反得到 0000 ... 0000</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求数x的所有因子"><a href="#求数x的所有因子" class="headerlink" title="求数x的所有因子"></a>求数x的所有因子</h2><p>优化：只需要遍历 i * i &lt;= x，可以得到所有因子，即 i , x/i 的子集。</p><h2 id="找规律-偏移量技巧"><a href="#找规律-偏移量技巧" class="headerlink" title="找规律-偏移量技巧"></a>找规律-偏移量技巧</h2><h3 id="756-蛇形矩阵-AcWing题库"><a href="#756-蛇形矩阵-AcWing题库" class="headerlink" title="756. 蛇形矩阵 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/758/">756. 蛇形矩阵 - AcWing题库</a></h3><p><img src="/2022/03/02/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_00%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20220306123851750.png" alt="image-20220306123851750"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/758/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;; <span class="comment">// 坐标变化规律恒定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>, k = <span class="number">1</span>; k &lt;= n * m; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        res[x][y] = k;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[d], b = y + dy[d]; <span class="comment">// 判断下一个位置-加偏移量</span></span><br><span class="line">        <span class="comment">// 判断是否变换偏移量  出界/重复</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || res[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            a = x + dx[d], b = y + dy[d];</span><br><span class="line">        &#125;</span><br><span class="line">        x = a, y = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            cout &lt;&lt; res[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>‘0’ – 48<br>‘A’ – 65<br>‘a’ – 97        与大写差值是32<br>‘\0’ – 0</p><blockquote><p>0 在 int、double、float等中表示0，在char中表示’\0’，在指针中表示NULL，在bool中表示false。</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是字符数组加上一个结束符’\0’</p><h3 id="输入输出-2"><a href="#输入输出-2" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; s + <span class="number">1</span>; <span class="comment">// 从s+1开始读入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s + <span class="number">1</span> &lt;&lt; endl; <span class="comment">// 从s+1开始输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>); <span class="comment">// 从s+1开始输出  只能用于输出char[] 不能输出string</span></span><br><span class="line"><span class="built_in">puts</span>(s+<span class="number">1</span>); <span class="comment">// 等价与printf(&quot;%s&quot;, s+1); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cin scanf都是遇到空格或回车即停止读入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fgets</span>(s, 长度, stdin);  <span class="comment">// 读入一行 char[]  但不会去掉换行符\n。【注意】</span></span><br><span class="line">cin.<span class="built_in">getline</span>(s, 长度, del); <span class="comment">// 读入一行   char[] 【注意】同时自动去掉最后一个换行符\n      del是分隔符，默认是换行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, str, del);  <span class="comment">// 读入一行    string 【注意】同时自动去掉最后一个换行符\n       del是分隔符，默认是换行</span></span><br></pre></td></tr></table></figure><h3 id="char-常用函数"><a href="#char-常用函数" class="headerlink" title="char[]常用函数"></a>char[]常用函数</h3><p>char[]中的函数，不适用于string<br><code>strlen(str)</code> 求字符串的长度，不包含’\0’<br><code>strcmp(a, b)</code> 比较两个字符串的大小， a - b   比较的是字典序</p><blockquote><p>一般涉及字符串的大小比较的话，贪心问题</p></blockquote><p><code>strcpy(a, b)</code> 将字符串b复制给a开始的字符数组<br><code>strcat(a, b);</code>  把字符串b拼接到a之后，拼接后的字符串保存在a中</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><blockquote><p>算法题目往往用string 而不是char[]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">string s1;</span><br><span class="line">string s2 = s1;</span><br><span class="line">string s3 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>; <span class="comment">// 1111111111</span></span><br><span class="line"></span><br><span class="line">string 输出 cin  cout</span><br><span class="line">string 用printf输出：<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s1.<span class="built_in">c_str</span>());</span><br><span class="line">string 不能用scanf输入</span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin, s1); <span class="comment">// 读入一行</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">c_str</span>();  <span class="comment">// 转成char数组，此时才可用printf输出</span></span><br><span class="line">s1.<span class="built_in">empty</span>(); <span class="comment">// 字符串为空则返回true，否则false</span></span><br><span class="line">s1.<span class="built_in">size</span>();  <span class="comment">// 返回string长度 O(1) 不包含&#x27;\0&#x27;</span></span><br><span class="line">比较 &gt; &lt; == != 等都支持</span><br><span class="line">string拼接，直接用 + <span class="comment">// 可以加字符串、字符（字符会自动转为string）</span></span><br><span class="line">str.<span class="built_in">substr</span>(begin, length);   <span class="comment">// 子串  下标0开始</span></span><br><span class="line"><span class="comment">// length超过字符串长度则只返回到最后位置  length如果省略也是返回到最后一个字符</span></span><br><span class="line">str.<span class="built_in">back</span>();  <span class="comment">// 返回字符串最后一个字符</span></span><br><span class="line">str.<span class="built_in">pop_back</span>();             <span class="comment">// 删除最后一个字符 </span></span><br><span class="line">str.<span class="built_in">push_back</span>();  <span class="comment">// 向后添加字符</span></span><br></pre></td></tr></table></figure><h4 id="其他类型转为string"><a href="#其他类型转为string" class="headerlink" title="其他类型转为string"></a>其他类型转为string</h4><p>C++11增加了全局函数std::to_string，支持将int、long、long long、unsigned、unsigned long、float、double等转为string类型。</p><h4 id="string转为其他类型-实际上是先转为char"><a href="#string转为其他类型-实际上是先转为char" class="headerlink" title="string转为其他类型 (实际上是先转为char[])"></a>string转为其他类型 (实际上是先转为char[])</h4><p>string转为int – <code>atoi(s.c_str())</code><br>string转为float – <code>atof(s.c_str())</code><br>string转为long – <code>atol(s.c_str())</code></p><h4 id="string拼接中的一个问题"><a href="#string拼接中的一个问题" class="headerlink" title="string拼接中的一个问题"></a>string拼接中的一个问题</h4><p>string拼接，直接用 + // 可以加字符串、字符。<br><strong>但是必须保证每个加法运算符的两侧的运算对象都至少有一个是string。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;.&quot;</span>; <span class="comment">// 正确 string和字符串相加</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 错误，两个运算对象都不是string</span></span><br><span class="line">string s6 = s1 + <span class="string">&#x27;,&#x27;</span> + <span class="string">&quot;hello&quot;</span>; <span class="comment">// 正确，每个加法计算都有一个是string</span></span><br><span class="line">string s7 = <span class="string">&quot;hello&quot;</span> + <span class="string">&#x27;,&#x27;</span> + s1; <span class="comment">// 错误，计算是从左到右的</span></span><br></pre></td></tr></table></figure><h4 id="sstream用法"><a href="#sstream用法" class="headerlink" title="sstream用法"></a>sstream用法</h4><p>更加方便转换string的格式，提取相应信息–特别是<strong>原string中有空格的情况</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">string s = <span class="string">&quot;aaa bb c dd&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ssin</span><span class="params">(s)</span></span>; <span class="comment">// 初始化</span></span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ssin &gt;&gt; str)&#123;&#125; <span class="comment">//  用法与cin一样</span></span><br></pre></td></tr></table></figure><h4 id="string的find方法"><a href="#string的find方法" class="headerlink" title="string的find方法"></a>string的find方法</h4><h5 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h5><p>string中find()返回值是子串在母串中的位置（下标），如果没有找到返回特别的标记npos。（返回值可以看成是一个int型的数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string p = <span class="string">&quot;asd4654asdaxzxdasdrew&quot;</span>, t = <span class="string">&quot;assss&quot;</span>;</span><br><span class="line">cout &lt;&lt; (p.<span class="built_in">find</span>(t) == p.npos) &lt;&lt; endl; <span class="comment">// ()要加 </span></span><br></pre></td></tr></table></figure><h5 id="find-first-of-find-last-of"><a href="#find-first-of-find-last-of" class="headerlink" title="find_first_of()  find_last_of()"></a>find_first_of()  find_last_of()</h5><p>find_first_of() 返回子串在母串中首次出现的位置<br>find_last_of() 返回子串在母串中最后出现的位置</p><h5 id="find-子串-index"><a href="#find-子串-index" class="headerlink" title="find(子串, index)"></a>find(子串, index)</h5><p>查找某个给定位置后(<strong>包括这个位置</strong>)的子串的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string p = <span class="string">&quot;as1111111as1s1asas&quot;</span>, t = <span class="string">&quot;as&quot;</span>;</span><br><span class="line">cout &lt;&lt; p.<span class="built_in">find</span>(t, <span class="number">0</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h5 id="查找所有子串在母串中出现的位置"><a href="#查找所有子串在母串中出现的位置" class="headerlink" title="查找所有子串在母串中出现的位置"></a>查找所有子串在母串中出现的位置</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找s 中flag 出现的所有位置。</span></span><br><span class="line">flag = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((position = s.<span class="built_in">find</span>(flag, position)) != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;position  &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;position&lt;&lt;endl;</span><br><span class="line">    position ++;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反向查找子串在母串中位置-rfind"><a href="#反向查找子串在母串中位置-rfind" class="headerlink" title="反向查找子串在母串中位置 rfind()"></a>反向查找子串在母串中位置 rfind()</h5><p>从后面开始找匹配的，比如p=”123as45as”，t=”as”，p.rfind(t)结果是7。通常我们可以这样来使用，当正向查找与反向查找得到的位置不相同说明子串不唯一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; p.<span class="built_in">rfind</span>(t);</span><br></pre></td></tr></table></figure><h2 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h2><p>类成员默认是private，结构体成员默认是public<br>空默认构造函数默认是给出的，如果写了其他构造函数则不会给出，因此最后写其他构造函数时写一下空构造函数。<br>注意，类与结构体的定义其后面都要加分号。<br>#知识点<br>C++中==类、结构体以及STL中常用的vector、queue、stack、set、map等==都有默认的赋值操作，即默认支持同类型之间进行赋值操作。</p><h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><p><img src="/2022/03/02/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_00%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20220307205653365.png" alt="AcWing考研算法题_00基础知识"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// &amp; 表示取地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// * 表示取指针的值</span></span><br></pre></td></tr></table></figure><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>容器：string, vector, map, stack等<br>#知识点<br>C++中==类、结构体以及STL中常用的vector、queue、stack、set、map等==都有默认的赋值操作，即默认支持同类型之间进行赋值操作。<br>同时，vector、queue、stack、set、map等支持初始化时==赋一系列的值==加入到容器。<br>所有容器都有的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般都支持容器之间的直接赋值</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = v1;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3 = v2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stl.<span class="built_in">size</span>();  <span class="comment">// 返回其中元素个数 例如 str.size();</span></span><br><span class="line">stl.<span class="built_in">empty</span>();  <span class="comment">// 返回是否为空   例如 str.empty();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大部分都有：</span></span><br><span class="line">stl.<span class="built_in">begin</span>();  <span class="comment">// 返回指向容器第一个元素的迭代器</span></span><br><span class="line">stl.<span class="built_in">end</span>();  <span class="comment">// 返回指向容器的最后一个元素的下一个位置的迭代器</span></span><br><span class="line"></span><br><span class="line">stl.<span class="built_in">clear</span>();  <span class="comment">// 除了stack、queue和priority_queue以外都有！</span></span><br><span class="line"></span><br><span class="line">所有容器（除了队列以外）一般都可以遍历</span><br></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><blockquote><p>基于倍增的思想实现，先开n大小的数组，不够就再开2n大小的数组，然后拷贝。<br>效率接近普通数组一半。</p></blockquote><p>vector是变长数组，支持随机访问O(1)，不支持在任意位置O(1)插入，为了保证效率，一般在末尾插入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; b[<span class="number">10</span>];  <span class="comment">// vector数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span></span></span><br><span class="line"><span class="class">&#123;</span> ...</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;rec&gt; c;  <span class="comment">// 结构体vector</span></span><br></pre></td></tr></table></figure><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将vector清空</span></span><br><span class="line">vec.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代器类似STL容器的指针，可以用 * 操作符取到其值<br>声明示例：<br><code>vector&lt;int&gt;::iterator it;</code><br>vector迭代器：随机访问迭代器，可以把该迭代器与整数相加减。可以把两个迭代器相减，结果为两个迭代器对应下标之间距离。</p><h5 id="begin-end"><a href="#begin-end" class="headerlink" title="begin()/end()"></a>begin()/end()</h5><p>vec.begin();  // 返回指向容器第一个元素的迭代器<br>vec.end();  // 返回指向容器的最后一个元素的下一个位置的迭代器</p><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作类似指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++ ) </span><br><span class="line">    cout &lt;&lt; *i &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和string是一样的，:获得的是对应元素值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : a)</span><br><span class="line">cout &lt;&lt; x &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="front-back"><a href="#front-back" class="headerlink" title="front()/back()"></a>front()/back()</h5><p>front()返回vector第一个元素的值。back()返回vector最后一个元素的值。<br>vec.front()等价于vec[0]等价于*vec.begin()<br>vec.back()等价vec[vec.size-1]</p><h5 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h5><p>向最后插入元素，时间复杂度O(1)</p><h5 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back()"></a>pop_back()</h5><p>删除最后一个元素，时间复杂度O(1)</p><h5 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h5><blockquote><p>注：O(n)的时间复杂度，一般不用</p></blockquote><p>常用：<code>insert(迭代器, 插入元素)</code> 会将要插入的元素插入到给定迭代器的前面。<br>元素插入有三种方法。<br>（1） insert (iterator position, const value_type&amp; val)传入的参数是迭代器的位置和需要插入的元素val。<br>Position可以是a.begin()，也可以是a.end()，或者这两者中间的一个迭代器位置<br>（2）void insert (iterator position, size_type n, const value_type&amp; val);<br>在position位置开始，插入n个值为val的元素<br>（3）void insert (iterator position, InputIterator first, InputIterator last);<br>在position位置插入first（比如数组首地址）到last（比如数组首地址+n）之间的元素。</p><h5 id="find-1"><a href="#find-1" class="headerlink" title="find()"></a>find()</h5><p>vector没有自带的find()方法。不过可以通过<code>std::find()</code>来实现查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;类型&gt; v;</span><br><span class="line"></span><br><span class="line">类型::iterator i = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), 目标元素);  <span class="comment">//会返回对应元素的迭代器，如果没有找到返回v.end()</span></span><br></pre></td></tr></table></figure><h5 id="比较符号"><a href="#比较符号" class="headerlink" title="比较符号"></a>比较符号</h5><p><code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>&gt;=</code>、<code>&lt;=</code>等操作，依次每一个元素比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a, b; </span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt; b);</span><br></pre></td></tr></table></figure><p>#技巧<br>如果返回值类型是<code>vector&lt;int&gt;</code>，而实际返回的数是已知，那么可以直接<code>return &#123;值, 值, ... &#125;</code><br>例如返回空的vector，可以 <code>return &#123;&#125;;</code></p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p><code>#include&lt;queue&gt;</code> 头文件中包括循环队列queue和优先队列priority_queue两个容器。<br>queue 是队列，先进先出<br>priority_queue 默认是大根堆，优先向外弹出最大值<br><code>priority_queue&lt;int&gt; q</code><br><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; b;</code> // 小根堆，优先弹出最小值</p><blockquote><p>注意，如果使用priority_queue来存放自己定义的结构体/类，一定要重载小于号（大根堆）/小于号（小根堆）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Rec&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; t.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">priority_queue&lt;Rec&gt; d;</span><br></pre></td></tr></table></figure><h4 id="循环队列queue常用操作"><a href="#循环队列queue常用操作" class="headerlink" title="循环队列queue常用操作"></a>循环队列queue常用操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(); <span class="comment">// 队尾插入一个元素</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 队头弹出一个元素</span></span><br><span class="line">q.<span class="built_in">front</span>(); <span class="comment">// 取队头元素</span></span><br><span class="line">q.<span class="built_in">back</span>();  <span class="comment">// 取队尾元素</span></span><br></pre></td></tr></table></figure><h4 id="优先队列priority-queue常用操作"><a href="#优先队列priority-queue常用操作" class="headerlink" title="优先队列priority_queue常用操作"></a>优先队列priority_queue常用操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pq.<span class="built_in">push</span>(); <span class="comment">// 把元素插入到堆</span></span><br><span class="line">pq.<span class="built_in">pop</span>(); <span class="comment">// 删除堆顶元素</span></span><br><span class="line">pq.<span class="built_in">top</span>(); <span class="comment">// 查询堆顶元素</span></span><br></pre></td></tr></table></figure><h4 id="stack、queue和priority-queue没有clear-函数"><a href="#stack、queue和priority-queue没有clear-函数" class="headerlink" title="stack、queue和priority_queue没有clear()函数"></a>stack、queue和priority_queue没有clear()函数</h4><p>其他容器都有clear()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清除方式：</span><br><span class="line">q = queue&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// 即重新初始化一下</span></span><br></pre></td></tr></table></figure><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>先进后出</p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">push</span>(); <span class="comment">// 栈顶插入一个元素</span></span><br><span class="line">s.<span class="built_in">top</span>();  <span class="comment">// 返回栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();  <span class="comment">// 删除栈顶元素</span></span><br></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双端队列，是一个支持在两端高效插入或删除元素的连续线性存储空间。他就像vector和queue的结合，与vector相比，deque在头部增删元素仅需要O(1)的时间；与queue相比，deque支持像数组一样随机访问。</p><blockquote><p>但是实际上其平均操作效率比较低</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dq[index] <span class="comment">// 随机访问</span></span><br><span class="line">dq.<span class="built_in">begin</span>() dq.<span class="built_in">end</span>()</span><br><span class="line">dq.<span class="built_in">front</span>() <span class="comment">// 队头元素</span></span><br><span class="line">dq.<span class="built_in">back</span>()  <span class="comment">// 队头元素</span></span><br><span class="line">dq.<span class="built_in">push_back</span>()  <span class="comment">// 队尾入队</span></span><br><span class="line">dq.<span class="built_in">push_front</span>()  <span class="comment">// 队头入队</span></span><br><span class="line">dq.<span class="built_in">pop_back</span>()  <span class="comment">// 队尾弹出</span></span><br><span class="line">dq.<span class="built_in">pop_front</span>()  <span class="comment">// 队头弹出</span></span><br><span class="line">dq.<span class="built_in">clear</span>()  <span class="comment">// 清空队列</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>#include&lt;set&gt;</code>包含set和multiset两个容器，分别是“==有序==集合”和“==有序多重==集合”，即前者元素不能重复，而后者可以包含若干个相等的元素。set和multiset内部实现是一棵红黑树，他们支持的函数基本一致。</p><blockquote><p>如果set的元素是结构体/类，注意<strong>重载小于号</strong>，因为set内部是<strong>有序</strong>的（默认从小到大），即有比较操作。</p></blockquote><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="size-empty-clear"><a href="#size-empty-clear" class="headerlink" title="size/empty/clear"></a>size/empty/clear</h5><h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><p>set和multiset的迭代器称为双向迭代器，不支持随机访问（不支持<code>[]</code>），支持星号*解除引用（访问值），支持++和–、==、!=等操作。</p><h5 id="begin-end-1"><a href="#begin-end-1" class="headerlink" title="begin/end"></a>begin/end</h5><p>–s.end()是指向集合中最大元素的迭代器。时间复杂度O(1)</p><h5 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h5><p>s.insert(x)将元素x插入到集合s中，时间复杂度O(logn)<br>在set中，若元素已经存在，则不会插入</p><h5 id="find-2"><a href="#find-2" class="headerlink" title="find"></a>find</h5><p>s.find(x)会在集合中查找等于x的元素，并返回指向该元素的迭代器，若不存在，则返回s.end()。时间复杂度O(logn)。</p><h5 id="lower-bound和upper-bound-二分"><a href="#lower-bound和upper-bound-二分" class="headerlink" title="lower_bound和upper_bound  二分"></a>lower_bound和upper_bound  二分</h5><p>用法与find类似，时间复杂度O(logn)<br>s.lower_bound(x); 找到==大于等于==x的最小的元素的迭代器<br>s.upper_bound(x); 找到==大于==x的最小的元素的迭代器</p><h5 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h5><p>s.erase(it)从s中删除迭代器it指向的元素，时间复杂度O(logn)<br>s.erase(x)从s中删除所有等于x的元素，时间复杂度O(k+logn)，k为删除的个数</p><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>s.count(x) 返回集合中s等于x的元素的个数k，时间复杂度O(k+logn)，k为元素x的个数</p><blockquote><p>注意，因为set不能存在重复元素，所以erase和count的k = 1 或 0</p></blockquote><h3 id="unordered-set-无序的set"><a href="#unordered-set-无序的set" class="headerlink" title="unordered_set 无序的set"></a>unordered_set 无序的set</h3><p><code>#include &lt;unordered_set&gt;</code>中包含unordered_set和unordered_multiset两个结构<br>unordered_set底层实现是哈希表，除了没有lower_bound和upper_bound函数，其他函数与set一致。<br>哈希表效率比较高，一般函数时间复杂度为O(1)，而set中是O(logn)</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>#include&lt;map&gt;</code>包含map和multimap两个容器，<br>map容器是一个键值对的映射，其内部实现是一棵以key为关键码的红黑树。</p><blockquote><p>map内部通过key构建红黑树，所以key必须定义小于号运算符。</p></blockquote><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="size-empty-clear-begin-end均与set类似"><a href="#size-empty-clear-begin-end均与set类似" class="headerlink" title="size/empty/clear/begin/end均与set类似"></a>size/empty/clear/begin/end均与set类似</h5><h5 id="insert-2"><a href="#insert-2" class="headerlink" title="insert"></a>insert</h5><p>与set一样，但是参数是pair&lt;key_type, value_type&gt;<br>同样，map中已存在k1时，插入相同的k1不同value的操作不会执行（不报错，原状态不变）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>));  <span class="comment">// 与上面等价</span></span><br></pre></td></tr></table></figure><h5 id="erase-1"><a href="#erase-1" class="headerlink" title="erase"></a>erase</h5><p>erase(key) 通过键值来删除<br>erase(iterator) 通过迭代器来删除<br>erase(iterator begin, interator end) 通过迭代器删除一个序列</p><blockquote><p>erase的注意事项，在遍历中使用erase时，注意map是关联式容器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; m ;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)) ;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;def&quot;</span>)) ;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;def&quot;</span>)) ;</span><br><span class="line">    m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;ghi&quot;</span>)) ;</span><br><span class="line"> </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator itor ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误的写法</span></span><br><span class="line">    <span class="keyword">for</span> (itor = m.<span class="built_in">begin</span>(); itor != m.<span class="built_in">end</span>(); ++itor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (itor-&gt;second == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m.<span class="built_in">erase</span>(itor) ; <span class="comment">// map是关联式容器，调用erase后，当前迭代器已经失效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的写法</span></span><br><span class="line">    <span class="keyword">for</span> (itor = m.<span class="built_in">begin</span>(); itor != m.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (itor-&gt;second == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m.<span class="built_in">erase</span>(itor++) ; <span class="comment">// erase之后，令当前迭代器指向其后继。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++itor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个正确的写法，利用erase的返回值，注意，有些版本的stl-map没有返回值，比如SGI版，但vc版的有</span></span><br><span class="line">    <span class="keyword">for</span> (itor = m.<span class="built_in">begin</span>(); itor != m.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (itor-&gt;second == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            itor = m.<span class="built_in">erase</span>(itor) ; <span class="comment">// erase的返回值是指向被删除元素的后继元素的迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           ++itor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print m</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::const_iterator citor ;</span><br><span class="line">    <span class="keyword">for</span> (citor = m.<span class="built_in">begin</span>(); citor != m.<span class="built_in">end</span>(); ++citor)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; citor-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; citor-&gt;second &lt;&lt; endl ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>() ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="count-1"><a href="#count-1" class="headerlink" title="count"></a>count</h5><p>m.count(k)通过k值来查找map中是否存在key值等于k的数据，如果存在返回1，不存在返回0。</p><h5 id="find-3"><a href="#find-3" class="headerlink" title="find"></a>find</h5><p>m.find(key) 通过key值来查找对应元素，返回的是元素的迭代器 </p><h5 id="操作符"><a href="#操作符" class="headerlink" title="[]操作符"></a>[]操作符</h5><p>m[key] 返回key映射的value的引用，时间复杂度为O(logn)<br>我们可以很方便地通过m[key]来得到key对应的value，还可以对m[key]进行赋值操作，改变key对应的value</p><blockquote><p>m[key]++; 或 ++ m[key]操作，如果key之前不存在，会默认value值为0，然后进行相应操作。</p></blockquote><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [k, v]: m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; k &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>同样是hash表，不可做二分，然后函数时间复杂度一般是O(1)</p><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>支持位运算的容器，用来存储很长的二进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;1000&gt; a, b; <span class="comment">// 定义  中括号中是长度</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 可以赋值1或0</span></span><br><span class="line">cout &lt;&lt; b[<span class="number">2</span>];  <span class="comment">// 没有赋值的默认是0</span></span><br><span class="line"></span><br><span class="line">b.<span class="built_in">count</span>();  <span class="comment">// 返回b中1的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持位运算  按照每一位去做</span></span><br><span class="line">a &amp;= b;</span><br><span class="line">a |= b;</span><br><span class="line"></span><br><span class="line">b.<span class="built_in">set</span>(index);  <span class="comment">// 将index下标设为1</span></span><br><span class="line">b.<span class="built_in">reset</span>(index);  <span class="comment">// 将index下标设为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有clear()函数</span></span><br></pre></td></tr></table></figure><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, string&gt; a, b; <span class="comment">// 定义</span></span><br><span class="line">a = &#123;<span class="number">3</span>, <span class="string">&quot;hello&quot;</span>&#125;;  <span class="comment">// 赋值</span></span><br><span class="line">b = <span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>);  <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.second &lt;&lt; endl; <span class="comment">// .first返回第一个值</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a &gt; b; <span class="comment">// pair中实现了pair之间的大于、小于、等于等操作，比较：先比较第一个数，再比较第二个</span></span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><table><thead><tr><th>操作</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>与AND</td><td>&amp;</td><td>同1为1</td></tr><tr><td>或OR</td><td>|</td><td>有1为1</td></tr><tr><td>取反NOT</td><td>~</td><td></td></tr><tr><td>异或XOR</td><td>^</td><td>相同为1</td></tr><tr><td>左移</td><td>&lt;&lt;</td><td>等价于乘$2^k$</td></tr><tr><td>右移</td><td>&gt;&gt;</td><td>等价于除$2^k$</td></tr><tr><td>两个整数进行位运算  == 对每一位分别进行位运算</td><td></td><td></td></tr></tbody></table><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="求x的第k位数字（从低位开始看）-x-gt-gt-k-amp-1"><a href="#求x的第k位数字（从低位开始看）-x-gt-gt-k-amp-1" class="headerlink" title="求x的第k位数字（从低位开始看） x &gt;&gt; k &amp; 1"></a>求x的第k位数字（从低位开始看） x &gt;&gt; k &amp; 1</h4><p><img src="/2022/03/02/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_00%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20220308195714030.png" alt="image-20220308195714030"></p><h4 id="lowbit-x-x-amp-x-返回x的最后一位的1"><a href="#lowbit-x-x-amp-x-返回x的最后一位的1" class="headerlink" title="lowbit(x) = x &amp; -x  返回x的最后一位的1"></a>lowbit(x) = x &amp; -x  返回x的最后一位的1</h4><p>x &amp; -x 等价于 x &amp; (~x + 1)</p><p><img src="/2022/03/02/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_00%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20220308195854999.png" alt="image-20220308195854999"></p><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h3 id="第一类双指针算法"><a href="#第一类双指针算法" class="headerlink" title="第一类双指针算法"></a>第一类双指针算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; str[j] == str[i])</span><br><span class="line">j++;</span><br><span class="line">i = j - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换两个相同类型(int, double, string, char等)的数据</span></span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// string 转 其他类型   -- 实质是char[]转；如果首字母不能转为目标类型会输出0</span></span><br><span class="line"><span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>()); <span class="comment">// int</span></span><br><span class="line"><span class="built_in">atof</span>(str.<span class="built_in">c_str</span>()); <span class="comment">// float</span></span><br><span class="line"><span class="built_in">atol</span>(str.<span class="built_in">c_str</span>()); <span class="comment">// long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string 转 其他类型    -- 如果首字母不能转为目标类型会抛出异常</span></span><br><span class="line"><span class="built_in">stoi</span>(str); <span class="comment">// int</span></span><br><span class="line"><span class="built_in">stof</span>(str); <span class="comment">// float</span></span><br><span class="line"><span class="built_in">stol</span>(str); <span class="comment">// long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他类型转string</span></span><br><span class="line"><span class="built_in">to_string</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断char是否为十进制数</span></span><br><span class="line"><span class="built_in">isdigit</span>(c);</span><br><span class="line"><span class="comment">// 判断char是否为字母</span></span><br><span class="line"><span class="built_in">isalpha</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字母char大小写转换</span></span><br><span class="line"><span class="comment">// 注意事项：这两个函数返回值是int型，需要(char)强转为char型</span></span><br><span class="line"><span class="built_in">tolower</span>(c);  <span class="comment">// 将字母c转为小写，如果不是字母则不变</span></span><br><span class="line"><span class="built_in">toupper</span>(c);  <span class="comment">// 将字母c转为大写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="reverse-翻转"><a href="#reverse-翻转" class="headerlink" title="reverse 翻转"></a>reverse 翻转</h3><p>可以翻转：数组、字符串、vector。时间复杂度：O(n)<br>注意第二项是最后一个元素的下一个位置！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(vec.begin, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(a, a + 长度);  <span class="comment">// a[6] 第二项 a + 6</span></span><br></pre></td></tr></table></figure><h3 id="unique-去重"><a href="#unique-去重" class="headerlink" title="unique 去重"></a>unique 去重</h3><p>进行去重操作，然后返回去重之后的尾迭代器/指针，这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。</p><blockquote><p>注意：unique去重的前提条件是相同元素已经放到了一起，否则不相邻的重复数据不会被去除</p></blockquote><p>把一个vector去重:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) - v.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>把一个数组去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="built_in">unique</span>(a, a + n) - a;</span><br></pre></td></tr></table></figure><p>vector、数组去重之后，都是将去重后的数据放到前半部分，但是后半部分没有用到的数据空间也不会删除，而是保留下来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> e = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : a)        <span class="comment">//  输出是 1 2 1 3 5 6 5 6</span></span><br><span class="line">    cout &lt;&lt; i;        <span class="comment">//  没有相邻的相同数不会删除，后半部分空间未释放</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">size</span>();  <span class="comment">//  输出是 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i != e; ++i) <span class="comment">//  输出是 1 2 1 3 5 6</span></span><br><span class="line">        cout &lt;&lt; *i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案 2   释放后半部分空间（推荐）</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;)</span></span>; </span><br><span class="line"></span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><p>随机种子默认是0，一般设置时间为随机种子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// time(0)返回当前时间到1970年1月1日的秒数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">random_shuffle</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>不稳定排序，默认是从小到大排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认 不稳定排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;&#125;  <span class="comment">// a是否应该在b前面</span></span><br></pre></td></tr></table></figure><p>对结构体排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Rec a, Rec b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rec1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Rec &amp;t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; b[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x = -i;</span><br><span class="line">        a[i].y = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d ,%d) &quot;</span>, a[i].x, a[i].y);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + <span class="number">5</span>, cmp);</span><br><span class="line">    <span class="comment">// sort(b, b+5); // 重载小于号也是可以的（默认调用小于号）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d ,%d) &quot;</span>, a[i].x, a[i].y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lower-bound-upper-bound-二分"><a href="#lower-bound-upper-bound-二分" class="headerlink" title="lower_bound/upper_bound 二分"></a>lower_bound/upper_bound 二分</h3><p><code>lower_bound(开始的迭代器/指针, 结束的迭代器/指针, x)</code><br>lower_bound的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。<br>upper_bound与lower_bound基本一致，区别在于它查找的是第一个大于x的元素。</p><blockquote><p>注意：这两个函数操作的对象都应该是提前排好序的！</p></blockquote><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h3><p><code>next_permutation(开始的迭代器，结束的迭代器)</code><br>这个函数对传入的vector（或其他容器）的数据进行排序，返回下一种排序可能（默认按照数值从小到大的进行），返回值是是否为排序的最大情况，如果是返回true，否则返回false。（所以如果想获得所有的排序结果，需要先将vector按从小到大排列（即排列数值最小的情况））</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.acwing.com/problem/content/47/</span></span><br><span class="line"><span class="comment">// 数据排列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permutation</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">do</span> res.<span class="built_in">push_back</span>(nums); <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h3><p>它是STL里面的函数，使用时需要包含头文件&lt;algorithm&gt;<br><code>void nth_element (Iterator first, Iterator first+nth, Iterator last, Compare cmp);</code><br>重新排列range[first,last)中的元素，使第n个位置的元素是按排序cmp顺序的第n个位置的元素，即第n大/小的数放到了第n个位置上<br>不过其他元素没有任何特定的顺序，只是第n个元素之前的元素都不大于该元素，而第n个元素后面的元素均不小于该元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;68542931&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">random_shuffle</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="built_in">nth_element</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>()+<span class="number">2</span>, str.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//  28356914</span></span><br><span class="line"><span class="comment">//  21345698</span></span><br></pre></td></tr></table></figure><h2 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h2><p>$$<br>(x * y) % m = ((x % m) * (y % m)) % m\=x%m<em>y%m<br>$$<br>$x%m</em>y%m$按照优先级，%优先级等于*，所以是从左到右，先取模再乘最后再取模。（注：这种写法不具有普遍性，需要保证x%m*y没有溢出，即y值相对较小时）</p><h2 id="sort-函数只能对支持随机访问迭代器的容器排序"><a href="#sort-函数只能对支持随机访问迭代器的容器排序" class="headerlink" title="sort()函数只能对支持随机访问迭代器的容器排序"></a>sort()函数只能对支持随机访问迭代器的容器排序</h2><p>踩坑记录：sort()函数不能用来对map、unordered_map、set、unordered_set进行排序，因为这些容器迭代器都是双向迭代器，而sort函数要求迭代器类型是随机访问迭代器。同样stack、queue等不支持迭代器，也不可以用sort排序。<br>对于unordered_map等，可以将元素取出放入vector，排完序以后再放回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second &lt; b.second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.second == b.second) <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string, <span class="keyword">int</span>&gt; msi;</span><br><span class="line">    msi[<span class="string">&quot;apple&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    msi[<span class="string">&quot;watermelon&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    msi[<span class="string">&quot;pear&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    msi[<span class="string">&quot;peach&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">    msi[<span class="string">&quot;cherry&quot;</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt; <span class="built_in">vpi</span>(msi.<span class="built_in">begin</span>(), msi.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(vpi.<span class="built_in">begin</span>(), vpi.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item: vpi)&#123;</span><br><span class="line">        cout &lt;&lt; item.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">watermelon 2</span></span><br><span class="line"><span class="comment">pear 3</span></span><br><span class="line"><span class="comment">apple 5</span></span><br><span class="line"><span class="comment">peach 5</span></span><br><span class="line"><span class="comment">cherry 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>vector&lt;pair&lt;string, int&gt;&gt; vpi(msi.begin(), msi.end());</code><br>初始化vector时，直接通过首尾两个迭代器进行赋值。</p><h2 id="sort对二维数组进行排序"><a href="#sort对二维数组进行排序" class="headerlink" title="sort对二维数组进行排序"></a>sort对二维数组进行排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a[i], a[i] + <span class="number">10</span>); <span class="comment">// 对数组的第i行进行排序</span></span><br></pre></td></tr></table></figure><h2 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h2><p>计算机对于浮点数存储是有精度损失的，特别是计算完浮点数以后再转为int时更容易出现截断损失问题，比如浮点数存储计算结果1有可能存储的是0.999999，转为int型时就可能截断为0。<br>#技巧 浮点数放大法转为int再进行计算<br>例如下面换零钱，因为小数位只有两位，结合数据范围，所以所有数据放大100倍也不会超过int的限制，因此可以数据放大100倍把浮点数变为整数，然后再计算。<br><a href="https://www.acwing.com/problem/content/description/658/">656. 钞票和硬币 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">int</span> m=x*<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">12</span>]=&#123;<span class="number">10000</span>,<span class="number">5000</span>,<span class="number">2000</span>,<span class="number">1000</span>,<span class="number">500</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">25</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NOTAS:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d nota(s) de R$ %.2lf\n&quot;</span>,m/a[i],(<span class="keyword">double</span>)a[i]/<span class="number">100.00</span>);</span><br><span class="line">        m%=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;MOEDAS:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">6</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d moeda(s) de R$ %.2lf\n&quot;</span>,m/a[i],(<span class="keyword">double</span>)a[i]/<span class="number">100.00</span>);</span><br><span class="line">        m%=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-02线性表；日期问题</title>
      <link href="2022/03/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_02%E7%BA%BF%E6%80%A7%E8%A1%A8_%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
      <url>2022/03/01/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_02%E7%BA%BF%E6%80%A7%E8%A1%A8_%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><blockquote><p>注意！笔试时手写代码的线性表需要用指针形式实现，但是上机一定不要用指针，因为很容易超时！==上机时线性表最好采用数组形式！==</p></blockquote><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><ol><li><p>将具有线性关系的数据存储到计算机中所使用的存储结构称为线性表。</p><p>==逻辑结构！==</p><span id="more"></span></li><li><p>对于线性表中的数据来说，位于当前数据之前的<strong>所有数据</strong>统称为“前趋元素”，前边紧挨着的数据称为“直接前趋”；同样，后边的<strong>所有数据</strong>统称为“后继元素”，后边紧挨着的数据称为“直接后继”。</p></li><li><p>线性表的分类<br> (1) 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；</p><pre><code> 例如：数组</code></pre><p> (2) 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”。</p><pre><code> 例如：单链表、双链表、循环单（双）链表</code></pre></li><li><p>不同实现方式的时间复杂度（不要硬背结论、要从实现方式入手分情况讨论，下述为特定情况下的时间复杂度）<br> (1) 数组：随机索引O(1)、插入O(n)、删除O(n)<br> (2) 单链表：查找某一元素O(n)、插入O(1)、删除O(n)</p><blockquote><p>注意:</p><ul><li><p>这里插入指的是在当前节点之后插入节点，如果是在当前节点之前插入节点，时间复杂度是O(n)</p></li><li><p>这里删除指的是删除当前节点，如果是删除下一个节点，时间复杂度是O(1)</p></li></ul></blockquote><p> (3) 双链表：查找某一元素O(n)、插入O(1)、删除O(1)</p><blockquote><p>注意链表删除后，要delete释放节点空间。</p></blockquote></li></ol><p>考题：2016-1、2016-2、2012-42、2015-41、2019-41</p><p>2012-42</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针实现单链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next)</span><br><span class="line">        cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    head-&gt;next = a;</span><br><span class="line">    a-&gt;next = b;</span><br><span class="line">    <span class="built_in">print</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针实现双链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *prev, *next;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(): <span class="built_in">prev</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val): <span class="built_in">val</span>(_val), <span class="built_in">prev</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next)</span><br><span class="line">        cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head = <span class="literal">NULL</span>, *tail = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/62/">66. 两个链表的第一个公共结点 - AcWing题库</a></p><blockquote><p>很妙的解法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">findFirstCommonNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q= headB;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(p!=q)&#123;</span><br><span class="line">            p = p?p-&gt;next:headB;</span><br><span class="line">            q = q?q-&gt;next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2015-41</p><p>unordered_set中底层是哈希表，count平均时间复杂度是O(1)；但是set底层是红黑树，count时间复杂度就是O(logN)了。</p><p><strong>unordered_set解法</strong>  空间复杂度O(max(m,n))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">filterList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;<span class="comment">//定义p指针指向头结点</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//建立哈希表，存只出现一次的数的绝对值</span></span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">abs</span>(head-&gt;val));<span class="comment">//首先第一个节点是一定需要插入的</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//判断指针指向的下一个节点是否出现过，如果出现过则删除</span></span><br><span class="line">        <span class="comment">//(删除下一个点方便很多，如果要求删除自己这个点会比较麻烦)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">count</span>(<span class="built_in">abs</span>(p-&gt;next-&gt;val))==<span class="number">0</span>)<span class="comment">//查询这个节点的绝对值是否在哈希表中出现过，count查询这个值的出现次数</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(<span class="built_in">abs</span>(p-&gt;next-&gt;val));<span class="comment">//如果没有出现则插入这个节点的绝对值</span></span><br><span class="line">                p=p-&gt;next;<span class="comment">//保留这个点，指针向后移动一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> q=p-&gt;next;<span class="comment">//如果已经出现过，先记录下这个需要删除的点</span></span><br><span class="line">                p-&gt;next=q-&gt;next;<span class="comment">//使p-&gt;next指向需要删除的点的下一个点</span></span><br><span class="line">                <span class="keyword">delete</span> q;<span class="comment">//删除它</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>额外数组解法</strong> 空间复杂度O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">filterList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> st[<span class="number">10001</span>]=&#123;&#125;; <span class="comment">// 初始化为false</span></span><br><span class="line">        </span><br><span class="line">        st[<span class="built_in">abs</span>(head-&gt;val)]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环判断下一个数据是否已经存在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p=head; p-&gt;next;)  <span class="comment">//  p = p-&gt;next不能写在这里!!!</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="built_in">abs</span>(p-&gt;next-&gt;val)])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                st[<span class="built_in">abs</span>(p-&gt;next-&gt;val)]=<span class="literal">true</span>;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2019-41</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://www.acwing.com/problem/content/3760/</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rearrangedList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特处  注意！！！</span></span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 双指针找中间节点</span></span><br><span class="line">        <span class="keyword">auto</span> p = head, q = head -&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(q&amp;&amp;q-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(!q-&gt;next)  <span class="comment">// 注意，这里是!q-&gt;next 不是q-&gt;next</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l1 = head, l2 = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 翻转后半部分链表获得反序链表</span></span><br><span class="line">        p = l2;</span><br><span class="line">        q = l2 -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(q)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            p -&gt; next = q -&gt; next;</span><br><span class="line">            q -&gt; next = l2;</span><br><span class="line">            l2 = q;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 将两个链表合并</span></span><br><span class="line">        head = l1;</span><br><span class="line">        l1 = l1 -&gt; next;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2 -&gt; next;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            </span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1 -&gt; next;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 特处</span></span><br><span class="line">            <span class="keyword">if</span>(!l1)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!l2)&#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="押题"><a href="#押题" class="headerlink" title="押题"></a>押题</h4><p><a href="https://www.acwing.com/problem/content/86/">34. 链表中环的入口结点 - AcWing题库</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">1451.</span> 单链表快速排序 - AcWing题库](https:<span class="comment">//www.acwing.com/problem/content/1453/)</span></span><br><span class="line"></span><br><span class="line">```c++</span><br></pre></td></tr></table></figure><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><blockquote><p>模板</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每月天数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> months[<span class="number">13</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;; <span class="comment">// 这里;别忘了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断闰年</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_leap</span><span class="params">(<span class="keyword">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> || year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求y年m月有多少天</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_days</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> months[m] + <span class="built_in">is_leap</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> months[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing考研算法题-01时间复杂度、矩阵展开；排序、进位制</title>
      <link href="2022/02/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_01%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6_%E7%9F%A9%E9%98%B5%E5%B1%95%E5%BC%80_%E6%8E%92%E5%BA%8F_%E8%BF%9B%E4%BD%8D%E5%88%B6/"/>
      <url>2022/02/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_01%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6_%E7%9F%A9%E9%98%B5%E5%B1%95%E5%BC%80_%E6%8E%92%E5%BA%8F_%E8%BF%9B%E4%BD%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="考纲"><a href="#考纲" class="headerlink" title="考纲"></a>考纲</h2><p>一、线性表<br>    （一）线性表的定义和基本操作<br>    （二）线性表的实现<br>        1. 顺序存储<br>        2. 链式存储<br>        3. 线性表的应用<br>二、栈、队列和数组<br>    （一）栈和队列的基本概念<br>    （二）栈和队列的顺序存储结构<br>    （三）栈和队列的链式存储结构<br>    （四）栈和队列的应用<br>    （五）特殊矩阵的存储和压缩</p><span id="more"></span> 三、树与二叉树<pre><code>（一）树的基本概念（二）二叉树    1. 二叉树的定义及其主要特征    2. 二叉树的顺序存储结构和链式存储结构    3. 二叉树的遍历    4. 线索二叉树的基本概念和构造（三）树、森林    1. 树的存储结构    2. 森林与二叉树的转换    3. 树和森林的遍历（四）树与二叉树的应用    1. 二叉排序树    2. 平衡二叉树    3. 哈夫曼（Huffman）树的哈弗曼编码</code></pre><p>四、图<br>    （一）图的基本概念<br>    （二）图的存储及基本操作<br>        1. 邻接矩阵法<br>        2. 邻接表法<br>        3. 邻接多重表、十字链表<br>    （三）图的遍历<br>        1. 深度优先搜索<br>        2. 广度优先搜索<br>    （四）图的基本应用<br>        1. 最小（代价）生成树<br>        2. 最短路径<br>        3. 拓扑排序<br>        4. 关键路径<br>五、查找<br>    （一）查找的基本概念<br>    （二）顺序查找法<br>    （三）分块查找法<br>    （四）折半查找法<br>    （五）B树及其基本操作、B+树及其基本概念<br>    （六）散列（Hash）表<br>    （七）字符串模式匹配（KMP）<br>    （八）查找算法的分析及应用<br>六、排序<br>    （一）排序的基本概念<br>    （二）插入排序<br>        1. 直接插入排序<br>        2. 折半插入排序<br>    （三）起泡排序（bubble sort）<br>    （四）简单选择排序<br>    （五）希尔排序（shell sort）<br>    （六）快速排序<br>    （七）堆排序<br>    （八）二路归并排序（merge sort）<br>    （九）基数排序<br>    （十）外部排序<br>    （十一）各种内部排序算法的比较<br>    （十二）排序算法的应用</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度：只考虑次数、不考虑常数</p><p>常见复杂度：O(1)、O(n)、O(sqrt(n))、O(n^k)、O(logn)、O(nlogn)</p><p>考题：2011-1、2012-1、2013-1、2014-1、2017-1、2019-1</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2022/02/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_01%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6_%E7%9F%A9%E9%98%B5%E5%B1%95%E5%BC%80_%E6%8E%92%E5%BA%8F_%E8%BF%9B%E4%BD%8D%E5%88%B6/image-20220228192200445.png" alt="2013-1"></p><p>D</p><p>本质：两个链表进行归并</p><ul><li>归并是线性的</li><li>两个链表上两个指针向后移动，最后其中一个走到最后即结束</li></ul><p>最坏时间复杂度：O(m+n)</p><blockquote><p>O(max(m,n))=O(m+n)</p><p>例：如n$\geq$m，则$2n\geq max(m, n)\geq n$，O(max(m,n))=O(m+n)=O(n)</p></blockquote><h2 id="矩阵展开"><a href="#矩阵展开" class="headerlink" title="矩阵展开"></a>矩阵展开</h2><p>矩阵的按行展开、按列展开，展开后下标从0开始</p><p>考题：2016-4、2018-3、2020-1</p><ul><li><p>上三角矩阵：矩阵的右上三角形有数据</p><p><img src="/2022/02/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_01%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6_%E7%9F%A9%E9%98%B5%E5%B1%95%E5%BC%80_%E6%8E%92%E5%BA%8F_%E8%BF%9B%E4%BD%8D%E5%88%B6/image-20220228195443847.png" alt="上三角矩阵"></p></li></ul><blockquote><p>高斯求和公式：和=（首项+尾项）*项数/2</p></blockquote><ul><li><p>三对角矩阵：三条对角线有数据</p><img src="/2022/02/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_01%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6_%E7%9F%A9%E9%98%B5%E5%B1%95%E5%BC%80_%E6%8E%92%E5%BA%8F_%E8%BF%9B%E4%BD%8D%E5%88%B6/image-20220228200418610.png" alt="三对角矩阵" style="zoom:50%;"></li></ul><blockquote><p>2+3*（行数-1）+列数-行数+1</p></blockquote><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><img src="/2022/02/28/AcWing%E8%80%83%E7%A0%94%E7%AE%97%E6%B3%95%E9%A2%98_01%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6_%E7%9F%A9%E9%98%B5%E5%B1%95%E5%BC%80_%E6%8E%92%E5%BA%8F_%E8%BF%9B%E4%BD%8D%E5%88%B6/image-20220228201809357.png" alt="2020-1"></p><p>C</p><blockquote><p>注意：对称矩阵 –&gt; 求m<sub>7,2</sub>的存储位置，即m<sub>2,7</sub>的存储位置</p></blockquote><h1 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>==稳定排序==：相同元素排序前后位置不发生变化</p><ul><li>稳定排序：归并排序</li><li>不稳定排序：快排、堆排序</li></ul><p>C++中提供的==sort==是<strong>不稳定排序</strong>。如果想要实现稳定排序，两种方案：</p><ol><li>采用多关键字排序，将开始的下标也作为排序基础，当两个数值相同时，比较下标，下标小的放前面</li><li>采用C++提供的==stable_sort==排序，其内在实现是归并排序（<strong>稳定排序</strong>）</li></ol><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="3375-成绩排序-AcWing题库"><a href="#3375-成绩排序-AcWing题库" class="headerlink" title="3375. 成绩排序 - AcWing题库"></a><a href="https://www.acwing.com/problem/content/3378/">3375. 成绩排序 - AcWing题库</a></h4><p>stable_sort</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体的排序方式</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Person &amp;t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score &lt; t.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Person &amp;t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score &gt; t.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 分隔符：空格、回车、制表符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q[i].name &gt;&gt; q[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="comment">// 从高到低排序</span></span><br><span class="line">        <span class="built_in">stable_sort</span>(q, q + n, greater&lt;Person&gt;());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">stable_sort</span>(q, q + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; q[i].name &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; q[i].score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort + 多关键字排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体的排序方式</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Person &amp;t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(score!=t.score) <span class="keyword">return</span> score &lt; t.score;</span><br><span class="line">        <span class="keyword">return</span> id &lt; t.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Person &amp;t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(score!=t.score) <span class="keyword">return</span> score &gt; t.score;</span><br><span class="line">        <span class="keyword">return</span> id &lt; t.id; <span class="comment">// 将开始的id小的排在前面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 分隔符：空格、回车、制表符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q[i].name &gt;&gt; q[i].score;</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="comment">// 从高到低排序</span></span><br><span class="line">        <span class="built_in">sort</span>(q, q + n, greater&lt;Person&gt;());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sort</span>(q, q + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; q[i].name &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; q[i].score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><a href="https://www.acwing.com/problem/content/3377/">3374. 进制转换2 - AcWing题库</a></p><p>a进制转为b进制+高精度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[s.<span class="built_in">size</span>() - i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 注意！为便于计算，都转换为10进制存入到int中</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            A.<span class="built_in">push_back</span>(c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        res = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (A.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 除  求余数与商</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 直接将余数存储到A中</span></span><br><span class="line">                A[i] += r * a;</span><br><span class="line">                r = A[i] % b;</span><br><span class="line">                A[i] /= b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (A.<span class="built_in">size</span>() &amp;&amp; A.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">                A.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">// 注意！判断是否要用a-z表示</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">10</span>)</span><br><span class="line">                res += <span class="built_in">to_string</span>(r);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += r - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing考研算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 考研算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liking起始页搭建日记[前端]-05常用应用</title>
      <link href="2022/02/14/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_05%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/"/>
      <url>2022/02/14/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_05%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="Draggable实现可拖拽式的常用页"><a href="#Draggable实现可拖拽式的常用页" class="headerlink" title="Draggable实现可拖拽式的常用页"></a>Draggable实现可拖拽式的常用页</h2>]]></content>
      
      
      <categories>
          
          <category> Liking起始页搭建日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liking </tag>
            
            <tag> Vue </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo基础使用和报错记录</title>
      <link href="2022/02/09/Hexo%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%92%8C%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
      <url>2022/02/09/Hexo%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%92%8C%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-b"><a href="#YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-b" class="headerlink" title="YAMLException: can not read a block mapping entry; a multiline key may not b"></a>YAMLException: can not read a block mapping entry; a multiline key may not b</h2><p>报错信息：</p><p>YAMLException: can not read a block mapping entry; a multiline key may not b</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: [转]--ISP（图像信号处理）算法概述、工作原理、架构、处理流程</span><br><span class="line">date: 2020-03-22 21:39:40</span><br><span class="line">tags: [图像处理]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><span id="more"></span><p>报错位置是第2行第5位<br>意思是我的date: 2020-03-22 21:39:40这块时间冒号后面没有空格，<br>这块反复确认过，是没有问题，我转头看标题，可能是[转]括号不太行</p><p>修正为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &lt;转&gt;--ISP（图像信号处理）算法概述、工作原理、架构、处理流程</span><br><span class="line">date: 2020-03-22 21:39:40</span><br><span class="line">tags: [图像处理]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>[]改为&lt;&gt;，报错信息消失，可以正常生成html文件预览</p><blockquote><p>另外注意</p><p><code>title: </code>       <code>date: </code>        <code>tags: </code></p><p>:冒号后面都要加空格，哪怕是多个tags，然后分行写，冒号后也要有空格</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">  -</span> [图像处理]</span><br><span class="line"><span class="bullet">  -</span> AI</span><br><span class="line">---</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liking起始页搭建日记[前端]-04swiper轮播图</title>
      <link href="2022/02/09/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_04%E8%BD%AE%E6%92%AD%E5%9B%BESwiper/"/>
      <url>2022/02/09/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_04%E8%BD%AE%E6%92%AD%E5%9B%BESwiper/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>官网：<a href="https://swiperjs.com/vue">刷卡器 Vue.js 组件 (swiperjs.com)</a></p><h2 id="下载swiper插件"><a href="#下载swiper插件" class="headerlink" title="下载swiper插件"></a>下载swiper插件</h2><p>Swiper Vue.js插件只能通过NPM作为主Swiper库的一部分使用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">npm</span> i swiper@<span class="number">7</span>.<span class="number">2</span>.<span class="number">0</span> --save</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><a href="https://blog.csdn.net/weixin_42063951/article/details/121354984?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_default&utm_relevant_index=5">vue3中使用swiper7_weianl的博客-CSDN博客_vue使用swiper7</a></p><span id="more"></span><h2 id="keep-alive介绍与应用"><a href="#keep-alive介绍与应用" class="headerlink" title="keep-alive介绍与应用"></a>keep-alive介绍与应用</h2><h3 id="keep-alive是什么"><a href="#keep-alive是什么" class="headerlink" title="keep-alive是什么"></a>keep-alive是什么</h3><blockquote><p>keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p></blockquote><h3 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景"></a>一个场景</h3><p>用户在某个列表页面选择筛选条件过滤出一份数据列表，由列表页面进入数据详情页面，再返回该列表页面，我们希望：列表页面可以保留用户的筛选（或选中）状态。<br> keep-alive就是用来解决这种场景。当然keep-alive不仅仅是能够保存页面/组件的状态这么简单，它还可以避免组件反复创建和渲染，有效提升系统性能。总的来说，<strong>keep-alive用于保存组件的渲染状态。</strong></p><h3 id="keep-alive用法"><a href="#keep-alive用法" class="headerlink" title="keep-alive用法"></a>keep-alive用法</h3><ul><li>在动态组件中的应用</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;whiteList&quot;</span> <span class="attr">:exclude</span>=<span class="string">&quot;blackList&quot;</span> <span class="attr">:max</span>=<span class="string">&quot;amount&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在vue-router中的应用</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;whiteList&quot;</span> <span class="attr">:exclude</span>=<span class="string">&quot;blackList&quot;</span> <span class="attr">:max</span>=<span class="string">&quot;amount&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>include</strong>定义缓存白名单，keep-alive会缓存命中的组件；<strong>exclude</strong>定义缓存黑名单，被命中的组件将不会被缓存；<strong>max</strong>定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。</p><blockquote><p><a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5633616">内存管理</a>的一种页面置换算法，对于在内存中但又不用的<a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%9D%97/107672">数据块</a>（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。</p></blockquote><p>链接：<a href="https://www.jianshu.com/p/9523bb439950">https://www.jianshu.com/p/9523bb439950</a></p><h2 id="Vue路由转换动态效果"><a href="#Vue路由转换动态效果" class="headerlink" title="Vue路由转换动态效果"></a>Vue路由转换动态效果</h2><p><a href="https://segmentfault.com/a/1190000040935668">用了很多动效，介绍 4个很 Nice 的 Vue 路由过渡动效！ - SegmentFault 思否</a></p><blockquote><p>最后还是选择通过swiper切换组件，而不是切换路由，因为切换组件可以保留用户输入的信息</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Liking起始页搭建日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liking </tag>
            
            <tag> Vue </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liking起始页搭建日记[前端]-03搜索页</title>
      <link href="2022/02/05/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_03%E6%90%9C%E7%B4%A2%E9%A1%B5/"/>
      <url>2022/02/05/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_03%E6%90%9C%E7%B4%A2%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="js设置输入框失去光标（onblur）与光标选中（onfocus）时样式"><a href="#js设置输入框失去光标（onblur）与光标选中（onfocus）时样式" class="headerlink" title="js设置输入框失去光标（onblur）与光标选中（onfocus）时样式"></a>js设置输入框失去光标（onblur）与光标选中（onfocus）时样式</h2><h3 id="onfocus事件"><a href="#onfocus事件" class="headerlink" title="onfocus事件"></a>onfocus事件</h3><p>onfocus 属性在元素获得焦点时触发。</p><p>onfocus 常用于 <input>、<select> 以及 <a>.</a></select></p><p><strong>提示：</strong>onfocus 属性与 onblur 属性相反。</p><p><strong>注释：</strong>onfocus 属性不适用于以下元素：<base>、<bdo>、<br>、<head>、<html>、<iframe>、<meta>、<param>、<script>、<style> 或 <title>。</p><span id="more"></span><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">onfocus</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>script</em></td><td align="left">onfocus 发生时运行的脚本。</td></tr></tbody></table><h3 id="onblur事件"><a href="#onblur事件" class="headerlink" title="onblur事件"></a>onblur事件</h3><p>onblur 属性在元素失去焦点时触发。</p><p>onblur 常用于表单验证代码（例如用户离开表单字段）。</p><p><strong>提示：</strong>onblur 属性与 onfocus 属性相反。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">onblur</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性值-1"><a href="#属性值-1" class="headerlink" title="属性值"></a>属性值</h4><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>script</em></td><td align="left">onblur 发生时运行的脚本。</td></tr></tbody></table><h3 id="Vue中-blur和-focus"><a href="#Vue中-blur和-focus" class="headerlink" title="Vue中@blur和@focus"></a>Vue中@blur和@focus</h3><p>@blur 是当元素失去焦点时所触发的事件</p><p>@focus是元素获取焦点时所触发的事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    @blur 当元素失去焦点时触发blur事件</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入内容&quot; @blur&#x3D;&quot;blurText&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      name: &quot;commitText&quot;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        blurText()&#123;</span><br><span class="line">          console.log(&quot;blur事件被执行了&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/weixin_42246997/article/details/103749770">https://blog.csdn.net/weixin_42246997/article/details/103749770</a></p><h2 id="class-a-hover时改变class-a子元素样式"><a href="#class-a-hover时改变class-a子元素样式" class="headerlink" title="class_a:hover时改变class_a子元素样式"></a>class_a:hover时改变class_a子元素样式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.class_a:hover .class_b&#123;</span><br><span class="line">  color: rgba(77, 77, 77, 0.75);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>.class_a:hover ~ .class_b  必须是class_b不是class_a的子元素才生效</p></blockquote><h2 id="CSS3毛玻璃效果-blur-有白边问题的解决方法"><a href="#CSS3毛玻璃效果-blur-有白边问题的解决方法" class="headerlink" title="CSS3毛玻璃效果(blur)有白边问题的解决方法"></a>CSS3毛玻璃效果(blur)有白边问题的解决方法</h2><p>主要解决方案：</p><p><code>transform: scale(1.1);</code></p><p>通过放大元素，来使得白边部分不显示在屏幕中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;home-background&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.home-background &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  background: url(&quot;..&#x2F;assets&#x2F;home_background.jpg&quot;) no-repeat;</span><br><span class="line">  transform: scale(1.1);</span><br><span class="line">  background-size: cover;</span><br><span class="line">  z-index: -1;</span><br><span class="line">  filter: blur(10px); &#x2F;* 高斯模糊 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="点击按钮后出现搜索框，同时搜索框自动获取焦点"><a href="#点击按钮后出现搜索框，同时搜索框自动获取焦点" class="headerlink" title="点击按钮后出现搜索框，同时搜索框自动获取焦点"></a>点击按钮后出现搜索框，同时搜索框自动获取焦点</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>直接使用<code>document.getElementsByClassName(&quot;search-input&quot;)[0].focus();</code>失效，因为搜索框是动态隐藏显示的，这句话调用的时候，还没加载出来</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- 搜索框 --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;search-box&quot;&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        class&#x3D;&quot;search-box-button&quot;</span><br><span class="line">        @click&#x3D;&quot;clickSearchBoxButton&quot;</span><br><span class="line">        :class&#x3D;&quot;&#123; show: this.focused &#x3D;&#x3D; false &#125;&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        搜索</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type&#x3D;&quot;text&quot;</span><br><span class="line">        class&#x3D;&quot;search-input&quot;</span><br><span class="line">        :class&#x3D;&quot;&#123; show: this.focused &#x3D;&#x3D; true &#125;&quot;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Search&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      focused: false,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickSearchBoxButton() &#123;</span><br><span class="line">      this.focused &#x3D; true;</span><br><span class="line">      this.$nextTick(function () &#123;</span><br><span class="line">        document.getElementsByClassName(&quot;search-input&quot;)[0].focus();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>Vue.nextTick</code>用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回<code>promise</code>对象。</p><p><a href="https://www.jianshu.com/p/a7550c0e164f">简单理解Vue中的nextTick - 简书 (jianshu.com)</a></p></blockquote><h2 id="vue-router如何传递参数"><a href="#vue-router如何传递参数" class="headerlink" title="vue-router如何传递参数"></a>vue-router如何传递参数</h2><h3 id="利用router-link-中的to来传参"><a href="#利用router-link-中的to来传参" class="headerlink" title="利用router-link 中的to来传参"></a>利用router-link 中的to来传参</h3><p>语法：</p><p><code>&lt;router-link v-bind:to=&quot;&#123;name:&#39;xxx&#39;,params:&#123;key:value&#125;&#125;&quot;&gt;&lt;/router-link&gt;</code></p><p>a.首先：to需要绑定；</p><p>b.传参使用类似与对象的形式；</p><p>c.name就是我们在配置路由时候取的名字；</p><p>d.参数也是采用对象的形式。</p><p>实际操作一下：</p><p>a.在APP.vue中将to里面的路径改成上面那样</p><p><code>&lt;router-link :to=&quot;&#123;name:&#39;hellovue&#39;,params:&#123;username:&#39;tomcat&#39;&#125;&#125;&quot;&gt;hellovue页面&lt;/router-link&gt;</code></p><p>这里我们注意to的写法，前面加了冒号，因为那是绑定的，传递一个username过去，值为tomcat</p><p>b.在index.js里面给hellovue配置名字叫hellovue,与上面name相对应</p><p><img src="Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_03%E6%90%9C%E7%B4%A2%E9%A1%B5/20180511141049216.png" alt="vue-router如何传递参数1"></p><p>c、在hellovue.vue中接收参数</p><p>  <code>&lt;p&gt;传递的名字是：&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt;</code></p><h3 id="采用url传参"><a href="#采用url传参" class="headerlink" title="采用url传参"></a>采用url传参</h3><p>在路由文件里采用冒号的形式传参，这就是对参数的绑定</p><p>a、修改index.js里的path，这里我们修改myjob.vue组件</p><p><img src="Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_03%E6%90%9C%E7%B4%A2%E9%A1%B5/20180511141232645.png" alt="采用url传参1"></p><p>b、在App.vue组件里传递参数</p><p><img src="Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_03%E6%90%9C%E7%B4%A2%E9%A1%B5/20180511141303641.png" alt="采用url传参2"></p><p>c、在myjob.vue组件里显示我们要展示的内容（接收参数）</p><p><img src="Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_03%E6%90%9C%E7%B4%A2%E9%A1%B5/20180511141334653.png" alt="采用url传参3"></p><h2 id="vue组件间通信六种方式（完整版）-SegmentFault-思否"><a href="#vue组件间通信六种方式（完整版）-SegmentFault-思否" class="headerlink" title="vue组件间通信六种方式（完整版） - SegmentFault 思否"></a><a href="https://segmentfault.com/a/1190000019208626">vue组件间通信六种方式（完整版） - SegmentFault 思否</a></h2><p>vue组件间通信六种方式</p><h2 id="router-view-组件间传值"><a href="#router-view-组件间传值" class="headerlink" title="router-view 组件间传值"></a>router-view 组件间传值</h2><h3 id="情况一：router-view-子组件发生变化导致父组件发生改变"><a href="#情况一：router-view-子组件发生变化导致父组件发生改变" class="headerlink" title="情况一：router-view 子组件发生变化导致父组件发生改变"></a>情况一：router-view 子组件发生变化导致父组件发生改变</h3><p>父组件中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view <span class="meta">@getMessage</span>=<span class="string">&quot;showMsg&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">showMsg (<span class="keyword">val</span>) &#123;   <span class="comment">// methods方法  val即为子组件传过来的值</span></span><br><span class="line">  console.log(<span class="keyword">val</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">&#x27;getMessage&#x27;</span>, “传给父组件的值”);</span><br></pre></td></tr></table></figure><h3 id="情况二：router-view-父组件发生变化导致子组件发生改变"><a href="#情况二：router-view-父组件发生变化导致子组件发生改变" class="headerlink" title="情况二：router-view 父组件发生变化导致子组件发生改变"></a>情况二：router-view 父组件发生变化导致子组件发生改变</h3><p>父组件中：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view  <span class="symbol">:searchVal=<span class="string">&quot;searchVal&quot;</span>&gt;&lt;/router-view&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">searchVal:</span> <span class="string">&#x27;&#x27;</span>,  <span class="regexp">//</span> data里面申明</span><br><span class="line"></span><br><span class="line">this.searchVal = <span class="string">&quot;需要传给子组件的值&quot;</span>;    <span class="regexp">//</span> 在需要传值的方法中处理</span><br></pre></td></tr></table></figure><p>子组件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;searchVal&#x27;</span>],</span><br><span class="line"></span><br><span class="line">watch: &#123;</span><br><span class="line">      searchVal: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;       </span><br><span class="line">       <span class="built_in">console</span>.log(val);   <span class="comment">// 接收父组件的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="CSS实现div的高度填满剩余空间"><a href="#CSS实现div的高度填满剩余空间" class="headerlink" title="CSS实现div的高度填满剩余空间"></a>CSS实现div的高度填满剩余空间</h2><p>实现content的高度填满剩余空间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#85d989</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#cc85d9</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是要top和bottom一起使用，这是很反常规的用法，可以强制定义盒模型的区域，神奇啊</p><h2 id="vue点击页面的小盒子之外元素触发事件"><a href="#vue点击页面的小盒子之外元素触发事件" class="headerlink" title="vue点击页面的小盒子之外元素触发事件"></a>vue点击页面的小盒子之外元素触发事件</h2><p>主要思路：对整个页面的main之外套一个div，然后设置div的@click事件，重要的是抑制盒子内部的冒泡现象，点击盒子内部的小盒子不触发事件，点击页面内部的各个小盒子之外的地方触发事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;!-- 主体部分 --&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;main-box&quot; @click&#x3D;&quot;toHome($event)&quot;&gt;</span><br><span class="line">        &lt;el-main&gt;</span><br><span class="line">          &lt;!-- 主题内容 --&gt;</span><br><span class="line">          &lt;router-view &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;el-main&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toHome(event)&#123;</span><br><span class="line">      &#x2F;* 点击页面内部的各个小盒子不进行后续操作 *&#x2F;</span><br><span class="line">      if(event.target.className!&#x3D;&#x3D;&#39;main-box&#39;)&#123;</span><br><span class="line">        return ;</span><br><span class="line">      &#125;</span><br><span class="line">      this.focused &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue实例data对象里有哪些类型数据"><a href="#Vue实例data对象里有哪些类型数据" class="headerlink" title="Vue实例data对象里有哪些类型数据"></a>Vue实例data对象里有哪些类型数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &#123;&#123;school.name&#125;&#125;&#123;&#123;school.mobile&#125;&#125;</span><br><span class="line">        &lt;!-- 数组输出方式比较特殊 --&gt;</span><br><span class="line">        &lt;ul&gt;一共：</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &#123;&#123;campus&#125;&#125;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;ul&gt;分散：</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &#123;&#123;campus[0]&#125;&#125;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &#123;&#123;campus[1]&#125;&#125;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &#123;&#123;campus[2]&#125;&#125;</span><br><span class="line">            &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Search&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">     msg:&quot;你好呀！VUE！&quot;,</span><br><span class="line">     school:&#123;</span><br><span class="line">        name: &quot;胖纸&quot;,</span><br><span class="line">        mobile:&quot;400-618-9090&quot;</span><br><span class="line">             &#125;,</span><br><span class="line">     campus:[&quot;北京校区&quot;,&quot;上海校区&quot;,&quot;广州校区&quot;]             </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="实现渐变色的背景之间的过渡切换"><a href="#实现渐变色的背景之间的过渡切换" class="headerlink" title="实现渐变色的背景之间的过渡切换"></a>实现渐变色的背景之间的过渡切换</h2><p>在开发过程中遇到一个需求，要实现渐变色的背景之间的过渡切换，而css3的transition属性对于background-image不生效</p><p>想了很久之后，想到一个办法，利用两个div来设置不同的渐变的背景色，再通过改变div的透明度，实现渐变色之间的过渡，效果还不错</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;words-bg&quot;&gt;测试&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.words-bg &#123;</span><br><span class="line">  background: linear-gradient(90deg, #ffffffef, #00000000); &#x2F;* transition无法对其生效*&#x2F;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transition: all 0.5s ease;</span><br><span class="line">&#125;</span><br><span class="line">.words-bg:hover&#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>此时，transition是对opacity生效</p><h2 id="当父盒子width不是全屏宽度时，如何设置子盒子宽度为全屏宽"><a href="#当父盒子width不是全屏宽度时，如何设置子盒子宽度为全屏宽" class="headerlink" title="当父盒子width不是全屏宽度时，如何设置子盒子宽度为全屏宽"></a>当父盒子width不是全屏宽度时，如何设置子盒子宽度为全屏宽</h2><p>解决方法：设置子盒子position为absolute，然后再设置width:100%即可</p><h2 id="监听数据变化"><a href="#监听数据变化" class="headerlink" title="监听数据变化"></a>监听数据变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      activeURL: 0,</span><br><span class="line">      focused: false,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    &#x2F;&#x2F; 监听focused数据变化</span><br><span class="line">    activeURL: function(val)&#123;</span><br><span class="line">      if(val !&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        this.focused &#x3D; true</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        this.focused &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><h2 id="background-linear-gradient属性值无效"><a href="#background-linear-gradient属性值无效" class="headerlink" title="background: linear-gradient属性值无效"></a>background: linear-gradient属性值无效</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">    <span class="number">90deg</span>,</span><br><span class="line">    <span class="number">#fff</span>,</span><br><span class="line">    <span class="number">#000</span>,</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>失效原因：linear-gradient最后一个元素后面加了逗号<code>,</code></p><p>解决方法：删除逗号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">    <span class="number">90deg</span>,</span><br><span class="line">    <span class="number">#fff</span>,</span><br><span class="line">    <span class="number">#000</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure></script></iframe></html></head></bdo></p>]]></content>
      
      
      <categories>
          
          <category> Liking起始页搭建日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liking </tag>
            
            <tag> Vue </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liking起始页搭建日记[前端]-02主页面布局</title>
      <link href="2022/02/01/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_02%E4%B8%BB%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
      <url>2022/02/01/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_02%E4%B8%BB%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h1><ol><li>完成主页面基础布局</li><li>完成主页面通用组件</li></ol><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="实现菜单栏与组件绑定"><a href="#实现菜单栏与组件绑定" class="headerlink" title="实现菜单栏与组件绑定"></a>实现菜单栏与组件绑定</h2><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>通过一个变量<code>activeURL</code>和一个动态class属性<code>:class=&quot;&#123; activedPage: activeURL == index + 1 &#125;&quot;</code>来实现点击菜单栏以后对应菜单栏发生样式变化，同时通过<code>a</code>标签/<code>router-link</code>标签实现对应组件渲染。</p><span id="more"></span><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- 菜单栏 --&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;menu&quot; router&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;menu-item&quot; :key&#x3D;&quot;0&quot;&gt;</span><br><span class="line">            &lt;a href&#x3D;&quot;&#x2F;&quot; @click&#x3D;&quot;activeURL &#x3D; 0&quot;&gt;首页&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;div</span><br><span class="line">              class&#x3D;&quot;menu-underline&quot;</span><br><span class="line">              :class&#x3D;&quot;&#123; activedPage: activeURL &#x3D;&#x3D; 0 &#125;&quot;</span><br><span class="line">            &gt;&lt;&#x2F;div&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;div</span><br><span class="line">            class&#x3D;&quot;menu-item&quot;</span><br><span class="line">            @click&#x3D;&quot;activeURL &#x3D; index + 1&quot;</span><br><span class="line">            v-for&#x3D;&quot;(item, index) in this.$router.options.routes[0].children&quot;</span><br><span class="line">            :key&#x3D;&quot;index + 1&quot;</span><br><span class="line">          &gt;</span><br><span class="line">            &lt;router-link :to&#x3D;&quot;item.path&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;router-link&gt;</span><br><span class="line">            &lt;div</span><br><span class="line">              class&#x3D;&quot;menu-underline&quot;</span><br><span class="line">              :class&#x3D;&quot;&#123; activedPage: activeURL &#x3D;&#x3D; index + 1 &#125;&quot;</span><br><span class="line">            &gt;&lt;&#x2F;div&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      activeURL: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.el-header .menu-item .menu-underline &#123;</span><br><span class="line">  width: 10px;</span><br><span class="line">  height: 5px;</span><br><span class="line">  background-color: #ffffffcc;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">  margin-left: calc(50% - 5px); &#x2F;* 注意空格，否则无效！ *&#x2F;</span><br><span class="line">  transform: scaleX(0);</span><br><span class="line">  transition: transform 0.3s ease;</span><br><span class="line">&#125;</span><br><span class="line">.el-header .menu-underline.activedPage &#123;</span><br><span class="line">  transform: scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="字体水平居中与垂直居中"><a href="#字体水平居中与垂直居中" class="headerlink" title="字体水平居中与垂直居中"></a>字体水平居中与垂直居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="方式一-flex"><a href="#方式一-flex" class="headerlink" title="方式一 flex"></a>方式一 flex</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure><h3 id="方式二-position-absolute"><a href="#方式二-position-absolute" class="headerlink" title="方式二 position: absolute"></a>方式二 position: absolute</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - 宽度二分之一);</span><br></pre></td></tr></table></figure><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">line-height</span>: <span class="number">35px</span>; <span class="comment">/* 垂直居中 */</span></span><br></pre></td></tr></table></figure><h2 id="实现菜单栏从上到下缓慢移动并显现的动画"><a href="#实现菜单栏从上到下缓慢移动并显现的动画" class="headerlink" title="实现菜单栏从上到下缓慢移动并显现的动画"></a>实现菜单栏从上到下缓慢移动并显现的动画</h2><p><code>opacity: 0</code>表示不透明度为0，即隐藏，<code>opacity: 1</code>表示不透明度为1，即显示。</p><p><code>padding-top</code>的改变加上<code>transition: all 0.5s ease;</code>的0.5s延迟演示，会显现出从上向下逐渐移动的动画。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.el-header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.5s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-header</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css-calc-无效的原因"><a href="#css-calc-无效的原因" class="headerlink" title="css calc() 无效的原因"></a>css calc() 无效的原因</h2><p>无效时，在F12即开发者工具中显示该属性前会有黄色感叹号并提醒属性无效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">5px</span>); <span class="comment">/* 有效 */</span></span><br><span class="line"><span class="attribute">margin-left</span>: <span class="built_in">calc</span>(<span class="number">50%</span>-<span class="number">5px</span>);  <span class="comment">/* 无效  原因：运算符前后无空格！*/</span></span><br></pre></td></tr></table></figure><h2 id="实时时钟"><a href="#实时时钟" class="headerlink" title="实时时钟"></a>实时时钟</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;time&quot;&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;&#123; this.hours &#125;&#125;</span><br><span class="line">      &lt;span&gt;:&lt;&#x2F;span&gt;</span><br><span class="line">      &#123;&#123; this.minutes &#125;&#125;</span><br><span class="line">    &lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Time&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      timer: &quot;&quot;, &#x2F;&#x2F; 定时器</span><br><span class="line">      hours: &quot;00&quot;,</span><br><span class="line">      minutes: &quot;00&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 组件创建时设置计时器定时获取时间</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.timer &#x3D; setInterval(this.getTime, 1000); &#x2F;&#x2F; 周期调用函数获取时间</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;   在Vue实例销毁前，清除定时器</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    if (this.timer) &#123;</span><br><span class="line">      clearInterval(this.timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getTime() &#123;</span><br><span class="line">      &#x2F;&#x2F; new Date() 时间类 获取当前时间</span><br><span class="line">      &#x2F;&#x2F; new Date()返回的值是静态值，并不是实时更新的，所以需要周期性获取）</span><br><span class="line">      this.hours &#x3D; new Date().getHours();</span><br><span class="line">      this.hours &#x3D; this.hours &lt;&#x3D; 9 ? &quot;0&quot; + this.hours : this.hours;</span><br><span class="line">      this.minutes &#x3D; new Date().getMinutes();</span><br><span class="line">      this.minutes &#x3D; this.minutes &lt;&#x3D; 9 ? &quot;0&quot; + this.minutes : this.minutes;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.time &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  color: #fff;</span><br><span class="line">  font-size: 1.2em;</span><br><span class="line">  text-shadow: 0 0 20px rgba(0, 0, 0, 0.35);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现’-’每秒闪动"><a href="#实现’-’每秒闪动" class="headerlink" title="实现’:’每秒闪动"></a>实现’:’每秒闪动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.time &#123;</span><br><span class="line">  animation: delayedFadeIn 2s;</span><br><span class="line">&#125;</span><br><span class="line">.time span &#123;</span><br><span class="line">  animation: blink 1s ease infinite;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 秒 闪烁 *&#x2F;</span><br><span class="line">@keyframes blink &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    opacity: 0.5;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 0.5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 打开主页延迟显示2s显示时间组件 *&#x2F;</span><br><span class="line">@keyframes delayedFadeIn &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const routes: Array&lt;RouteRecordRaw&gt; &#x3D; [</span><br><span class="line">  &#x2F;&#x2F; 重定向根目录</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;home&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#39;&#x2F;home&#39;,</span><br><span class="line">    name: &#39;主页&#39;,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [ &#x2F;&#x2F; 这样路径跳转会匹配到Home中的router-view</span><br><span class="line">      &#123;</span><br><span class="line">        path: &#39;&#x2F;commonApp&#39;,</span><br><span class="line">        name: &#39;常用&#39;,</span><br><span class="line">        component: CommonApp,</span><br><span class="line">      &#125;,</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="修改input元素placeholder样式的方法"><a href="#修改input元素placeholder样式的方法" class="headerlink" title="修改input元素placeholder样式的方法"></a>修改input元素placeholder样式的方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改input的placeholder属性 */</span></span><br><span class="line"><span class="selector-class">.search-input</span><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>我们时常需要跟input输入框打交道，很多情况下都要对placeholder的内容进行修改</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; placeholder=&#123;&#x27;placeholder&#x27;&#125;/&gt;</span><br></pre></td></tr></table></figure><p>我们是没法直接对input元素设置样式来更改placeholder，需要通过伪元素 ::-webkit-input-placeholder 的方式来修改样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里补充一下针对不同浏览器的用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder &#123; /* WebKit, Blink, Edge */</span><br><span class="line">    color: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br><span class="line">:-moz-placeholder &#123; /* Mozilla Firefox <span class="number">4</span> to <span class="number">18</span> */</span><br><span class="line">    color: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br><span class="line">::-moz-placeholder &#123; /* Mozilla Firefox <span class="number">19</span>+ */</span><br><span class="line">    color: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br><span class="line">:-ms-input-placeholder &#123; /* Internet Explorer <span class="number">10</span>-<span class="number">11</span> */</span><br><span class="line">    color: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/cc18868876837/article/details/92005355">https://blog.csdn.net/cc18868876837/article/details/92005355</a></p><h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><h2 id="Uncaught-ReferenceError-xxx-is-not-defined"><a href="#Uncaught-ReferenceError-xxx-is-not-defined" class="headerlink" title="Uncaught ReferenceError: xxx is not defined"></a>Uncaught ReferenceError: xxx is not defined</h2><p>代码中无报错，但是运行页面全白，F12开发者工具中显示：Uncaught ReferenceError: Time is not defined。</p><p>错误原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: Time,  &#x2F;* 这里应该是字符串！！！ *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>改正</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;Time&#39;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Liking起始页搭建日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liking </tag>
            
            <tag> Vue </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liking起始页搭建日记[前端]-01登录注册页面</title>
      <link href="2022/01/27/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_01%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2/"/>
      <url>2022/01/27/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_01%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h1><ol><li>学习前端自适应开发</li><li>完成登录/注册页面</li><li>上传项目至Github</li></ol><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="页面窗口自适应"><a href="#页面窗口自适应" class="headerlink" title="页面窗口自适应"></a>页面窗口自适应</h2><p>想要实现窗口的自适应有很多种解决方案。Liking中主要采用@media、display: flex、rem相互配合来实现窗口的自适应。</p><span id="more"></span><h2 id="a和router-link区别"><a href="#a和router-link区别" class="headerlink" title="a和router-link区别"></a>a和router-link区别</h2><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;&quot;</span>&gt;链接 &lt;/a&gt;</span><br><span class="line">JS 复制 全屏</span><br></pre></td></tr></table></figure><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;&quot;</span>&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="a标签-1"><a href="#a标签-1" class="headerlink" title="a标签"></a>a标签</h3><p>点击a标签从当前页面跳转到另一个页面<br>通过a标签跳转，页面就会重新加载，相当于重新打开了一个网页</p><h3 id="router-link-1"><a href="#router-link-1" class="headerlink" title="router-link"></a>router-link</h3><p>通过router-link进行跳转不会跳转到新的页面，不会重新渲染，它会选择路由所指的组件进行渲染</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过a标签和router-link对比，router-link避免了重复渲染，不像a标签一样需要重新渲染，导致一些动态添加路由的机制失效</p><h2 id="v-for中动态id由静态字符串和变量构成怎么办"><a href="#v-for中动态id由静态字符串和变量构成怎么办" class="headerlink" title="v-for中动态id由静态字符串和变量构成怎么办"></a>v-for中动态id由静态字符串和变量构成怎么办</h2><p>使用纯JavaScript字符串连接即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(field, key) in lists[$route.params.model][$route.params.status].fields&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">:id</span>=<span class="string">&quot;&#x27;order_by&#x27; + field&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">                            ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code> :id=&quot;&#39;order_by&#39; + field&quot;</code> 其中’order_by’是字符串，field是属性值/变量，由+连接</p><h2 id="同一位置点击事件显示不同的组件"><a href="#同一位置点击事件显示不同的组件" class="headerlink" title="同一位置点击事件显示不同的组件"></a>同一位置点击事件显示不同的组件</h2><p>核心思路：通过动态改变<code>component</code>的<code>is</code>属性值实现渲染不同组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right-container&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;right-context&quot;&gt;</span><br><span class="line">        &lt;!-- 点击按钮会显示不同组件 --&gt;</span><br><span class="line">        &lt;component :is&#x3D;&quot;loginOrRegister&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;right-footer-box&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;right-footer-login-box&quot;&gt;</span><br><span class="line">          &lt;a class&#x3D;&quot;quick-register&quot; @click&#x3D;&quot;toRegister&quot;&gt;快速注册&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;right-footer-register-box&quot; style&#x3D;&quot;display:none;&quot;&gt;</span><br><span class="line">          &lt;a class&#x3D;&quot;quick-login&quot; @click&#x3D;&quot;toLogin&quot;&gt;去登录&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import LoginForm from &#39;LoginForm.vue&#39;</span><br><span class="line">import RegisterForm from &#39;RegisterForm.vue&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;LoginRegister&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    LoginForm,</span><br><span class="line">    RegisterForm,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      loginOrRegister: &quot;LoginForm&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toRegister() &#123;</span><br><span class="line">      this.loginOrRegister &#x3D; &quot;RegisterForm&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">    toLogin() &#123;</span><br><span class="line">      this.loginOrRegister &#x3D; &quot;LoginForm&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="css隐藏页面元素的方法"><a href="#css隐藏页面元素的方法" class="headerlink" title="css隐藏页面元素的方法"></a>css隐藏页面元素的方法</h2><p>用css隐藏页面元素有许多种方法。</p><p><strong>第一种方法【opacity: 0;】</strong></p><p>opacity属性通常用于设置一个元素的透明度，从另一个角度来看，如果透明度为0，也就从视觉上隐藏了该元素。</p><p>这个属性不是为改变元素的边界框（bounding box）而设计的，元素本身依然占据它自己的位置并对网页的布局起作用，它也将响应用户交互。</p><p><strong>第二种方法【visibility: hidden;】</strong></p><p>第二个要说的属性是visibility。</p><p>将它的值设为hidden将隐藏我们的元素。</p><p>如同opacity属性，被隐藏的元素依然会对我们的网页布局起作用。</p><p>与opacity唯一不同的是它不会响应任何用户交互。</p><p>此外，设置了该属性之后，元素在读屏软件中会被隐藏。</p><p>另外要注意的是，如果一个元素的visibility被设置为hidden之后，却想要显示它的某个子孙元素，只要将那个子孙元素的visibility显式设置为visible即可（样式覆盖）。</p><p><strong>第三种方法【display: none;】</strong></p><p>display属性依照词义才是真正地隐藏了元素。</p><p>将display属性设为none就能确保元素不可见并且连盒模型也不生成，使用这个属性，被隐藏的元素不占据任何空间。</p><p>不仅如此，一旦display设为none任何对该元素直接打用户交互操作都不可能生效。</p><p>此外，读屏软件也不会读到元素的内容，因为这种方式产生的效果就像元素完全不存在。</p><p>任何这个元素的子孙元素也会被同时隐藏。</p><p>为这个属性添加过度动画是无效的，他的任何不同状态值之间的切换总是会立即生效。</p><p>不过请注意，通过DOM依然可以访问到这个元素。因此你可以通过DOM来操作它。</p><p><strong>第四种方法【position: absolute;】</strong></p><p>假设有一个元素你想要与它交互，但是你又不想让它影响你的网页布局，没有合适的属性可以处理这种情况（opacity和visibility影响布局mdisplay不影响布局但又无法直接交互）。</p><p>在这种情况下，只能考虑将元素移出可视区域，这个办法既不会影响布局，有可能让元素保持可以操作。</p><p>具体是通过将position属性设置为absolute来实现（绝对定位）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: -<span class="number">999px</span>;</span><br><span class="line"><span class="attribute">left</span>: -<span class="number">999px</span>;</span><br></pre></td></tr></table></figure><p><strong>第五种方法【clip-path】</strong></p><p>隐藏元素的另一种方法是通过剪裁它们实现，具体是通过clip-path属性，这个属性比较新，浏览器兼容性也会比较差。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clip</span>-path: polygon(<span class="number">0</span>px <span class="number">0</span>px,<span class="number">0</span>px <span class="number">0</span>px,<span class="number">0</span>px <span class="number">0</span>px,<span class="number">0</span>px <span class="number">0</span>px);</span><br></pre></td></tr></table></figure><p>但是了解一下还是很必要的。</p><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="github上文件夹显示白色箭头并且不可访问"><a href="#github上文件夹显示白色箭头并且不可访问" class="headerlink" title="github上文件夹显示白色箭头并且不可访问"></a>github上文件夹显示白色箭头并且不可访问</h2><p>之前在写一个练手项目时，因为前端工程用vue-cli构建，相当于clone了别人的项目，github就将他视为一个子系统模块，导致在上传代码时该文件夹上传失败，并在github上显示向右的白色箭头。</p><p><img src="/2022/01/27/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_%E5%89%8D%E7%AB%AF_01%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2/image-20220120200527287.png" alt="github上文件夹显示白色箭头"></p><p>解决办法：</p><ol><li>删除子文件夹里面的.git文件</li><li>执行<code>git rm --cached [文件夹名]</code></li><li>执行<code>git add .</code></li><li>执行<code>git commit -m &quot;commit messge&quot;</code></li><li>执行<code>git push origin [branch_name]</code></li></ol><blockquote><p>链接：<a href="https://www.jianshu.com/p/7cc6ea70e48e">https://www.jianshu.com/p/7cc6ea70e48e</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Liking起始页搭建日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liking </tag>
            
            <tag> Vue </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liking起始页搭建日记-00项目定位和初始化</title>
      <link href="2022/01/25/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_00%E9%A1%B9%E7%9B%AE%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>2022/01/25/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_00%E9%A1%B9%E7%9B%AE%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Liking相关"><a href="#Liking相关" class="headerlink" title="Liking相关"></a>Liking相关</h1><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>一个组织个人笔记、日志、文件的网站<br>功能：</p><ol><li>个人笔记整理，markdown文件</li><li>源码分享页面，对代码注释优化，左侧代码，右侧注释<span id="more"></span></li><li>个人日记页面，实现书写随笔，然后写完以后点击确认直接随机放入，页面上只保留日记标题和日期。然后形成星云形式。只有输入密码才可以获得按照日期排序的个人日记和提供搜索按钮的归档页面，然后点击对应日志才能看到内容。可以很好保护个人隐私。</li><li>日程安排<ol><li>仿照滴搭</li><li>添加拖拽功能</li></ol></li><li>文件传输<ol><li>类似百度网盘</li></ol></li></ol><h2 id="页面逻辑"><a href="#页面逻辑" class="headerlink" title="页面逻辑"></a>页面逻辑</h2><p>首页：浏览器+常用功能按钮+日程提醒+文件传输提醒</p><ul><li>第一页：默认：常用功能按钮为第一页</li><li>第二页：首页下的日程 – 当天日程（默认） + 每周日程、每月日程（可跳转   以日历形式  参考IOS） <ul><li>//  待定：然后点击可以跳转到具体日程页</li></ul></li><li>第三页：文件传输，文件夹格式（显示云端的文件内容              可以拓展为与百度网盘等网盘链接             自己用可以是链接服务器）</li></ul><h2 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h2><ol><li>将自己博客上传，同时提供《一些好玩的》中的实时编辑功能</li><li>提供文档分享页，markdown格式，同时支持分享源码，源码讲解：左侧代码，右侧注释。分享数据结构解题方案，左侧代码，右侧解释（解释可以是左右，上下滑动等）。</li><li>根据用户上传背景自动改变主题（白  黑），主题会改动字体颜色、边框颜色等。</li><li>一言<ol><li>点击即复制到剪贴板  同时提醒一下“已复制到剪切板”</li></ol></li></ol><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><ol><li><p>哪些东西存在到数据库？前端哪些东西写死逻辑，哪些通过读取数据库获得？</p></li><li><p>哪些东西保存到用户本地？</p><p>用户配置可以写到本地（方法：<a href="https://www.runoob.com/jsref/prop-win-localstorage.html">localStorage</a>）。而登录以后可以存到服务端，到时候直接从服务器端获取用户配置。</p></li><li><p>文件传输怎么样更快？局域网传输？</p></li><li><p>前端哪些组件可以动态加载？哪些异步加载？</p><p><a href="https://www.bilibili.com/video/BV1D54y1C7ST/?spm_id_from=333.788.recommend_more_video.1">如何使用Vue.extend来动态创建组件？【Vue】_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1YT4y1w7FT/?spm_id_from=333.788.recommend_more_video.0">有些组件不想马上加载？使用异步组件！【Vue】_哔哩哔哩_bilibili</a></p></li></ol><h1 id="前端项目初始化"><a href="#前端项目初始化" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h1><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>解决npm国内速度慢问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><h3 id="搭建vue项目"><a href="#搭建vue项目" class="headerlink" title="搭建vue项目"></a>搭建vue项目</h3><p>管理员模式运行powerShell，然后在项目文件夹执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create liking</span><br></pre></td></tr></table></figure><p>如果出现“系统上禁止运行脚本”的报错：</p><p><img src="/2022/01/25/Liking%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%90%AD%E5%BB%BA%E6%97%A5%E8%AE%B0_00%E9%A1%B9%E7%9B%AE%E5%AE%9A%E4%BD%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/image-20220120000144171.png" alt="“系统上禁止运行脚本”的报错"></p><p>则执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后选择Y</span></span><br></pre></td></tr></table></figure><p>配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v4.5.15</span><br><span class="line">? Please pick a preset: Manually select features</span><br><span class="line">? Check the features needed for your project:</span><br><span class="line"> (*) Choose Vue version</span><br><span class="line"> (*) Babel</span><br><span class="line"> (*) TypeScript</span><br><span class="line"> ( ) Progressive Web App (PWA) Support</span><br><span class="line"> (*) Router</span><br><span class="line"> ( ) Vuex</span><br><span class="line"> ( ) CSS Pre-processors</span><br><span class="line"> ( ) Linter / Formatter</span><br><span class="line"> ( ) Unit Testing</span><br><span class="line"> ( ) E2E Testing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue CLI v4.5.15</span><br><span class="line">? Please pick a preset: Manually select features</span><br><span class="line">? Check the features needed for your project: Choose Vue version, Babel, TS, Router</span><br><span class="line">? Choose a version of Vue.js that you want to start the project with 3.x</span><br><span class="line">? Use class-style component syntax? No</span><br><span class="line">? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? Yes</span><br><span class="line">? Use history mode for router? (Requires proper server setup for index fallback in production) Yes</span><br><span class="line">? Where do you prefer placing config for Babel, ESLint, etc.? In package.json</span><br></pre></td></tr></table></figure><p>运行项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h4 id="部分代码解释"><a href="#部分代码解释" class="headerlink" title="部分代码解释"></a>部分代码解释</h4><p><code>babel.config.js</code> 是为了兼容低版本IE</p><p><code>index.ts</code> 定义路由对应的组件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    <span class="comment">// route level code-splitting</span></span><br><span class="line">    <span class="comment">// this generates a separate chunk (about.[hash].js) for this route</span></span><br><span class="line">    <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>)  <span class="comment">// ES6写法，动态加载。类似于懒加载模式，不是在初始化时就加载这个组件，而是用到这个组件的时候才去加载他</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router  <span class="comment">// 暴露组件 导出路由，让其他地方使用到路由时可以导入</span></span><br></pre></td></tr></table></figure><p><code>App.vue</code> 是默认主页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;  &lt;!-- 代码模板 --&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;nav&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;router-link&gt; | </span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;router-link&gt; &lt;!-- router-link类似于&lt;a&gt;标签 --&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;router-view&#x2F;&gt;  &lt;!-- 路径匹配  会渲染路由匹配到的组件 例如router-link --&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only  scoped表示这个样式只会作用于该组件--&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><code>main.ts</code> 是程序入口</p><p><code>Home.vue</code> 是一个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default defineComponent(&#123;  &#x2F;&#x2F; 将组件暴露出去，支持其他组件等访问</span><br><span class="line">  name: &#39;Home&#39;,</span><br><span class="line">  components: &#123;  &#x2F;&#x2F; 该组件使用的组件</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">  props:&#123;  &#x2F;&#x2F; 该组件需要的参数</span><br><span class="line">     msg: String   &#x2F;&#x2F; 可以通过&#123;&#123;msg&#125;&#125;使用</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="安装element-plus"><a href="#安装element-plus" class="headerlink" title="安装element plus"></a>安装element plus</h2><p><a href="https://element-plus.org/zh-CN/guide/installation.html#%E7%89%88%E6%9C%AC">安装 | Element Plus (element-plus.org)</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> NPM</span></span><br><span class="line">npm install element-plus --save</span><br></pre></td></tr></table></figure><p>–save  表示将模块安装到项目目录下，并将模块放入到正式开发环境中”dependencies”（package.json文件）。</p><p>完整引入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ElementPlus <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">app.use(ElementPlus)</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Liking起始页搭建日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liking </tag>
            
            <tag> Vue </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue进行前端开发</title>
      <link href="2022/01/18/vue%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2022/01/18/vue%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="创建Vue3项目"><a href="#创建Vue3项目" class="headerlink" title="创建Vue3项目"></a>创建Vue3项目</h2><h3 id="使用vue-cli创建"><a href="#使用vue-cli创建" class="headerlink" title="使用vue-cli创建"></a>使用vue-cli创建</h3><p>安装/升级vue-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>查看vue版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -V</span><br></pre></td></tr></table></figure><p>创建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create project_name</span><br></pre></td></tr></table></figure><span id="more"></span><p>创建完成后的项目框架：</p><p><img src="/2022/01/18/vue%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/image-20220118131953437.png" alt="项目框架"></p><blockquote><p>build——项目构建(webpack)相关代码。</p><p>config——基本配置信息，如端口等，此处初学我们可以默认。</p><p>node_modules——npm加载的项目依赖模块。</p><p>src——最重要的开发目录，包含：assets(放置一些图片，如logo等)、 components( 组件文件夹)、App.vue( 项目入口文件)、main.js:(项目的核心文件)</p><p>static——静态资源目录。在打包发布后将用于存放静态资源。</p><p>test——初始测试目录，可以删除。</p><p>index.html ——首页入口文件。</p><p>package.json ——项目配置文件，此处初学我们可以默认。</p><p>.xxxx文件 ——一些配置文件，包括语法配置，git配置等，此处初学我们可以默认。</p><p>README.md ——项目的说明文档，为markdown 格式 。</p></blockquote><p>运行项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve                  </span><br></pre></td></tr></table></figure><h3 id="打开已有项目"><a href="#打开已有项目" class="headerlink" title="打开已有项目"></a>打开已有项目</h3><p>在已有项目所在目录打开命令行</p><p>安装依赖，安装完成后，项目中会多出“node_modules”文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>运行项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve                  </span><br></pre></td></tr></table></figure><h2 id="使用Element-plus的组件"><a href="#使用Element-plus的组件" class="headerlink" title="使用Element plus的组件"></a>使用Element plus的组件</h2><p><a href="https://element-plus.org/zh-CN">Element Plus (element-plus.org)</a></p><h2 id="404页面的路由写法"><a href="#404页面的路由写法" class="headerlink" title="404页面的路由写法"></a>404页面的路由写法</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/:catchAll(.*)&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Error404&#x27;</span>,</span><br><span class="line">    component: Error404</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="窗口大小到一定程度后，div不显示"><a href="#窗口大小到一定程度后，div不显示" class="headerlink" title="窗口大小到一定程度后，div不显示"></a>窗口大小到一定程度后，div不显示</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">500px</span>)&#123; <span class="comment">/* max screen size */</span></span><br><span class="line">    <span class="selector-id">#div</span> &#123; <span class="attribute">display</span>: none; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="a标签的下划线、颜色等"><a href="#a标签的下划线、颜色等" class="headerlink" title="a标签的下划线、颜色等"></a>a标签的下划线、颜色等</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-decoration</span>: none; <span class="comment">/* 去除下划线 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置点击链接后颜色 */</span></span><br><span class="line"><span class="selector-class">.footer-box</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置鼠标移动到该处后变化 */</span></span><br><span class="line"><span class="selector-class">.footer-box</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* text-decoration:underline; */</span> <span class="comment">/* 字体下划线 */</span></span><br><span class="line">  <span class="comment">/* font-weight: bold; */</span> <span class="comment">/* 字体加粗 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="vue3表单的输入框无法输入，或者输入多个字母只出现一两个"><a href="#vue3表单的输入框无法输入，或者输入多个字母只出现一两个" class="headerlink" title="vue3表单的输入框无法输入，或者输入多个字母只出现一两个"></a>vue3表单的输入框无法输入，或者输入多个字母只出现一两个</h3><p>在element Plus + vue3 + TS 的项目中出现的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form :model=<span class="string">&quot;form&quot;</span> :rules=<span class="string">&quot;rules&quot;</span> <span class="keyword">ref</span>=<span class="string">&quot;form&quot;</span> label-width=<span class="string">&quot;0px&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;ms-content&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>将model绑定值 与 ref 绑定值的名称换成不一样的就搞定了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-form :model=<span class="string">&quot;form&quot;</span> :rules=<span class="string">&quot;rules&quot;</span> <span class="keyword">ref</span>=<span class="string">&quot;formRef&quot;</span> label-width=<span class="string">&quot;0px&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;ms-content&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>具体原因不详</p><h3 id="vue3-挂载-axios"><a href="#vue3-挂载-axios" class="headerlink" title="vue3 挂载 axios"></a>vue3 挂载 axios</h3><p><a href="https://www.cnblogs.com/pyjblog/articles/15775885.html">https://www.cnblogs.com/pyjblog/articles/15775885.html</a><br>axios是一个库，并不是vue中的第三方插件，使用时不能通过Vue.use()安装插件，需要在原型上进行绑定，<br>例如以下写法是vue2引入axios的写法<br>import Vue from ‘vue’<br>import axios from ‘axios’<br>Vue.prototype.$http = axios<br>然而，在vue3.0，并不是直接创建的vue实例，而是通过createApp来创建的<br>vue3.0要通过app.config.globalProperties.$axios = axios进行挂载</p>]]></content>
      
      
      <categories>
          
          <category> Vue - 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing寒假每日一题-2041. 干草堆</title>
      <link href="2022/01/05/AcWing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_2041.%20%E5%B9%B2%E8%8D%89%E5%A0%86/"/>
      <url>2022/01/05/AcWing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_2041.%20%E5%B9%B2%E8%8D%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2041-干草堆"><a href="#2041-干草堆" class="headerlink" title="2041. 干草堆"></a>2041. 干草堆</h1><h2 id="sailboat-题目"><a href="#sailboat-题目" class="headerlink" title=":sailboat:题目"></a>:sailboat:题目</h2><p><a href="https://www.acwing.com/problem/content/2043/">2041. 干草堆 - AcWing题库</a></p><p>贝茜对她最近在农场周围造成的一切恶作剧感到抱歉，她同意帮助农夫约翰把一批新到的干草捆堆起来。</p><p>开始时，共有 N 个空干草堆，编号 1∼N。</p><p>约翰给贝茜下达了 K 个指令，每条指令的格式为 <code>A B</code>，这意味着贝茜要在 A..B 范围内的每个干草堆的顶部添加一个新的干草捆。</p><p>例如，如果贝茜收到指令 <code>10 13</code>，则她应在干草堆 10,11,12,13 中各添加一个干草捆。</p><span id="more"></span><p>在贝茜完成了所有指令后，约翰想知道 N 个干草堆的中值高度——也就是说，如果干草堆按照高度从小到大排列，位于中间的干草堆的高度。</p><p>方便起见，N 一定是奇数，所以中间堆是唯一的。</p><p>请帮助贝茜确定约翰问题的答案。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含 N 和 K。</p><p>接下来 K 行，每行包含两个整数 A,B，用来描述一个指令。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出完成所有指令后，N 个干草堆的中值高度。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N≤10<sup>6</sup><br>1≤K≤25000<br>1≤A≤B≤N</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">7 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>贝茜完成所有指令后，各堆高度为 0,1,2,3,3,1,0</p><p>将各高度从小到大排序后，得到 0,0,1,1,2,3,3，位于中间的是 1。</p><h2 id="cake-答案"><a href="#cake-答案" class="headerlink" title=":cake:答案"></a>:cake:答案</h2><h3 id="我的答案"><a href="#我的答案" class="headerlink" title="我的答案"></a>我的答案</h3><p>穷举：对a和b分别求其所对应的可能存在的进制数，即将分别修改一位数据的结果穷举出来，然后寻找对应十进制相等的两个进制数即为所求的数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>穷举</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_dec</span><span class="params">(string s, <span class="keyword">int</span> b)</span>  <span class="comment">// 将b进制转为十进制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 常用算法：秦九韶算法</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        res = res * b + c - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// c - &#x27;0&#x27; 字符转为数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c: a)  <span class="comment">// auto自动识别类型 &amp;表示引用，使用引用是因为我们是直接改本来的数据进行后续计算的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &#x27;0&#x27;的ASCII码是48    &#x27;1&#x27;的ASCII码是49</span></span><br><span class="line"><span class="comment">        所以 &#x27;0&#x27; 异或 1 = &#x27;1&#x27;</span></span><br><span class="line"><span class="comment">             &#x27;1&#x27; 异或 1 = &#x27;0&#x27;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        c ^= <span class="number">1</span>;  <span class="comment">// 异或操作</span></span><br><span class="line">        S.<span class="built_in">insert</span>(<span class="built_in">get_dec</span>(a, <span class="number">2</span>));</span><br><span class="line">        c ^= <span class="number">1</span>;  <span class="comment">// 将c恢复成原来的数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c:b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> t = c;  <span class="comment">// 暂存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="string">&#x27;0&#x27;</span> != t)&#123;</span><br><span class="line">                c = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">get_dec</span>(b, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(S.<span class="built_in">count</span>(x))</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; x &lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rocket-知识点总结"><a href="#rocket-知识点总结" class="headerlink" title=":rocket:知识点总结"></a>:rocket:知识点总结</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7 \sim 10^8$ 为最佳。</p><blockquote><p>比如上面这道题假如枚举所有可能的数N，数据范围为0≤N≤10<sup>9</sup>，而将数据转为二进制或三进制的时间复杂度是$log(n)$，那么这道题的穷举操作次数在$10^9*log(n)$，远超$10^8$次数，所以大概率超时，不可取。</p><p>而如果对给定的二进制数和三进制进行修改某一位得到的数进行穷举，那么数据量将大大减少，二进制数大概30个，三进制数大概50个，操作次数大概30*50*30*30次，则不会超时。</p></blockquote><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol><li>$n \le 30$, 指数级别,  dfs+剪枝，状态压缩dp</li><li>$n \le 100$ =&gt; $O(n^3)$，floyd，dp，高斯消元</li><li>$n \le 1000$ =&gt; $O(n^2)$，$O(n^2logn)$，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li>$n \le 10000$ =&gt; $O(n * \sqrt n)$，块状链表、分块、莫队</li><li>$n \le 100000$ =&gt; $O(nlogn)$ =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li>$n \le 1000000$ =&gt; $O(n)$, 以及常数较小的 $O(nlogn)$ 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa</li><li>$n \le 10000000$ =&gt; $O(n)$，双指针扫描、kmp、AC自动机、线性筛素数</li><li>$n \le 10^9$ =&gt; $O(\sqrt n)$，判断质数</li><li>$n \le 10^{18}$ =&gt; $O(logn)$，最大公约数，快速幂，数位DP</li><li>$n \le 10^{1000}$ =&gt; $O((logn)^2)$，高精度加减乘除</li><li>$n \le 10^{100000}$ =&gt; $O(logk \times loglogk)，k$表示位数，高精度加减、FFT/NTT</li></ol><h3 id="判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合"><a href="#判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合" class="headerlink" title="判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合"></a>判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合</h3><p>unordered_set</p><p>unordered_map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">unordered_set&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">S.<span class="built_in">insert</span>(数据);  <span class="comment">// 插入数据</span></span><br><span class="line">S.<span class="built_in">count</span>(目标数据);  <span class="comment">// 判断集合中是否包含目标数据</span></span><br></pre></td></tr></table></figure><h3 id="秦九韶算法求十进制数"><a href="#秦九韶算法求十进制数" class="headerlink" title="秦九韶算法求十进制数"></a>秦九韶算法求十进制数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_dec</span><span class="params">(string s, <span class="keyword">int</span> b)</span>  <span class="comment">// 将b进制转为十进制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 常用算法：秦九韶算法</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        res = res * b + c - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// c-&#x27;0&#x27;字符转为数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="‘0’-和-‘1’-的转换"><a href="#‘0’-和-‘1’-的转换" class="headerlink" title="‘0’ 和 ‘1’ 的转换"></a>‘0’ 和 ‘1’ 的转换</h4><p>‘0’的ASCII码是48    ‘1’的ASCII码是49<br>所以 ‘0’ 异或 1 = ‘1’<br>          ‘1’ 异或 1 = ‘0’</p><p><code>c ^= 1;  // 异或操作</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing-每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing寒假每日一题-2058. 笨拙的手指</title>
      <link href="2022/01/04/AcWing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_2058.%20%E7%AC%A8%E6%8B%99%E7%9A%84%E6%89%8B%E6%8C%87/"/>
      <url>2022/01/04/AcWing%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_2058.%20%E7%AC%A8%E6%8B%99%E7%9A%84%E6%89%8B%E6%8C%87/</url>
      
        <content type="html"><![CDATA[<h1 id="2058-笨拙的手指"><a href="#2058-笨拙的手指" class="headerlink" title="2058. 笨拙的手指"></a>2058. 笨拙的手指</h1><h2 id="sailboat-题目"><a href="#sailboat-题目" class="headerlink" title=":sailboat:题目"></a>:sailboat:题目</h2><p><a href="https://www.acwing.com/problem/content/2060/">2058. 笨拙的手指 - AcWing题库</a></p><p>奶牛贝茜正在学习如何在不同进制之间转换数字。</p><p>但是她总是犯错误，因为她无法轻易的用两个前蹄握住笔。</p><p>每当贝茜将数字转换为一个新的进制并写下结果时，她总是将其中的某一位数字写错。</p><p>例如，如果她将数字 1414 转换为二进制数，那么正确的结果应为 11101110，但她可能会写下 01100110 或 11111111。</p><span id="more"></span><p>贝茜不会额外添加或删除数字，但是可能会由于写错数字的原因，写下包含前导 00 的数字。</p><p>给定贝茜将数字 NN 转换为二进制数字以及三进制数字的结果，请确定 NN 的正确初始值（十进制表示）。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含 NN 的二进制表示，其中一位是错误的。</p><p>第二行包含 NN 的三进制表示，其中一位是错误的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出正确的 NN 的值。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>0≤N≤10<sup>9</sup>，且存在唯一解。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1010</span></span><br><span class="line"><span class="number">212</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>14 在二进制下的正确表示为 1110，在三进制下的正确表示为 112。</p><h2 id="cake-答案"><a href="#cake-答案" class="headerlink" title=":cake:答案"></a>:cake:答案</h2><h3 id="我的答案"><a href="#我的答案" class="headerlink" title="我的答案"></a>我的答案</h3><p>穷举：对a和b分别求其所对应的可能存在的进制数，即将分别修改一位数据的结果穷举出来，然后寻找对应十进制相等的两个进制数即为所求的数。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>穷举</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_dec</span><span class="params">(string s, <span class="keyword">int</span> b)</span>  <span class="comment">// 将b进制转为十进制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 常用算法：秦九韶算法</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        res = res * b + c - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// c - &#x27;0&#x27; 字符转为数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c: a)  <span class="comment">// auto自动识别类型 &amp;表示引用，使用引用是因为我们是直接改本来的数据进行后续计算的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &#x27;0&#x27;的ASCII码是48    &#x27;1&#x27;的ASCII码是49</span></span><br><span class="line"><span class="comment">        所以 &#x27;0&#x27; 异或 1 = &#x27;1&#x27;</span></span><br><span class="line"><span class="comment">             &#x27;1&#x27; 异或 1 = &#x27;0&#x27;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        c ^= <span class="number">1</span>;  <span class="comment">// 异或操作</span></span><br><span class="line">        S.<span class="built_in">insert</span>(<span class="built_in">get_dec</span>(a, <span class="number">2</span>));</span><br><span class="line">        c ^= <span class="number">1</span>;  <span class="comment">// 将c恢复成原来的数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c:b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> t = c;  <span class="comment">// 暂存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="string">&#x27;0&#x27;</span> != t)&#123;</span><br><span class="line">                c = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">get_dec</span>(b, <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span>(S.<span class="built_in">count</span>(x))</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; x &lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rocket-知识点总结"><a href="#rocket-知识点总结" class="headerlink" title=":rocket:知识点总结"></a>:rocket:知识点总结</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7 \sim 10^8$ 为最佳。</p><blockquote><p>比如上面这道题假如枚举所有可能的数N，数据范围为0≤N≤10<sup>9</sup>，而将数据转为二进制或三进制的时间复杂度是$log(n)$，那么这道题的穷举操作次数在$10^9*log(n)$，远超$10^8$次数，所以大概率超时，不可取。</p><p>而如果对给定的二进制数和三进制进行修改某一位得到的数进行穷举，那么数据量将大大减少，二进制数大概30个，三进制数大概50个，操作次数大概30*50*30*30次，则不会超时。</p></blockquote><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol><li>$n \le 30$, 指数级别,  dfs+剪枝，状态压缩dp</li><li>$n \le 100$ =&gt; $O(n^3)$，floyd，dp，高斯消元</li><li>$n \le 1000$ =&gt; $O(n^2)$，$O(n^2logn)$，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li>$n \le 10000$ =&gt; $O(n * \sqrt n)$，块状链表、分块、莫队</li><li>$n \le 100000$ =&gt; $O(nlogn)$ =&gt; 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li>$n \le 1000000$ =&gt; $O(n)$, 以及常数较小的 $O(nlogn)$ 算法 =&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa</li><li>$n \le 10000000$ =&gt; $O(n)$，双指针扫描、kmp、AC自动机、线性筛素数</li><li>$n \le 10^9$ =&gt; $O(\sqrt n)$，判断质数</li><li>$n \le 10^{18}$ =&gt; $O(logn)$，最大公约数，快速幂，数位DP</li><li>$n \le 10^{1000}$ =&gt; $O((logn)^2)$，高精度加减乘除</li><li>$n \le 10^{100000}$ =&gt; $O(logk \times loglogk)，k$表示位数，高精度加减、FFT/NTT</li></ol><h3 id="判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合"><a href="#判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合" class="headerlink" title="判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合"></a>判断一个数是否存在一个集合里，可以使用Hash表来存储这个集合</h3><p>unordered_set</p><p>unordered_map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">unordered_set&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">S.<span class="built_in">insert</span>(数据);  <span class="comment">// 插入数据</span></span><br><span class="line">S.<span class="built_in">count</span>(目标数据);  <span class="comment">// 判断集合中是否包含目标数据</span></span><br></pre></td></tr></table></figure><h3 id="秦九韶算法求十进制数"><a href="#秦九韶算法求十进制数" class="headerlink" title="秦九韶算法求十进制数"></a>秦九韶算法求十进制数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_dec</span><span class="params">(string s, <span class="keyword">int</span> b)</span>  <span class="comment">// 将b进制转为十进制</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 常用算法：秦九韶算法</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        res = res * b + c - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// c-&#x27;0&#x27;字符转为数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="‘0’-和-‘1’-的转换"><a href="#‘0’-和-‘1’-的转换" class="headerlink" title="‘0’ 和 ‘1’ 的转换"></a>‘0’ 和 ‘1’ 的转换</h4><p>‘0’的ASCII码是48    ‘1’的ASCII码是49<br>所以 ‘0’ 异或 1 = ‘1’<br>          ‘1’ 异或 1 = ‘0’</p><p><code>c ^= 1;  // 异或操作</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
          <category> AcWing-每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> AcWing </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客基本设置与美化</title>
      <link href="2022/01/04/%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E4%B8%8E%E7%BE%8E%E5%8C%96/"/>
      <url>2022/01/04/%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E4%B8%8E%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="博客基本设置与美化"><a href="#博客基本设置与美化" class="headerlink" title="博客基本设置与美化"></a>博客基本设置与美化</h1><h2 id="丰富背景样式"><a href="#丰富背景样式" class="headerlink" title="丰富背景样式"></a>丰富背景样式</h2><h3 id="浮层样式集合"><a href="#浮层样式集合" class="headerlink" title="浮层样式集合"></a>浮层样式集合</h3><p>（花瓣飘落、文字，爱心，连线，飘动的彩带）</p><p>修改主题文件夹下的 \layout\_partial 目录中的 <strong>footer.ejs</strong></p><span id="more"></span><blockquote><p>说明：加在footer而不是<a href="https://so.csdn.net/so/search?q=header">header</a>是提高页面加载速度，<br>以下<a href="https://so.csdn.net/so/search?q=cdn">cdn</a>都引用于<a href="https://wallleap.cn/">walllweap</a>大神的<a href="https://github.com/wallleap/cdn">素材库</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--浏览器搞笑标题--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;wallleap&#x2F;cdn@latest&#x2F;js&#x2F;hititle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- 🌸飘落 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;wallleap&#x2F;cdn@latest&#x2F;js&#x2F;sakura.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- 雪花飘落 --&gt;</span><br><span class="line">&lt;!-- &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Yafine&#x2F;cdn@2.5&#x2F;source&#x2F;js&#x2F;snow1.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;</span><br><span class="line">&lt;!-- &#x2F;&#x2F; 文字 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;wallleap&#x2F;cdn&#x2F;js&#x2F;shehuizhuyi.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- &#x2F;&#x2F; 烟花 --&gt;</span><br><span class="line">&lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt; </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt; </span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Yafine&#x2F;cdn@2.5&#x2F;source&#x2F;js&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- &#x2F;&#x2F; 星星跟随坠落 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;cungudafa&#x2F;cdn@2.1.2&#x2F;js&#x2F;cursor.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- &#x2F;&#x2F; 爱心 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;wallleap&#x2F;cdn&#x2F;js&#x2F;love.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- &#x2F;&#x2F; 连线 --&gt;</span><br><span class="line">&lt;!-- &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;wallleap&#x2F;cdn&#x2F;js&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.1&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt; --&gt;</span><br><span class="line">&lt;!-- 样式二（飘动的彩带） --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;wallleap&#x2F;cdn@latest&#x2F;js&#x2F;piao.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!--背景切换--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;&#x2F;instant.page&#x2F;3.0.0&quot; type&#x3D;&quot;module&quot; defer integrity&#x3D;&quot;sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="设置背景图片"><a href="#设置背景图片" class="headerlink" title="设置背景图片"></a>设置背景图片</h3><p>将想要的背景图片放入 themes/next/source/images。打开 themes/next/source/css/ _custom/custom.styl 文件，这个是 Next 故意留给用户自己个性化定制一些样式的文件，添加以下代码即可。</p><p>实际上我的版本里没有_custom，通过新建目录无法实现。我是在 themes/next/source/css/_schemes/Gemini/index.styl 中添加的代码，Gemini是我的 next 的布局样式。</p><p>在写这篇博客的过程中，又尝试了下将代码添加到 blog_root/source/_data/styles.style 下，设置成功。如果没有这个目录，直接新建即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/images/yourbackground.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; //不重复</span><br><span class="line">    <span class="attribute">background-size</span>: cover;      //填充</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>background:url 为图片路径，也可以直接使用链接。</li><li>background-repeat：若果背景图片不能全屏，那么是否平铺显示，充满屏幕</li><li>background-attachment：背景是否随着网页上下滚动而滚动，fixed 为固定</li><li>background-size：图片展示大小，这里设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示。</li></ul><h3 id="博客内容透明化"><a href="#博客内容透明化" class="headerlink" title="博客内容透明化"></a>博客内容透明化</h3><p>NexT 主题的博客文章均是不透明的，这样读者就不能好好欣赏背景图片了，下面的方法可以使博客内容透明化：</p><p>在 blog_root/source/_data/styles.style 中添加以下内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：其中 header-inner 不能使用 opacity 进行配置。因为 header-inner 包含 header.swig 中的所有内容。若使用 opacity 进行配置，子结点会出很多问题。</p><h2 id="设置文章末尾“本文结束”标记"><a href="#设置文章末尾“本文结束”标记" class="headerlink" title="设置文章末尾“本文结束”标记"></a>设置文章末尾“本文结束”标记</h2><p>在路径/themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:24px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>接着打开/themes/next/layout/_macro/post.swig文件，在post-footer前添加代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not is_index and theme<span class="selector-class">.passage_end_tag</span><span class="selector-class">.enabled</span> %&#125;</span><br><span class="line">  &lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>具体位置如下图：</p><p><img src="/2022/01/04/%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E4%B8%8E%E7%BE%8E%E5%8C%96/v2-a449da45307774c93857b03b6585a0b7_720w.jpg" alt="具体位置"></p><p>然后打开<strong>主题配置文件</strong>（_config.yml)，在末尾添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><h2 id="设置文本框的边角弧度"><a href="#设置文本框的边角弧度" class="headerlink" title="设置文本框的边角弧度"></a>设置文本框的边角弧度</h2><p>在<code>Blog/source/_data</code>目录下新建<code>variables.styl</code> ，打开<code>variables.styl</code>，添加如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 圆角设置</span><br><span class="line">$border-radius-inner     = 20px 20px 20px 20px;</span><br><span class="line">$border-radius           = 20px;</span><br></pre></td></tr></table></figure><h2 id="设置文本框的阴影"><a href="#设置文本框的阴影" class="headerlink" title="设置文本框的阴影"></a>设置文本框的阴影</h2><p>修改Blog\themes\next\source\css_variables目录下的Gemini.styl文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Borders.</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$box-shadow-inner        = 0 2px 10px 0 rgba(0, 0, 0, .12), 0 3px 10px -2px rgba(0, 0, 0, .06), 0 1px 10px 0 rgba(0, 0, 0, .12);</span><br><span class="line">$box-shadow              = 0 2px 10px 0 rgba(0, 0, 0, .12), 0 3px 10px -2px rgba(0, 0, 0, .06), 0 1px 10px 0 rgba(0, 0, 0, .12), 0 -1px 10px 0 rgba(0, 0, 0, .09);</span><br></pre></td></tr></table></figure><h2 id="在页面首部添加置顶图案"><a href="#在页面首部添加置顶图案" class="headerlink" title="在页面首部添加置顶图案"></a>在页面首部添加置顶图案</h2><p>修改Blog\themes\next\layout\_layout.swig中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-inner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-wrap&quot;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 设置首页头部图片 暂时做成这样，之后改成halo主题的 一行三个推荐页--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-block&quot;</span> <span class="attr">style</span>=<span class="string">&quot;opacity: 1;display: block; padding:0px&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; url_for(theme.headerimg) &#125;&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;头部图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius:5px; height:300px;width:100%;opacity:0.65;&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Blog\themes\next\_config.yml中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首页头部图片</span></span><br><span class="line"><span class="attr">headerimg:</span> <span class="string">/images/bg.jpg</span></span><br></pre></td></tr></table></figure><h2 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h2><p>打开<code>Blog/themes/next/source/css/_variables/base.styl</code>，找到Colors代码段，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Colors</span></span><br><span class="line"><span class="comment">// colors for use across theme.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------</span></span><br><span class="line">  <span class="variable">$whitesmoke</span>   = <span class="number">#f5f5f5</span></span><br><span class="line">  <span class="variable">$gainsboro</span>    = <span class="number">#eee</span>  <span class="comment">//这个是边栏头像外框的颜色，</span></span><br><span class="line">  <span class="variable">$gray</span>-lighter = <span class="number">#ddd</span>  <span class="comment">//文章中插入图片边框颜色</span></span><br><span class="line">  <span class="variable">$grey</span>-light   = <span class="number">#ccc</span>  <span class="comment">//文章之间分割线、下划线颜色</span></span><br><span class="line">  <span class="variable">$grey</span>         = <span class="number">#bbb</span>  <span class="comment">//页面选中圆点颜色</span></span><br><span class="line">  <span class="variable">$grey</span>-dark    = <span class="number">#999</span></span><br><span class="line">  <span class="variable">$grey</span>-dim     = <span class="number">#666</span> <span class="comment">//侧边栏目录字体颜色</span></span><br><span class="line">  <span class="variable">$black</span>-light  = <span class="number">#555</span> <span class="comment">//修改文章字体颜色</span></span><br><span class="line">  <span class="variable">$black</span>-dim    = <span class="number">#333</span></span><br><span class="line">  <span class="variable">$black</span>-deep   = <span class="number">#495a80</span>  <span class="comment">//修改主题的颜色，这里我已经改成老蓝色了。</span></span><br><span class="line">  <span class="variable">$red</span>          = <span class="number">#ff2a2a</span></span><br><span class="line">  <span class="variable">$blue</span>-bright  = <span class="number">#87daff</span></span><br><span class="line">  <span class="variable">$blue</span>         = <span class="number">#0684bd</span></span><br><span class="line">  <span class="variable">$blue</span>-deep    = <span class="number">#262a30</span></span><br><span class="line">  <span class="variable">$orange</span>       = <span class="number">#F39D01</span> <span class="comment">//浏览文章时，目录选中的颜色</span></span><br></pre></td></tr></table></figure><p>其他的可以自行更改，看看效果</p><h2 id="修改主题字体"><a href="#修改主题字体" class="headerlink" title="修改主题字体"></a>修改主题字体</h2><p>修改主题_config.yml文件中font部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="string">ture</span>  <span class="comment"># 是否启用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span>  <span class="comment"># 字体样式</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Zhi</span> <span class="string">Mang</span> <span class="string">Xing</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">2.3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Source</span> <span class="string">Code</span> <span class="string">Pro</span></span><br></pre></td></tr></table></figure><h1 id="预备方案"><a href="#预备方案" class="headerlink" title="预备方案"></a>预备方案</h1><h2 id="添加封面"><a href="#添加封面" class="headerlink" title="添加封面"></a>添加封面</h2><p>参考halo的主题</p><h2 id="将头部图片改成一行三个同时设置为跳转到三个链接"><a href="#将头部图片改成一行三个同时设置为跳转到三个链接" class="headerlink" title="将头部图片改成一行三个同时设置为跳转到三个链接"></a>将头部图片改成一行三个同时设置为跳转到三个链接</h2><p>参考Halo主题</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统-课堂答疑</title>
      <link href="2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/"/>
      <url>2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库答疑知识点汇总"><a href="#数据库答疑知识点汇总" class="headerlink" title="数据库答疑知识点汇总"></a>数据库答疑知识点汇总</h2><h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><ul><li><p>order by 可以使用select使用别名之前的名字</p></li><li><p>除了from以外，其他语句用的都是一个表（from合成后的表）。from的作用就是串起来其他的表。</p></li><li><p>多表连接的两种方法</p><span id="more"></span><ul><li><p>join</p></li><li><p>‘ , ‘        本质：笛卡尔乘积</p><ul><li><p><code>from emp,dept</code></p><p><code>where emp.deptno=dept.deptno</code></p><blockquote><p>缺点：</p><p>​    1、不易分辨拼接语句和其他条件语句</p><p>​    2、不能实现外连接功能</p><p>优点：</p><p>​    1、用代码实现好实现</p></blockquote></li></ul></li></ul></li><li><p>内连接：连接结果中只包含满足连接条件的</p></li><li><p>外连接：在内连接基础上将某些未满足连接条件的连接结果也包含在内</p><ul><li>left （outer） join            right （outer） join</li><li>没有直接outer join这种表示方法，用full (outer) join表示全连接</li></ul></li><li><p>多表连接，实际就是进行多次双表连接</p></li><li><p>起别名</p><ul><li>对表起别名</li><li>对列起别名</li><li>对表表达式起别名（sql语句  一定有select）</li></ul><blockquote><p>from emp join dept on emp.deptno=dept.deptno   as  tab   ❌</p></blockquote></li><li><p>外连接要一路走到黑</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Employee_id,EMPLOYEES.Department_id</span><br><span class="line"><span class="keyword">from</span> EMPLOYEES <span class="keyword">full</span> <span class="keyword">join</span> DEPARTMENTS</span><br><span class="line">    <span class="keyword">on</span> EMPLOYEES.Department_id<span class="operator">=</span>DEPARTMENTS.Department_id</span><br><span class="line">    <span class="keyword">full</span> <span class="keyword">join</span> JOBS </span><br><span class="line">    <span class="keyword">on</span> EMPLOYEES.Salary<span class="operator">&gt;=</span>JOBS.Min_salary <span class="keyword">and</span> EMPLOYEES.Salary<span class="operator">&lt;=</span>Max_salary</span><br></pre></td></tr></table></figure><p>如果<code>full join JOBS </code>改为<code>join JOBS</code>，会导致部分行丢失，就没有达到我们保留所有行的目的。</p></li><li><p>null 参与的运算结果都是unknown</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department_id,Department_name,Location_id</span><br><span class="line"><span class="keyword">from</span> DEPARTMENTS</span><br><span class="line"><span class="keyword">where</span> Department_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/image-20210612234531893.png" alt="image-20210612234531893"></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department_id,Department_name,Location_id</span><br><span class="line"><span class="keyword">from</span> DEPARTMENTS</span><br><span class="line"><span class="keyword">where</span> Department_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">20</span>,<span class="number">30</span>,<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/image-20210612234610657-1623512773526.png" alt="image-20210612234610657"></p></blockquote><blockquote><p>解释：</p><p>数据库管理系统在执行查询之前，会对<code>Department_id not in (20,30,null)</code>进行简单的转化，转化之后的语句为<code>Department_id != 2 and Department_id != null</code>。Department_id != null的结果是(非null时)unknown /（null时）false。</p></blockquote></li></ul><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul><li><p>sql中 列名、nvl(sal,0)、(select count(*) from emp)、case when   end  等返回一个值的都是表达式，然后都可以出现在case中</p></li><li><p>case作用：类似C中switch     用来分支判断</p></li><li><p>select语句作用：</p><ul><li>select h1,h2  <strong>逐行</strong>运算表达式   通过对输入的表进行逐行运算<ul><li>输入多少行，就输出多少行</li><li>select 1 from emp   输出emp的行数个值为1的行</li></ul></li></ul></li><li><p>case的两种形式</p><ul><li>case  列名  when 标量 then …end</li><li>case when 表达式  then …end</li></ul></li></ul><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><ul><li><p>判断是否相关？</p><ul><li>子查询是否可以独立运行</li><li>嵌套的子查询是否用到了外部查询语句中的表或重命名的表</li></ul></li><li><p>相关子查询本质：对外部表的每一行依此进行执行select子查询</p><ul><li>类似双重循环，只不过内部循环使用外部循环的变量</li></ul></li><li><p>不相关子查询执行顺序</p><ul><li>当外层查询执行到子查询位置时，子查询已经进行完成并将结果（标量）返回给外查询</li></ul></li></ul><h3 id="not-exists"><a href="#not-exists" class="headerlink" title="not exists"></a>not exists</h3><ul><li><p>就是一个函数 返回true/false</p></li><li><p>exists(括号内一般是表表达式（即集合、select语句，一般是相关子查询)）</p><ul><li>输入集合有值：返回true， 没值：false</li><li>如果是  exists(select返回值是一行，但是其值为null)  ？也是有值，返回true</li></ul></li><li><p>没有group by时，是将所有的数据当作一个组处理，可以直接用having 。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department_name, Location_id</span><br><span class="line"><span class="keyword">from</span> DEPARTMENTS</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">null</span> <span class="comment">--这里用*或者1都是可以的</span></span><br><span class="line">    <span class="keyword">from</span> EMPLOYEES</span><br><span class="line">    <span class="keyword">where</span> EMPLOYEES.Department_id<span class="operator">=</span>DEPARTMENTS.Department_id</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/image-20210612223101902.png" alt="image-20210612223101902"></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> EMPLOYEES</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/image-20210612222803220.png" alt="image-20210612222803220" style="zoom:80%;"></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">from</span> EMPLOYEES</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/image-20210612222842593.png" alt="image-20210612222842593"></p></blockquote><ul><li><p>但是此时select子语句不能是*  列名等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> EMPLOYEES</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> Employee_id</span><br><span class="line"><span class="keyword">from</span> EMPLOYEES</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/image-20210612223230906.png" alt="image-20210612223230906"></p></blockquote></li></ul></li><li><p>相关子查询和exists用法举例</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department_id,Department_name,Location_id</span><br><span class="line"><span class="keyword">from</span> DEPARTMENTS</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> Department_id</span><br><span class="line">    <span class="keyword">from</span> EMPLOYEES</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> Department_id</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">5</span> <span class="keyword">and</span> DEPARTMENTS.Department_id<span class="operator">=</span>EMPLOYEES.Department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department_id,Department_name,Location_id</span><br><span class="line"><span class="keyword">from</span> DEPARTMENTS</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> Department_id</span><br><span class="line">    <span class="keyword">from</span> EMPLOYEES</span><br><span class="line">    <span class="keyword">where</span> DEPARTMENTS.Department_id<span class="operator">=</span>EMPLOYEES.Department_id</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> Department_id</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">5</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注：where中不可以使用聚集函数</p></blockquote><blockquote><p>注：where和group by可以一起使用</p></blockquote><ul><li>当有group by时，select子语句必须是group by后的数据，或聚集函数，或常数</li></ul><h3 id="代数除法"><a href="#代数除法" class="headerlink" title="代数除法"></a>代数除法</h3><ul><li>理解：</li></ul><ul><li><p>sql实现：</p><p>通过相关子查询进行查询</p><p>关键：<strong>A包含B</strong>   即B-A的结果为空， “小差大”  </p><ul><li><p>例如：学生 not exists (二年级课程  minus/except  该学生选的课)</p></li><li><p>例如：查找包括了所有平均工资大于15000的职业的部门</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Department_id,Department_name</span><br><span class="line"><span class="keyword">from</span> DEPARTMENTS</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> JOB_ID</span><br><span class="line">    <span class="keyword">from</span> EMPLOYEES</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> JOB_ID</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">avg</span>(Salary)<span class="operator">&gt;</span><span class="number">15000</span></span><br><span class="line">    minus</span><br><span class="line">    <span class="keyword">select</span> JOB_ID</span><br><span class="line">    <span class="keyword">from</span> EMPLOYEES</span><br><span class="line">    <span class="keyword">where</span> EMPLOYEES.Department_id<span class="operator">=</span>DEPARTMENTS.Department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/image-20210613001729437.png" alt="image-20210613001729437"></p></blockquote></li></ul></li></ul><h3 id="E-R"><a href="#E-R" class="headerlink" title="E-R"></a>E-R</h3><ul><li>E-R图转换为关系模式<ul><li>关系模式的数量=E-R图实体集+E-R图多对多联系的数量</li></ul></li></ul><p><img src="/2021/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_%E8%AF%BE%E5%A0%82%E7%AD%94%E7%96%91/IMG_20210612_205823_edit_159802250906863.jpg" alt="IMG_20210612_205823_edit_159802250906863"></p><blockquote><p>当一对多或一对一的联系集中有描述性属性时，可以放到实体集中，也可以单独提出来作为一个关系模式</p></blockquote><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><ul><li><p>数据依赖</p><ul><li>单值依赖（函数依赖）：当t<sub>1</sub>(α)=t<sub>2</sub>(α)时，总有t<sub>1</sub>(β)=t<sub>2</sub>(β)</li><li>α决定β  或称  β依赖α</li></ul></li><li><p>函数依赖类型</p><ul><li><p>平凡/非平凡</p><ul><li><p>平凡   β包含于α时，α→β       例如：AB→A   </p></li><li><p>非平凡的    例如：AB→BC    A→B</p><ul><li>部分函数依赖</li></ul><blockquote><p>(sno,cno)→sname  就是部分函数依赖，因为存在sno→sname</p><blockquote><p>为什么不直接用(sno)→sname？  因为(sno,cno)是关系模式的码，一般找与码有关的函数依赖</p></blockquote></blockquote><ul><li>完全函数依赖</li></ul><blockquote><p>sno→sname</p></blockquote><ul><li>传递函数依赖</li></ul><blockquote><p>sno→dno→dname</p></blockquote></li></ul></li></ul></li><li><p>2NF   消除了非主属性对于码的部分函数依赖</p></li><li><p>3NF   消除了非主属性对于码的传递函数依赖</p><blockquote><p>消除了非主属性对于码的传递函数依赖就已经消除了非主属性对于码的部分函数依赖</p></blockquote></li><li><p>BCNF   消除了主属性对于码的部分函数依赖、传递函数依赖</p></li><li><p>如何确定码？</p><ul><li><p>能通过函数依赖确定所有属性的，就是码</p><blockquote><p>如R(A,B,C,D,E)，F{A→B; C→DE; AB→CE}找出所有的候选码。</p><p>解：</p><p>先写出F<sup>+</sup>{A→B; C→DE; AB→CE; A→ABCDE}</p><p>所有只在函数依赖右边出现，而不在左边出现的，都不可能是候选码，所以只考虑A,B,C</p><p>只知道A可以推出所有ABCDE，即A<sup>+</sup>=R，所以A→R，A是候选码</p><p>而B、C不可以，所以B、C不是候选码</p></blockquote></li></ul></li><li><p>判断是否满足BCNF  —即是否都满足两个条件之一</p><ul><li>平凡函数依赖</li><li>函数依赖的决定因素是否是超码</li></ul></li></ul><blockquote><p>接着上面一题，F<sup>+</sup>{A→B; C→DE; AB→CE; A→ABCDE}  主码是A</p><p>先找出所有左边不是超码的函数依赖，这里面是C→DE，即是由于C→DE导致不满足BCNF</p><p>就将他单独拿出来作为一个关系模式R2(CDE)，原关系模式去掉C→DE中右边存在而不在左边存在的属性即DE作为另一个关系模式R1(ABC)。</p><p>即实现R的BCNF分解，R分解成两个BC范式R1和R2。</p></blockquote><blockquote><p>即r(R)由于α→β导致不满足BCNF，就拆分成r1(R-(β-α))和r2(α∪β)</p></blockquote><ul><li>分解（包括BCNF）都要是无损分解</li></ul><blockquote><p>无损：例如r拆分成r1和r2，r1 natural join r2 要和原来的r的数据一样</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-数据链路层和局域网</title>
      <link href="2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
      <url>2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-数据链路层和局域网"><a href="#计算机网络-数据链路层和局域网" class="headerlink" title="计算机网络-数据链路层和局域网"></a>计算机网络-数据链路层和局域网</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul><li>网络层解决了一个网络如何到达另外一个网络的路由问题。在一个网络内部如何由一个节点（主机或者路由器）到达另外一个相邻节点？—链路层的点到点传输层功能</li><li>目标:<ul><li><p>理解数据链路层服务的原理:</p><ul><li>检错和纠错</li><li>共享广播信道：多点接入（多路访问）</li><li>链路层寻址</li><li>LAN:以太网、WLAN、VLANs</li><li>可靠数据传输，流控制: 解决!</li></ul></li><li><p>实例和各种链路层技术的实现</p><span id="more"></span></li></ul></li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210510212247175.png" alt="概述"></p><ul><li><p>一个子网中的若干节点是如何连接到一起的？</p><ul><li>点到点连接</li><li>多点连接<ul><li>共享型介质</li><li>通过网络交换机</li></ul></li></ul><blockquote><p>一般来说，局域网是多点连接，实现比较复杂；而广域网是点到点连接，实现相对简单。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511212212995.png" alt="一个子网中的若干节点是如何连接到一起的？"></p></li><li><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511212338477.png" alt="链路层：上下文"></p></li><li><p>数据链路层服务</p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210510213213501.png" alt="链路层服务1"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511212938351.png" alt="链路层服务2"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210510213516860.png" alt="链路层服务3"></p></li></ul><blockquote><p>以上功能并不是所有链路层都全部实现的，有的链路层只是实现了部分功能。</p></blockquote><ul><li>链路层的具体实现</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210510213631618.png" alt="链路层的具体实现"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210510213706374.png" alt="网卡间通信"></p><h3 id="2-差错检测"><a href="#2-差错检测" class="headerlink" title="2. 差错检测"></a>2. 差错检测</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511214146161.png" alt="差错编码原理"></p><blockquote><p>差错编码不能保证100%正确。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511234046203.png" alt="差错编码的检错能力"></p><ul><li>常见的差错编码</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511234703213.png" alt="奇偶校验码"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511235056619.png" alt="Checksum"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511235432146.png" alt="CRC"></p><blockquote><p>模2运算，即异或运算</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210511235834302.png" alt="CRC举例"></p><blockquote><p>G是发送方和接收方约定好的生成多项式</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512000758328.png" alt="CRC性能分析"></p><h3 id="3-多点访问协议"><a href="#3-多点访问协议" class="headerlink" title="3. 多点访问协议"></a>3. 多点访问协议</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512001052632.png" alt="两种链路"></p><ul><li>解决单一共享广播信道的接入问题：MAC协议</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512002737886.png" alt="MAC协议"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512002902453.png" alt="理想MAC协议"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512003119913.png" alt="MAC协议分类"></p><h4 id="3-1-信道划分MAC协议"><a href="#3-1-信道划分MAC协议" class="headerlink" title="3.1 信道划分MAC协议"></a>3.1 信道划分MAC协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512003155337.png" alt="TDMA"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512003332647.png" alt="FDMA"></p><h4 id="3-2-随机访问MAC协议"><a href="#3-2-随机访问MAC协议" class="headerlink" title="3.2 随机访问MAC协议"></a>3.2 随机访问MAC协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512003630498.png" alt="随机访问MAC协议"></p><ul><li>时隙ALOHA协议</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512004017258.png" alt="时隙ALOHA协议"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512004246847.png" alt="时隙ALOHA协议优缺点"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512004508786.png" alt="时隙ALOHA协议的效率"></p><ul><li>ALOHA协议</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512004642533.png" alt="ALOHA协议"></p><blockquote><p>t<sub>0</sub>-1到t<sub>0</sub>+1  易损时间区     –两个时隙。</p><p>时隙ALOHA协议易损时间区   –一个时隙</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512004938459.png" alt="ALOHA协议的效率"></p><ul><li>CSMA协议</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512010439949.png" alt="CSMA协议"></p><blockquote><p>CSMA检测冲突是只在发送帧之前监听信道，而在发送帧的过程中不再监听信道，这将导致即使发生冲突了仍会继续发送冲突帧而浪费信道资源。</p></blockquote><ul><li>以太网CSMA/CD协议</li></ul><blockquote><p>CSMA/CD协议是在发送帧的同时就可以检测是否有冲突</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512011307257.png" alt="CSMA/CD"></p><blockquote><p>CD是不仅在发送帧之前监听信道，在发送帧的过程中仍在监听信道。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512142945641.png" alt="以太网CSMA/CD"></p><blockquote><p>发送强化冲突信号是为了让所有站点都知道发生冲突了</p></blockquote><blockquote><p>二进制指数退避算法（exponential backoff）：（在等待时间和再次发生碰撞可能性两个矛盾之间取得一个较为均衡的结果）</p><p>第一次碰撞m=1  两个适配器冲突发送失败的适配器在{0,1}之间选择一个i   即等待i*512位时之后再进行监听发送    所以再次发送失败的概率为1/2</p><p>第二次碰撞m=2  两个适配器冲突发送失败的适配器在{0,1,2,3}之间选择一个i   即等待i*512位时之后再进行监听发送    所以再次发送失败的概率为1/4</p><p>第二次碰撞m=3  两个适配器冲突发送失败的适配器在{0,1,2,3,4,5,6,7}之间选择一个i   即等待i*512位时之后再进行监听发送    所以再次发送失败的概率为1/8</p><p>……</p><p>几次尝试后放弃(通常是16次)，然后向主机报告传送错误</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512011941561.png" alt="CSMA/CD需满足等式"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512012222585.png" alt="例题"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512012404196.png" alt="CSMA/CD效率"></p><ul><li>无线局域网WLAN中CSMA/CA</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512144459710.png" alt="CSMA/CA"></p><blockquote><p>移动主机节点会通过无线信道向基站AP发送电磁波，但是由于多个主机向同一个基站发送同样频段的信号，同样会发生冲突。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512145412284.png" alt="CSMA/CA"></p><blockquote><p>CSMA/CD检测冲突不适用于无线网，因为无线网电磁波与距离平方成反比进行衰减，自身发送的信号要比接收到的其他节点的信号强的多，同时在开放空间会受到其他信号的干扰。所以802.11不进行冲突检测。</p><p>同时在以太网LAN中不冲突基本等于发送成功，而WLAN中不冲突不等于发送成功（可能由于山川等阻隔原因、与基站距离原因而传送失败）。</p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512151509457.png" alt="对于WALN而言冲突检测问题"></p><p>所以WLAN不能采用CSMA/CD冲突检测，没有用，而是采用CSMA/CA发送帧之前来避免冲突。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512151747211.png" alt="CSMA/CA"></p><blockquote><p>以太网中信道质量好，所以不做ACK确认帧的传输。而在WLAN中信道质量不好需要确认。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512152506821.png" alt="CSMA/CA冲突避免"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512155551626.png" alt="CSMA/CA无法完全避免冲突"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512155619651.png" alt="CSMA/CA无法完全避免冲突2"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512155638963.png" alt="RTS-CTS交换"></p><h4 id="3-3-轮转访问MAC协议"><a href="#3-3-轮转访问MAC协议" class="headerlink" title="3.3 轮转访问MAC协议"></a>3.3 轮转访问MAC协议</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512012558906.png" alt="三种方法比较"></p><ul><li><p>轮转访问MAC协议既不是最好也不是最坏，比较综合。</p></li><li><p>轮询方式</p></li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512013145993.png" alt="轮转访问MAC协议-轮询"></p><ul><li>令牌传递方式</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512013752940.png" alt="轮转访问MAC协议-令牌传递方式"></p><ul><li>总结</li></ul><p>解决多点接入问题：对于一个共享型介质，各个节点如何协调对它的访问和使用？</p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512013950395.png" alt="总结"></p><blockquote><p>CSMA/CD应用于802.3Ethernet网</p><p>CSMA/CA应用于802.11WLAN中</p></blockquote><blockquote><p>轮转访问MAC协议：<br>主节点轮询是集中式的    令牌传递是分布式的</p></blockquote><h3 id="4-LANs"><a href="#4-LANs" class="headerlink" title="4. LANs"></a>4. LANs</h3><h4 id="4-1-MAC地址"><a href="#4-1-MAC地址" class="headerlink" title="4.1 MAC地址"></a>4.1 MAC地址</h4><ul><li>网络层：IPv4的32位IP地址<ul><li>接口的网络层地址</li><li>用于标识网络层（第3层）分组，支持分组转发</li></ul></li><li>MAC地址是链路层地址</li><li>MAC地址是固定的，（也可手动修改），但是需保证一个局域网内的MAC地址（即物理地址）是互不相同的</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512160957066.png" alt="MAC地址"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512161017732.png" alt="MAC地址局域网内唯一"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512161429645.png" alt="MAC地址特点"></p><h4 id="4-2-ARP：地址解析协议"><a href="#4-2-ARP：地址解析协议" class="headerlink" title="4.2 ARP：地址解析协议"></a>4.2 ARP：地址解析协议</h4><ul><li>局域网：数据链路层的概念，指二层可达的网络（也就是不需要三层设备，如路由器，也能到达的网络），通俗得讲就是小范围的网络</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512162017813.png" alt="ARP：地址解析协议"></p><ul><li>同一个局域网下的ARP协议</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512163013409.png" alt="同一个局域网下的ARP协议"></p><ul><li>不是同一个局域网下的ARP协议</li></ul><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512163418607.png" alt="不同一个局域网下的ARP协议-寻址"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512163602990.png" alt="不同一个局域网下的ARP协议-寻址2"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512163641357.png" alt="不同一个局域网下的ARP协议-寻址3"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512163805021.png" alt="不同一个局域网下的ARP协议-寻址3"></p><blockquote><p>在R的网络层，可能会对数据报的IP地址进行改变（NAT协议 内网和广域网之间IP转换）</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512164559330.png" alt="不同一个局域网下的ARP协议-寻址4"></p><h4 id="4-3-以太网（Ethernet）"><a href="#4-3-以太网（Ethernet）" class="headerlink" title="4.3 以太网（Ethernet）"></a>4.3 以太网（Ethernet）</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512231646969.png" alt="以太网"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512231937042.png" alt="以太网：物理拓扑"></p><blockquote><p><strong>冲突域（collision domain）</strong>：交换机的某一个端口不再连接另外的交换机或网络，只是连接到主机，则称这个链路为冲突域。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512232128837.png" alt="以太网特点"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512232749266.png" alt="以太网CSMA/CD算法"></p><blockquote><p>二进制指数退避，冲突16次就不再进行尝试了。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512233143142.png" alt="以太网帧结构1"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512233537087.png" alt="以太网帧结构2"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512233904063.png" alt="以太网标准"></p><h4 id="4-4-交换机（switch）"><a href="#4-4-交换机（switch）" class="headerlink" title="4.4 交换机（switch）"></a>4.4 交换机（switch）</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512234157284.png" alt="交换机特点"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512234332046.png" alt="交换机：多端口间同时传输"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512234531746.png" alt="交换表"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512234639836.png" alt="自学习构建交换表"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512234912961.png" alt="帧过滤"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512235208782.png" alt="交换机互联"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512235600010.png" alt="组织机构网络"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210512235821137.png" alt="交换机 vs. 路由器"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513000328511.png" alt="网络设备对比"></p><h4 id="4-5-虚拟局域网（VLAN）"><a href="#4-5-虚拟局域网（VLAN）" class="headerlink" title="4.5 虚拟局域网（VLAN）"></a>4.5 虚拟局域网（VLAN）</h4><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513000826859.png" alt="VLAN必要性"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513000925584.png" alt="VLAN"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513001115423.png" alt="基于端口的VLAN"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513001538980.png" alt="跨越多交换机的VLAN"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513001727415.png" alt="802.1Q帧格式"></p><h3 id="5-802-11无线局域网"><a href="#5-802-11无线局域网" class="headerlink" title="5 802.11无线局域网"></a>5 802.11无线局域网</h3><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513002332754.png" alt="802.11无线局域网"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513002422272.png" alt="802.11无线局域网"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513002612733.png" alt="802.11体系结构"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513003035200.png" alt="信道与AP关联"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513003207972.png" alt="AP关联"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513003424197.png" alt="多路访问控制"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513003718392.png" alt="CSMA/CA"></p><blockquote><p>802.11需要进行可靠性传输保证，需要ACK确认收到帧。</p></blockquote><blockquote><p>802.11通过空闲时间长短（DIFS和SIFS）来判断优先级，实践越短优先级越高。SIFS比DIFS短，所以ACK一般先发送。</p></blockquote><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513004126740.png" alt="CA基本思想"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513004322601.png" alt="RTS-CTS交换"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513004516578.png" alt="802.11 MAC帧格式"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513004647994.png" alt="数据帧地址"></p><p><img src="/2021/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_04%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/image-20210513004846692.png" alt="举例"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-网络层：控制平面</title>
      <link href="2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"/>
      <url>2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-网络层：控制平面"><a href="#计算机网络-网络层：控制平面" class="headerlink" title="计算机网络-网络层：控制平面"></a>计算机网络-网络层：控制平面</h2><h3 id="1-导论"><a href="#1-导论" class="headerlink" title="1. 导论"></a>1. 导论</h3><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210427201135894.png" alt="网络层功能"></p><span id="more"></span><h3 id="2-路由选择算法"><a href="#2-路由选择算法" class="headerlink" title="2. 路由选择算法"></a>2. 路由选择算法</h3><ul><li><p>路由:按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径</p><ul><li>较好路径: 按照某种指标较小的路径</li><li>指标:站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均</li><li>采用什么样的指标，表示网络使用者希望网络在什么方面表现突出，什么指标网络使用者比较重视</li></ul></li><li><p>以网络为单位进行路由（路由信息通告+路由计算）</p><ul><li>网络为单位进行路由，路由信息传输、计算和匹配的代价低</li><li>前提条件是：一个网络所有节点地址前缀相同，且物理上聚集</li><li>路由就是：计算网络到其他网络如何走的问题</li></ul></li><li><p>网络到网络的路由 = 路由器-路由器之间路由</p><ul><li>网络对应的路由器到其他网络对应的路由器的路由</li><li>在一个网络中：路由器-主机之间的通信，链路层解决</li><li>到了这个路由器就是到了这个网络</li></ul></li><li><p>路由选择算法(routing algorithm)：网络层软件的一部分,完成路由功能</p></li><li><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210427203204658.png" alt="网络的图抽象1"></p></li></ul><p> <img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210428224703656.png" alt="费用"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210501175511806.png" alt="最优化原则"></p><ul><li><p>路由选择算法的原则</p><ul><li>正确性(correctness):算法必须是正确的和完整的，使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址；</li><li>简单性(simplicity):算法在计算机上应简单：最优但复杂的算法，时间上延迟很大，不实用，不应为了获取路由信息增加很多的通信量；</li><li>健壮性(robustness):算法应能适应通信量和网络拓扑的变化：通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发数据，不向断了的链路发送数据；</li><li>稳定性(stability)：产生的路由不应该摇摆</li><li>公平性(fairness)：对每一个站点都公平</li><li>最优性(optimality)：某一个指标的最优，时间上，费用上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li></ul></li><li><p>路由算法分类</p></li></ul><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210428230516251.png" alt="路由算法"></p><blockquote><p>静态路由：非自适应算法（non-adaptive algorithm）：不能适应网络拓扑和通信量的变化，路由表是事先计算好的。</p><p>动态路由：自适应路由选择（adaptive algorithm）：能适应网络拓扑和通信量的变化。</p></blockquote><ul><li>链路状态路由算法和距离矢量路由算法都是动态路由选择算法。其中链路状态路由算法利用的是全局信息，而距离矢量路由算法利用的是分散信息。</li></ul><h4 id="2-1-链路状态路由算法"><a href="#2-1-链路状态路由算法" class="headerlink" title="2.1 链路状态路由算法"></a>2.1 链路状态路由算法</h4><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210501180127082.png" alt="LS路由工作过程"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210501180239162.png" alt="ls路由"></p><blockquote><p>泛洪传递信息，可能遇到问题：发生信息风暴</p><p>解决方案：</p><ol><li>顺序号：类似于版本号，用于控制无穷的扩散。如果发现有相同的或更老的顺序号的分组传递过来，就将其丢弃。</li><li>年龄字段（AGE）：类似于TTL，每过一个时间段，AGE减一，减为零以后丢弃。</li></ol></blockquote><p>​    <img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210501181558907.png" alt="LS分组的扩散"></p><ul><li><p>Dijkstra算法</p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429103921468.png" alt="Dijkstra算法"></p></li></ul><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429104051152.png" alt="Dijkstra算法1"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210501181814898.png" alt="LS工作原理"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429104226152.png" alt="Dijkstra示例1"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429104253078.png" alt="Dijkstra示例2"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429104339907.png" alt="Dijkstra示例2 u的转发表"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429104652464.png" alt="讨论"></p><blockquote><p>所以如果转发表更新过快，可能导致报文一直难以被传送到目的地而一直在链路中绕圈，因此一般会给链路表一个更新的延迟时间。</p></blockquote><h4 id="2-2-距离向量路由算法"><a href="#2-2-距离向量路由算法" class="headerlink" title="2.2 距离向量路由算法"></a>2.2 距离向量路由算法</h4><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429105048675.png" alt="距离向量路由算法原理"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429105241726.png" alt="Bellman-Ford举例"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429105630026.png" alt="距离向量路由算法"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429105925809.png" alt="距离向量路由算法特点"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429111142396.png" alt="举例"></p><blockquote><p>x和z节点重新计算之后距离向量发生变化，所以还需要再次重新计算，直到重新计算都不发生变换位置。</p></blockquote><ul><li><p>链路费用发生改变：</p><ul><li>好消息传播的快！</li></ul><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429194822985.png" alt="好消息传播的快"></p><blockquote><p>这里只讨论y和z之间影响下y和z到达x的最小距离</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509170554570.png" alt="好消息传播的快"></p><ul><li><p>坏消息传播的慢</p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210429195405694.png" alt="坏消息传播的慢"></p><blockquote><p>如果其中有环路的话，有可能导致传播很多次，无穷计数</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509170618072.png" alt="坏消息传播的慢"></p></li><li><p>无穷计数问题解决方案：</p><ul><li>方法一：水平分裂/毒性逆转</li></ul><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509171411449.png" alt="水平分裂算法"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509171515012.png" alt="水平分裂算法不足"></p><ul><li>方法二：定义路径度量（代价）的最大值</li></ul></li></ul></li></ul><h4 id="2-3-两种路由算法比较"><a href="#2-3-两种路由算法比较" class="headerlink" title="2.3 两种路由算法比较"></a>2.3 两种路由算法比较</h4><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509171833204.png" alt="两种路由算法比较"></p><ul><li><p>收敛时间</p><ul><li>链路状态算法得知所有路由信息后，根据Dijkstra算法就可以一次得到路由表</li><li>距离矢量算法却需要多次迭代才能获得路由表</li></ul></li><li><p>健壮性</p><ul><li>例如某路由表故障显示到所有路由表的距离为0，则由于好消息在DV中传播得快，所有路由表都可能会经过这个路由表传播，影响大。</li></ul></li></ul><h3 id="3-层次路由"><a href="#3-层次路由" class="headerlink" title="3. 层次路由"></a>3. 层次路由</h3><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509173306110.png" alt="使用层次路由的原因"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509173731237.png" alt="层次路由的路由器"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509173941032.png" alt="互连的AS"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509175128417.png" alt="自治系统间路由任务"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509180128374.png" alt="举例1"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509180420609.png" alt="举例2"></p><h4 id="3-1-自治系统内部协议"><a href="#3-1-自治系统内部协议" class="headerlink" title="3.1 自治系统内部协议"></a>3.1 自治系统内部协议</h4><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509180618795.png" alt="自治系统内部协议"></p><h5 id="3-1-1-RIP协议"><a href="#3-1-1-RIP协议" class="headerlink" title="3.1.1 RIP协议"></a>3.1.1 RIP协议</h5><p>Routing Information Protocol,路由信息协议</p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509181704268.png" alt="RIP"></p><blockquote><ul><li>距离度量：为了解决无限计数问题</li><li>每隔30s就交换一次DV，而不是DV算法中的DV发生改变才交换一次DV</li></ul></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509181919224.png" alt="RIP举例"></p><blockquote><p>注意这里为什么A传递给D的DV中要有next（下一跳）的信息，是为了实现毒性逆转。</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509183329086.png" alt="RIP链路失效和恢复"></p><blockquote><p>虽然可能会发生无穷计数问题，但是因为RIP采用距离度量和毒性逆转技术，所以大大降低了这种可能。而同样因为距离度量设置跳数最大为15，所以RIP协议不适合较大的自治系统。</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509183829440.png" alt="RIP路由表的处理"></p><ul><li>注意：RIP协议是由应用层进程进行管理的。但是RIP是为了实现网络层功能，所以RIP是网络层协议，而不是应用层协议。</li><li>因为RIP是依赖于UDP协议，所以路由器上也要支持端到端的协议UDP（当然有的路由协议依赖于TCP，所以有的要支持TCP协议）。不过这些应用层协议和传输层协议都是为了实现网络层的功能，所以在通信网络的五层示意模型中，对于路由器还是只认为有三层协议。</li></ul><h5 id="3-1-2-OSPF协议"><a href="#3-1-2-OSPF协议" class="headerlink" title="3.1.2 OSPF协议"></a>3.1.2 OSPF协议</h5><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509201159812.png" alt="OSPF协议特点"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509201855863.png" alt="OSPF优点"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509202150162.png" alt="OSPF的进一步分层"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509202440415.png" alt="区边界路由器"></p><blockquote><p>区边界路由器既是局部区的路由器，知道局部区路由器的链路状态；同时也是主干区的路由器，知道主干区路由器的链路状态。此外最重要的是区边界路由器需要将该局部区的所有路由器的距离信息通告给主干区其他路由器，但是不会通告详细的拓扑结构。</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509202913046.png" alt="主干路由器"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509202937361.png" alt="AS边界路由器"></p><blockquote><p>AS边界路由器在一个自治系统中可以有一个，也可以有多个。</p><p>AS边界路由器负责连接不同的AS，属于网关路由器。</p></blockquote><h4 id="3-2-自治系统间的协议"><a href="#3-2-自治系统间的协议" class="headerlink" title="3.2 自治系统间的协议"></a>3.2 自治系统间的协议</h4><ul><li>Internet中自治系统间的协议：BGP协议</li></ul><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509204637666.png" alt="BGP特点"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509205709114.png" alt="BGP基础"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509205828738.png" alt="BGP基础2"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509210144760.png" alt="BGP基础：分发路径信息"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509211230791.png" alt="BGP通告包含信息"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509212126057.png" alt="BGP路由选择"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509214057233.png" alt="BGP路由选择策略"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509214423314.png" alt="BGP路由选择策略2"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210509214620036.png" alt="AS间和AS内路由协议不同原因"></p><h3 id="4-SDN控制平面"><a href="#4-SDN控制平面" class="headerlink" title="4. SDN控制平面"></a>4. SDN控制平面</h3><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510200914958.png" alt="SDN特点"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510200930360.png" alt="数据平面交换机"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510200940572.png" alt="SDN控制器"></p><blockquote><p>鲁棒性：是Robust的音译，也就是健壮和强壮的意思。它也是在异常和危险情况下系统生存的能力。</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510200949995.png" alt="控制应用"></p><blockquote><p>控制应用在北向接口之上的。</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201000613.png" alt="控制器中的元件"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201010936.png" alt="OpenFlow"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201019063.png" alt="控制器到交换机报文"></p><blockquote><p>packet-out：用于当交换机接收到的报文不知道该传递到哪个端口时，控制其传向某特定的端口。</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201027727.png" alt="交换机到控制器报文"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201037155.png" alt="举例"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201046205.png" alt="举例2"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201056875.png" alt="ODL控制器"></p><blockquote><p>北向接口：REST API</p></blockquote><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201105616.png" alt="ONOS控制器"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510201124565.png" alt="SDN面临的挑战"></p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="1-广播"><a href="#1-广播" class="headerlink" title="1. 广播"></a>1. 广播</h4><ul><li><p>一对多，一个源端，其他都是目的端，但是不能穿越路由器</p></li><li><p>一种方式：源端拷贝（source duplication）实现，即从源端发送到其他所有目标端报文拷贝  —效率很低，不合适；可行性不行，因为需要知道所有其他结点的IP地址，这是很难实现的</p></li><li><p>另一种方式：基于路由器拷贝实现（in-network duplication），路由接收到报文后进行拷贝然后进一步传播。</p></li><li><p>泛洪（flooding）：当路由接收到报文后进行拷贝然后进一步传播给自己所有的邻居。</p><ul><li><p>存在问题：存在回路时可能存在广播风暴</p></li><li><p>受控的泛洪（controlled flooding）—可以解决广播风暴问题，但是存在冗余数据报问题</p><ul><li>数据报加序列号，当接收到该路由器已转发过的相同序列号的报文，则不再进行转发</li><li>反向路径转发（RPF）：路由器在单播路由表中查找源地址以确定数据包到达的接口是否位于返回信源的的反向路径上，如果是则RPF检查成功，如果不是则标记“RPF失败丢弃”并丢弃数据包。</li></ul></li><li><p>生成树（spanning tree）：既可以解决广播风暴问题，又可以解决冗余数据报问题</p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510210342774.png" alt="生成树"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510210411661.png" alt="生成树"></p></li></ul></li></ul><h4 id="2-组播（多播）"><a href="#2-组播（多播）" class="headerlink" title="2. 组播（多播）"></a>2. 组播（多播）</h4><ul><li><p>一对多，源端传递给组里面所有的成员。可以穿越路由器</p></li><li><p>生成树</p><ul><li><p>基于源端的生成树（source-based tree）</p><ul><li><p>最短路径的树</p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510210959493.png" alt="最短路径的树"></p></li><li><p>反向路径转发（信源树）</p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510211114626.png" alt="反向路径转发"></p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510211128927.png" alt="反向路径转发例子"></p><blockquote><p>例如：源端到达R6的最短路径是从R2传递过来的，所以R6就不接受R3传播过来的源端的数据报，而只接受R2传播过来的</p></blockquote></li></ul></li><li><p>共享树（group-shared tree）</p><ul><li>最小生成树</li></ul><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510211536249.png" alt="最小生成树"></p><ul><li><p>基于中心的树</p><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210510211550101.png" alt="基于中心的树"></p></li></ul></li><li><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/image-20210514163920309.png" alt="优点"></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="2021/04/26/Java%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/26/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="一、理论基础"><a href="#一、理论基础" class="headerlink" title="一、理论基础"></a>一、理论基础</h3><ul><li>跨平台原理</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426001700366.png" alt="Java跨平台原理"></p><span id="more"></span><ul><li>JRE</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426001812338.png" alt="JRE"></p><ul><li>JDK</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426001843868.png" alt="JDK"></p><ul><li>JDK、JRE和JVM关系</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426001913255.png" alt="JDK、JRE和JVM关系"></p><ul><li>JDK的安装目录</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426002142231.png" alt="JDK的安装目录"></p><ul><li>常用DOS命令</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426002430887.png" alt="常用DOS命令"></p><ul><li>为什么要配置Path环境变量</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426002931636.png" alt="为什么要配置Path环境变量"></p><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426003325705.png" alt="注意环境配置的一个问题"></p><ul><li>Java程序开发运行流程</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426003425904.png" alt="Java程序开发运行流程"></p><blockquote><p>编译后会生成一个.class字节码文件</p></blockquote><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426003652247.png" alt="编译 运行"></p><ul><li>BUG</li></ul><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426003902152.png" alt="BUG"></p><blockquote><p>例如 </p><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210426004033701.png" alt="常见bug"></p></blockquote><ul><li><p>常量：</p><ul><li><p>字符常量可以是<strong>中文</strong>  例如’中’是一个常量   但是字符常量有且只有一个字符   比如 <strong>‘’ 没有字符</strong>  ‘ab’  这种都是错的</p></li><li><p>字符串常量可以是 <strong>“” 空字符</strong></p></li><li><p>空常量：null  表示没有任何数据</p><p><code>System.out.println(null);</code>这种写法是<strong>错误</strong>的，打印空常量</p></li></ul></li><li><p>数据类型分类：</p><ul><li>基本数据类型<ul><li>整数型  byte(1字节)   short(2字节)   int(4字节)(int默认类型)    long(8字节)</li><li>浮点型 float(4字节)  double(8字节) （double默认类型）<ul><li>近似值  都不精确</li></ul></li><li>字符型 char**(2字节)**  可表示中文</li><li>布尔型 boolean(1字节)</li></ul></li><li>引用数据类型<ul><li><strong>字符串</strong>  引用类型</li><li>数组</li><li>类</li><li>接口</li><li>Lambda</li></ul></li></ul></li><li><p>变量：程序运行期间  内容可以改变</p><p>[数据类型] [变量名称];</p></li><li><p>变量注意事项：</p><ul><li><p>byte num=400;  错误  右方数据范围不能大于左边的范围</p></li><li><p>对于float和long类型注意字母后缀。</p></li><li><p>变量使用不能超过作用域的范围   从变量定义开始，然后一直到直接所属的大括号为止</p></li><li><p>可以多个变量同时定义与赋值</p><p>int  a=1,b=2,c=3;</p></li></ul></li><li><p>当数据不一样时，将会发生数据类型转换</p><ul><li><p>自动类型转换</p><ul><li><p>数据范围从小到大   （与字节数不一定相关  例如float的范围大于long  但是字节数少）</p><blockquote><p>long lon=100;  //将Int赋给lon</p><p>double dou=1.0f;//将float赋给double</p><p>float flo=30L;//将long赋值给float    </p></blockquote></li></ul></li><li><p>强制类型转换</p><ul><li><p>数据范围从大到小</p><blockquote><p>int num=(int) 100L;</p></blockquote></li><li><p>可能会发生精度损失，数据溢出</p><blockquote><p>int num2=(int)3.5;   //输出3     将小数部分直接截取  精度运算</p><p>int num1=(int) 1000000000000000000L  数据溢出</p></blockquote></li></ul></li></ul></li><li><p>byte/short/char类型都可以进行数学运算   在运算的时候，都会首先被提升为int类型，然后再进行运算</p><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210427165107929.png" alt="强制类型转换"></p></li><li><p>boolean不能进行任何数据转换</p></li><li><p>数字和字符的对照表（编码表）</p><ul><li>ASCII码表：American Standard Code for Information Interchange  美国信息交换标准代码</li><li>Unicode码表：万国码  开头0-127与ASCII码表一致  后面有各国的的字符  例如中文、日文等</li></ul></li><li><p>/  整除  结果是商 整数</p></li><li><p>% 取模  结果是余数   只有对整数而言才有余数</p></li><li><p>一旦运算中有不同类型的数据，那么结果将是数据范围大的类型</p></li><li><p>加号“+”</p><ul><li><p>对于字符char，计算之前会将char提升为int，然后进行运算</p></li><li><p>对于String类型（不全是小写  所以不是关键字） 加号表示连接字符串。无论什么类型与字符串连接，最后结果都是字符串。</p><blockquote><p>优先级问题：</p><p>“String”+20+30    结果是”String2030”</p></blockquote></li></ul></li><li><p>自增自减、复合赋值运算符中隐含了一个强制类型转换</p><p><img src="/2021/04/26/Java%E5%9F%BA%E7%A1%80/image-20210427172025042.png" alt="复合运算符"></p></li><li><p>与&amp;&amp; 或|| 具有短路效果   如果左边已经可以获得结果  右边将不会执行，从而节省一定的性能</p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-网络层：数据平面</title>
      <link href="2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/"/>
      <url>2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-网络层：数据平面"><a href="#计算机网络-网络层：数据平面" class="headerlink" title="计算机网络-网络层：数据平面"></a>计算机网络-网络层：数据平面</h2><h3 id="1-导论"><a href="#1-导论" class="headerlink" title="1 导论"></a>1 导论</h3><ul><li><p>本章目标:</p><ul><li><p>理解网络服务的基本原理，聚焦于其数据平面<br>网络服务模型<br><strong>转发和路由</strong><br>路由器工作原理<br>通用转发</p></li><li><p>互联网中网络层协议的实例和实现</p><span id="more"></span></li></ul></li><li><p>网络层服务：</p><ul><li>在发送主机和接收主机对之间传送段（segment）</li><li>在发送端将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于每一个主机和路由器</li><li>路由器检查每一个经过它的IP数据报的头部</li></ul></li><li><p>网络层的关键功能</p><ul><li>转发: 将分组从路由器的输入接口转发到合适的输出接口（局部）    -数据平面</li><li>路由: 使用路由算法来决定分组从发送主机到目标接收主机的路径（全局）   -控制平面<ul><li>路由选择算法</li><li>路由选择协议</li></ul></li></ul><blockquote><p>旅行的类比：<br>转发: 通过单个路口的过程<br>路由: 从源到目的的路由路径规划过程</p></blockquote></li><li><p>网络层：数据平面+控制平面</p><ul><li><p>数据平面</p><ul><li><p>本地，每个路由器功能</p></li><li><p>决定从路由器输入端口到达的分组如何转发到输出端口</p></li><li><p>转发功能：</p><ul><li>传统方式：基于目标地址+转发表</li></ul><blockquote><p>转发仅由目标ip匹配路由表确定转发的输出端口。而且路由表只有转发等基础功能。</p><p>路由表由控制平面路由选择器实体自己通过路由协议路由器之间进行通信然后建立。</p></blockquote><ul><li>SDN方式：基于多个字段+流表</li></ul><blockquote><p>转发通过数据包中源ip、源端口、目标ip、目标端口、标志位等很多字段进行匹配流表。同时根据流表对分组进行转发、block、泛洪、修改字段等动作。</p><p>流表是由网络操作系统计算出来然后通过南向接口交给分组交换机。</p></blockquote></li></ul></li><li><p>控制平面</p><ul><li><p>网络范围内的逻辑</p></li><li><p>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</p></li><li><p>2个控制平面方法:</p><ul><li>传统的路由算法: 在路由器中被实现<ul><li>传统路由：在每一个路由器上各自控制平面和数据平面都是极具耦合的集中实现的，同时控制平面是分布式的，各自控制平面分布在每一个路由器单独实现。所以如果想要修改路由协议或者改进路由器功能很难实现、代价很大。</li></ul></li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424141918201.png" alt="传统的路由器控制平面"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424142319814.png" alt="传统方式：路由和转发相互作用">    </p><ul><li><p>software-defined networking(SDN): 在远程的服务器中实现</p><ul><li>SDN中，分组交换机的CA本地控制代理将分组交换机的状态上传给网络操作系统（远程控制器），网络操作系统实现流表的建立并将流表传递给CA，CA将流表装载到分组交换机上，然后数据包到来后通过流表匹配，并按照流表对其进行转发或其他动作。</li><li>控制平面是集中式的，这将有利于实现网络行为的修改等。</li></ul><blockquote><p>这里的术语：分组交换机   实际上起的是路由器的作用   “分组路由器”</p></blockquote></li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424142401578.png" alt="SDN方式"></p></li></ul></li></ul></li><li><p>网络服务模型</p><ul><li><p>Q: 从发送方主机到接收方主机传输数据报的“通道”，网络层向上层提供什么样的服务模型？</p><ul><li><p>对于单个数据报的服务:</p><ul><li>可靠传送</li><li>延迟保证，如：少于40ms的延迟</li></ul></li><li><p>对于数据报流的服务:</p><ul><li><p>保序数据报传送</p></li><li><p>保证流的最小带宽</p></li><li><p>分组之间的延迟差（传输前一个和后一个分组的时间差） </p><blockquote><p>保证延迟差较小对多媒体传输提供的服务是非常好的</p></blockquote></li></ul></li></ul></li></ul></li><li><p>连接建立</p><ul><li><p>在某些网络架构中是第三个重要的功能</p><ul><li>ATM, frame relay, X.25</li></ul></li><li><p>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接</p><ul><li>涉及到路由器</li></ul></li><li><p>网络层和传输层连接服务区别:</p><ul><li><p>网络层: 在2个主机之间，涉及到路径上的一些路由器</p><blockquote><p>不仅是端系统，还有之间的路径的交换结点之间的连接。所以是“有连接”。</p></blockquote></li><li><p>传输层: 在2个进程之间，很可能只体现在端系统上(TCP连接)</p><blockquote><p>TCP的连接只是两个端系统，没有涉及经过的路由器，所以称之为面向连接</p></blockquote></li></ul></li><li><p>路由表是控制平面和数据平面的粘合剂。控制平面的路由计算出路由表，路由表交给IP协议，IP协议通过路由表对接收到的数据报实现一个局部的转发，即数据平面的功能。</p></li></ul></li><li><p>网络层服务模型</p><p>服务模型：对于提供的服务的评价指标可以用数据进行表示时，称之为服务模型。</p><p>如IP协议的best effort 尽力而为</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424144515472.png" alt="网络层服务模型"></p></li></ul><h3 id="2-路由器组成"><a href="#2-路由器组成" class="headerlink" title="2 路由器组成"></a>2 路由器组成</h3><ul><li><p>路由器结构概况：高层面(非常简化的)通用路由器体系架构</p><ul><li><p>路由：运行路由选择算法／协议(RIP, OSPF, BGP)-生成路由表</p></li><li><p>转发：从输入到输出链路交换数据报-根据路由表进行分组的转发</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424154911059.png" alt="路由器结构"></p></li></ul></li><li><p>输入端口功能</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424155007573.png" alt="输入端口功能"></p><ul><li>物理层实体：将链路中电磁波或光波的形式转换成0101…的比特数字形式。</li><li>数据链路层实体：判断哪里是帧头、帧尾；进行数据错误检验；判断帧中目标mac和网卡的mac地址是不是一致，一致才收取这个帧；将帧中的数据（IP分组）取出交给网络层实体。</li><li>网络层实体：IP分组在其中排队依次等待处理，网络层根据路由表和IP分组对应的目的IP地址（传统方法）进行依次转发IP分组。</li></ul></li><li><p>输入端口网络层缓存</p><ul><li>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队<ul><li>会产生排队延迟</li><li>有的分组可能由于输入缓存溢出而造成丢失!</li></ul></li><li>Head-of-the-Line (HOL) blocking: 排在队头的数据报<br>阻止了队列中其他数据报向前移动</li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424174917021.png" alt="输入端口缓存"></p></li><li><p>交换结构</p><ul><li><p>交换结构用来将分组从输入缓冲区传输到合适的输出端口</p></li><li><p>交换速率：分组可以按照该速率从输入传输到输出</p><ul><li>交换速度经常是输入/输出链路速率的若干倍</li><li>N 个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈</li></ul></li><li><p>3种典型的交换机构</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424175746776.png" alt="三种典型的交换结构"></p></li><li><p>交换结构：通过内存（memory）交换   </p><ul><li><p>第一代路由器:（软件形式实现）</p><ul><li><p>在CPU直接控制下的交换，路由器采用传统的计算机</p></li><li><p>分组被拷贝到路由器系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口   </p></li><li><p>转发速率被内存的带宽限制(数据报通过BUS两遍)</p></li><li><p>一次只能转发一个分组</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424180251687.png" alt="基于memory的交换结构"></p></li></ul></li></ul></li><li><p>通过总线（bus）</p><ul><li>交换数据报通过共享总线时将会获得所有输出端口地址，然后通过匹配确定数据报的输出端口，将数据报从输入端口转发到输出端口 （经过Bus只经过一次，速度快上很多）</li><li>总线竞争: 交换速度受限于总线带宽</li><li>1次处理一个分组</li><li>1 Gbps bus, Cisco 1900； 32 Gbps bus, Cisco 5600；对于接入或企业级路由器，速度足够（但不适合区域或骨干网络）</li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424180755469.png" alt="BUS型交换结构"></p></li><li><p>通过互联网络（crossbar等）的交换</p><ul><li><p>同时并发转发多个分组，克服总线带宽限制</p><p>当分组从端口A到达，转给端口Y，控制器短接相应的两个总线（即短路下图连接点1）；同时可以短路下图连接点2、3，实现B到Z和C到X或其他方式的并行传输数据报。极大提高了速率。</p></li><li><p><strong>Banyan（榕树）网络，crossbar(纵横)和其它的互联网络被开发，将多个处理器连接成多处理器</strong>？？？</p></li><li><p>高级设计：将数据报分片为固定的较短长度的信元，分别通过交换网络进行交换，这样总体时间不变，但是更加有利于调度</p></li><li><p>Cisco12000：以60Gbps的交换速率通过互联网络</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424181559698.png" alt="互联网络的交换结构"></p></li></ul></li></ul></li><li><p>输出端口</p><ul><li><p>当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存</p></li><li><p>由调度规则选择排队的数据报进行传输</p><ul><li>先来的数据报不一定先传，由调度规则决定</li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424214749508.png" alt="输出端口"></p></li><li><p>物理层：将链路层来的帧比特转换成电磁波信号或者是光信号</p></li><li><p>链路层：对数据报进行封装，将源mac地址和目标mac地址、帧头和帧尾封装到每个帧中。进行CRC校验等。</p></li><li><p>网络层：对数据报进行排队，然后交给链路层的网卡。</p></li><li><p>输出端口的queuing：交换速度要大于传输速度，所以需要先把交换过来的数据报暂存一下。</p><ul><li><p>假设交换速率Rswitch是Rline的N倍（N：输入端口的数量）</p></li><li><p>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则缓存）</p></li><li><p>排队带来延迟，由于输出端口缓存溢出则丢弃数据报！</p></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424220300960.png" alt="输出端口排队"></p></li><li><p>调度机制：</p><ul><li><p>调度: 选择下一个要通过链路传输的分组</p></li><li><p>调度策略：FIFO (first in first out) scheduling: 按照分组到来的次序发送</p><ul><li>丢弃策略: 如果分组到达一个满的队列，哪个分组将会被抛弃?<br>tail drop: 丢弃刚到达的分组<br>priority: 根据优先权丢失/移除分组<br>random: 随机地丢弃/移除</li></ul></li><li><p>调度策略：优先权</p><ul><li><p>优先权调度：发送最高优先权的分组</p></li><li><p>多类，不同类别有不同的优先权</p><ul><li><p>类别可能依赖于标记或者其他的头部字段  例如源/目的IP、端口号等。</p></li><li><p>先传高优先级的队列中的分组，除非没有</p></li><li><p>高（低）优先权中的分组传输次序：FIFO</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424221737661.png" alt="多类的优先权调度算法"></p></li></ul></li></ul></li><li><p>调度策略：Round Robin（RR） scheduling</p><ul><li><p>多类，然后循环扫描不同类型的队列, 发送完一类的一个分组，再发送下一个类的一个分组，循环所有类</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424222422318.png" alt="RR"></p></li></ul></li><li><p>调度策略：Weighted Fair Queuing（WFQ）</p><ul><li><p>一般化的Round Robin</p></li><li><p>多类，在一段时间内，每个队列得到的服务时间是：W<sub>i</sub>/(XIGMA(W<sub>i</sub>)) *t，和整体优先级的权重成正比</p></li><li><p>每个类在每一个循环中获得不同权重的服务量</p><blockquote><p>高优先级队列也并不是绝对优先于低优先级队列，只是整体而言，服务时间占比与其整体优先级权重有关</p></blockquote><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210424222640236.png" alt="WFQ"></p></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="3-IP-协议"><a href="#3-IP-协议" class="headerlink" title="3 IP 协议"></a>3 IP 协议</h3><ul><li><p>主机、路由器中的网络层功能：</p><ul><li>路由协议</li><li>IP协议：数据层面，通过查forwarding table来确定路径并转发。对分组进行处理。</li><li>ICMP协议：信令协议，传送信号，用来进行错误报告，检验网络情况。例如ping、测试RRT等。</li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425154437160.png" alt="网络层"></p></li></ul><h4 id="3-1-数据报格式"><a href="#3-1-数据报格式" class="headerlink" title="3.1 数据报格式"></a>3.1 数据报格式</h4><ul><li><p>IP数据报格式</p><ul><li><p>ver： IP协议版本号  IPv4：0100</p></li><li><p>head len：头部长度 = 固定20字节长度 + 选项Options</p><blockquote><p>head len中单位是行 即4个字节为单位   所以固定长度为20字节、选项为0字节，则head len=5</p></blockquote></li><li><p>type of service：数据类型  设计时是为了让调度有一个依据，但后来废弃不用了。</p></li><li><p>time to live：TTL  每过一个路由器减一，减为零以后路由器将该数据报丢弃，同时发给源主机一个ICMP信号，通知一下。</p></li><li><p>upper layer：用来标记交给上一层的哪一个协议，UDP还是TCP。</p></li><li><p>Internet checksum ：用来检验IP数据报的头部是否出现问题。</p></li><li><p>Option：头部的可选项，可用来做一些特殊功能，例如时戳记录传输路径上经过的路由器有哪些等等。</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425155117547.png" alt="IP数据报格式"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425162202081.png" alt="IP协议数据报头部示例"></p><h4 id="3-2-IP分片和重组（Fragmentation-amp-Reassembly）"><a href="#3-2-IP分片和重组（Fragmentation-amp-Reassembly）" class="headerlink" title="3.2 IP分片和重组（Fragmentation &amp; Reassembly）"></a>3.2 IP分片和重组（Fragmentation &amp; Reassembly）</h4></li></ul></li><li><p>网络链路有MTU (最大传输单元)–链路层帧所携带的最大数据长度<br>  不同的链路类型有着不同的MTU</p><blockquote><p>MTU指的是链路层的每个帧所携带的负载body的最大长度。例如FDDI是4000B，以太网是1500B。</p></blockquote></li><li><p>大的IP数据报在网络上被分片(“fragmented”)，一个数据报被分割成若干个小的数据报</p><blockquote><p>例如FDDI链路的MTU是4000B，以太网是1500B，从FDDI来的帧不能在以太网中直接传输，所以需要将对应IP数据报（假设IP头部20B，则IP的body是3980B）进行分片。</p></blockquote><ul><li>相同的ID</li><li>不同的偏移量</li><li>最后一个分片标记为0</li></ul></li><li><p>IP头部的信息被用于标识，排序相关分片</p><p>  <img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425173944450.png" alt="分片"></p></li><li><p>“重组”只在最终的目标主机进行</p><blockquote><p>在中间的路由器不会进行重组，原因：路由器负担大；小IP数据报可能通过不同路径向目标主机传输。</p></blockquote><blockquote><p>目标主机接收到一个小IP数据报后，开始计时，计时时间内其他所有切分成的小IP数据报全部到达，则重组传给上层。如果有小IP数据报没到，则将所有IP数据报丢弃。</p></blockquote></li><li><p>示例：</p><ul><li><p>fragflag表示这一片后面是否还有分片，fragflag=1表示后面还有，fragflag=0表示后面没有分片了，这是最后的一个分片 </p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425174544531.png" alt="IP数据报分片和重组示例"></p></li><li><p>IP头部：</p><ul><li>标识（identification）ID：占16位。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。<br>但这个“标识”不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li><li>标志（flag）：占3位，但目前只有两位有意义。<ul><li>– 标志字段中的最低位为MF（More Fragment）。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。</li><li>– 标志字段中间的一位记为DF（Don’t Fragment），意思是“不能分片”。只有当DF=0时才允许分片。</li></ul></li><li>片偏移（offset）：占13位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以8个字节为偏移单位。也就是说，每个分片的长度一定是8字节（64位）的整数倍。</li></ul></li></ul></li></ul><h4 id="3-3-IPv4地址"><a href="#3-3-IPv4地址" class="headerlink" title="3.3 IPv4地址"></a>3.3 IPv4地址</h4><ul><li><p>IP地址是用来标识设备（主机、路由器、交换机等）与网络连接点的</p></li><li><p>IP 地址: 32位标示，对主机或者路由器的接口编址</p></li><li><p>接口: 主机/路由器和物理链路的连接处</p><ul><li><p>路由器通常拥有多个接口，即有多个IP地址</p></li><li><p>主机也有可能有多个接口（例如一台主机装多个网卡，或者一个网卡多个虚拟地址）</p></li><li><p> 一个IP地址和一个接口相关联</p></li></ul><p>  <img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425213114450.png" alt="IP地址"></p></li><li></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425213326018.png" alt="引论"></p></li><li><p>子网（Subnets）</p><ul><li><p>IP地址:</p><ul><li>子网部分(高位bits)</li><li>主机部分(地位bits)</li></ul></li><li><p>什么是子网(subnet) ?</p><ul><li>一个子网内的节点（主机或者路由器）它们的IP地址的高位部分相同，这些节点构成的网络的一部分叫做子网</li><li>无需路由器介入，（可以借助交换机），子网内各主机可以在物理上相互直接到达</li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425213841740.png" alt="子网"></p></li><li><p>如何判断子网？</p><ul><li><p>要判断一个子网, 将每一个接口从主机或者路由器上分开,构成了一个个网络的孤岛</p></li><li><p>每一个孤岛（网络）都是一个都可以被称之为subnet.</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425214631003.png" alt="判断子网"></p><blockquote><p>这种严格定义的子网也被称之为纯子网。</p><p>有时候，IP地址子网部分的高位地址相同，其他位不同的设备构成的网络也叫子网，这些设备可能经过一些路由器，但是相对于整个大的网络而言也是子网。称之为子网。</p></blockquote></li><li><p>示例：（纯子网）  6个</p><blockquote><p>去掉与设备的连接处形成的网络孤岛有6个。3个两ip地址的，2个三ip地址，一个四ip地址。</p></blockquote><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425214930124.png" alt="子网示例"></p></li></ul></li></ul></li><li><p>IP经过的物理网络一般有两个形式</p><ul><li>远程的连接：点对点</li><li>局域网内的：多点连接（通过交换机等）</li></ul></li><li><p>IP地址分类</p><p>Class A、B、C网络地址是单播网络地址</p><ul><li><p>Class A：126 networks ，16 million hosts</p><blockquote><p>A类网络以0开头   </p><p>一共有2<sup>7</sup>-2个网络（减二的原因是全0和全1的网络地址不用，这里就是0和127不用），（已经被分配完了）</p><p>然后有2<sup>24</sup>-2个主机地址（减二的原因是全0和全1的主机地址不用）</p></blockquote></li><li><p>Class B：16382 networks ，64 K hosts</p><blockquote><p>B类网络以10开头</p><p>一共有2<sup>14</sup>-2个网络（减二的原因是全0和全1的网络地址不用），（已经被分配完了）</p><p>然后有2<sup>16</sup>-2个主机地址（减二的原因是全0和全1的主机地址不用）</p></blockquote></li><li><p>Class C：2 million networks ，254 host</p><blockquote><p>C类网络以110开头</p><p>一共有2<sup>16</sup>-2个网络（减二的原因是全0和全1的网络地址不用），（现在一般获得的网络都是C类网络）</p><p>然后有2<sup>8</sup>-2个主机地址（减二的原因是全0和全1的主机地址不用）</p></blockquote></li></ul><p>Class D是组播地址</p><ul><li><p>Class D：multicast</p><blockquote><p>开头是1110    Multicast address是组播地址</p></blockquote></li><li><p>Class E：reserved for future</p><blockquote><p>开头是11110    预留地址  为之后的使用预留地址</p></blockquote><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425221216252.png" alt="IP地址分类"></p></li></ul></li><li><p>互联网中的路由是以网络（只看网络地址，而不是IP地址整体，减少负担，提高效率）为单位进行传输数据的，等到了目标主机所在子网以后，子网路由器才根据IP地址寻找对应的目标主机。</p><blockquote><p>即A类网络地址与路由表对照时只看第一个字节  B类看前两个字节  C类看前三个字节</p></blockquote></li><li><p>特殊IP地址</p><ul><li><p>一些约定：</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425223127933.png" alt="特殊IP地址"></p><ul><li>32位地址全为0：表示本主机</li><li>子网部分全为0：本网络</li><li>32位地址全为1：表示在本网络内广播</li><li>主机部分全为1：表示在远程的一个特定Network网络内广播</li><li>网络部分为127，其他位任意：表示回路地址/测试地址，即访问本机    （数据会传到本机的IP层再回传到本主机）</li><li>网络部分是某个网络地址，主机部分全0：表示这个网络的网络号</li></ul></li></ul></li><li><p>内网（专用）IP地址</p><ul><li><p>专用地址：地址空间的一部份供专用地址使用，而不作为公用地址使用</p></li><li><p>永远不会被当做公用地址来分配, 不会与公用地址重复</p><ul><li>只在局部网络中有意义，区分不同的设备</li></ul></li><li><p>路由器不会对目标地址是专用地址的分组进行转发，这些分组只会在子网内部临时使用</p><blockquote><p>比如某机构还没有正式被分配网络地址，那么在测试内部网络连接的时候，可以使用专用地址</p></blockquote></li><li><p>专用地址范围</p><ul><li>Class A 10.0.0.0-10.255.255.255 MASK 255.0.0.0</li><li>Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0</li><li>Class C 192.168.0.0-192.168.255.255 MASK 255.255.255.0</li></ul></li></ul></li><li><p>IP 编址: CIDR    Classless InterDomain Routing（无类域间路由）</p><ul><li><p>子网部分是前n位，n不用是字节划分的地方</p></li><li><p>地址格式: a.b.c.d/x, 其中x 是地址中子网号的长度</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425225356948.png" alt="CIDR"></p><blockquote><p>解决的问题：</p><p>A类、B类网络的网络地址太少，不够分</p><p>C类网络的网络地址很多，但是主机地址太少，不够用</p></blockquote><blockquote><p>问题：如何得知哪些部分是网络地址，哪些部分是IP地址？</p><p>解决方案：采用子网掩码，网络部分全为1，主机部分全为0，然后子网掩码与IP地址相与可以得到网络号</p></blockquote></li></ul></li><li><p>子网掩码（subnet mask）</p><ul><li><p>32bits , 0 or 1 in each bit</p><ul><li>1：bit位置表示子网部分</li><li>0：bit位置表示主机部分</li></ul></li><li><p>原始的A、B、C类网络的子网掩码分别是</p><ul><li>A：255.0.0.0 ：11111111 00000000 0000000 00000000</li><li>B：255.255.0.0：11111111 11111111 0000000 00000000</li><li>C：255.255.255.0：11111111 11111111 11111111 00000000</li></ul></li><li><p>CIDR下的子网掩码例子：</p><ul><li><p>IP地址设置前22位是网络部分，后10位是主机部分</p><p>子网掩码：11111111 11111111 11111100 00000000</p></li></ul></li><li><p>另外的一种表示子网掩码的表达方式</p><ul><li>/#</li><li>例：/22：表示前面22个bit为子网部分</li></ul></li></ul></li><li><p>转发表和转发算法</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210425230535450.png" alt="转发表和转发算法"></p><ul><li><p>获得IP数据报的目标地址</p></li><li><p>对于转发表中的每一个表项</p><ul><li>如(IP Des addr) &amp; (mask) == destination, 则按照表项对应的接口转发该数据报</li><li>如果都没有找到，则使用默认表项（Default）转发数据报。即一个网络的出口路由器、默认网关。</li></ul><blockquote><p>对于子网之间的传输（即远程传输中），查转发表时比较的是网络号，而不用全部的32位IP地址。减少路由器的负担，提高效率。</p><p>只有到最后一跳的时候（即子网内路由器到主机的时候）查转发表比较的才是IP地址。</p></blockquote></li></ul></li><li><p>Q: 主机如何获得一个IP地址?（两种方法）</p><ul><li><p>系统管理员将地址配置在一个文件中</p><ul><li>Wintel: control-panel-&gt;network-&gt;configuration-&gt;tcp/ip-&gt;properties</li><li>UNIX: /etc/rc.config</li><li>联网需要配置四个信息：IP地址、子网掩码、默认网关、Local Name Sever（域名解析系统）</li></ul></li><li><p>DHCP: Dynamic Host Configuration Protocol：从服务器中动态获得一个IP地址</p><ul><li><p>“plug-and-play”</p></li><li><p>目标: 允许主机在加入网络的时候，动态地从服务器那里获得IP地址：</p><ul><li>可以更新对主机在用IP地址的租用期-租期快到了</li><li>重新启动时，允许重新使用以前用过的IP地址</li><li>支持移动用户加入到该网络（短期在网）</li></ul><blockquote><p>优点：</p><ol><li><p>自动分配IP地址，不用手动配置</p></li><li><p>有时候有500人，但是同时在线的人数少，所以254个主机地址就够用了</p></li></ol></blockquote></li><li><p>DHCP工作概况:</p><ul><li>主机广播“DHCP discover” 报文[可选]</li><li>DHCP 服务器用“DHCP offer”提供报文响应[可选]</li><li>主机请求IP地址：发送“DHCP request” 报文</li><li>DHCP服务器发送地址：“DHCP ack” 报文</li></ul></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426143224611.png" alt="DHCP的请求IP示意图"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426143407009.png" alt="image-20210426143407009"></p><blockquote><p>请求IP地址的时候，主机还没有被分配IP地址，所以采用全0的IP地址表示本机，而主机也不知道DHCP服务器的IP地址，所以采用全1形式在本网内部进行广播。</p><p>yiaddr： 表示分配的IP地址</p><p>lifetime：表示IP地址的租用时间</p></blockquote></li><li><p>DHCP: 不仅仅是IP addresses<br>DHCP 返回:</p><ul><li>IP 地址</li><li>第一跳路由器的IP地址（默认网关）</li><li>DNS服务器的域名和IP地址</li><li>子网掩码(指示地址部分的网络号和主机号)</li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426144432370.png" alt="DHCP实例1"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426144631839.png" alt="DHCP实例2"></p></li></ul></li></ul></li><li><p>Q: 如何获得一个网络的子网部分？<br>A: 从ISP获得地址块中分配一个小地址块</p><blockquote><p>假设ISP的网络地址是20位，那么他可以以固定的20位再往后加3位的000-111向下分配出8个23位的子网，当然这些子网也可以继续向下划分更小的子网。</p></blockquote><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426145503696.png" alt="如何获得子网部分"></p></li><li><p>层次编址：路由聚集（route aggregation）</p><blockquote><p>下一跳：假如说某一个路由器发布通告，200.23.16.0/23前缀的IP地址的数据报都发给我，则这个路由器就是这些数据报的下一跳</p></blockquote><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426151030913.png" alt="路由聚集1"></p><blockquote><p>例如：图中IP X聚集IP 0、IP 1、IP 2、IP 3等路由信息，然后向Internet通告。Internet传来一个数据报目的IP是200.23.18.7 那么他就会传给IP x这个路由器  因为前20位是匹配上的。然后再在路由器中查转发表，查找下一跳。</p></blockquote><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426160917779.png" alt="路由聚集2"></p><blockquote><p>在路由聚集中支持大概齐的路由聚集，即IPx虽然只聚集了7个而有一个没有聚集，但是对外通告可以通告200.23.16.0/20，而IPy只聚集了200.23.18.0/23和199.31.0.0/16的，所以它通告要通告两个：200.23.18.0/23和199.31.0.0/16。</p><p>当有目的IP是200.23.18.7的数据报来到Internet中时，由于最长前缀匹配（最精确地）将会把数据报传递到IPy上。</p></blockquote><ul><li>路由聚集优点：减少路由表项，减少路由通告的代价，减少路由存储和计算的代价等。</li></ul></li><li><p>Q: 一个ISP如何获得一个地址块?<br>A: 向权威机构ICANN请求获得地址，ICANN：Internet Corporation for Assigned Names and Numbers</p></li><li><p>ICANN负责：分配地址、管理DNS、分配域名，解决冲突</p></li><li><p>NAT: Network Address Translation</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426161631547.png" alt="NAT"></p><ul><li><p>动机: 本地网络只有一个有效IP地址:</p><ul><li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备–省钱</li><li>可以在局域网改变设备的地址情况下而无须通知外界</li><li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li><li>局域网内部的设备没有明确的地址，对外是不可见的–安全</li></ul></li><li><p>实现: NAT 路由器必须:</p><ul><li><p>外出数据包：替换源地址和端口号为NAT IP地址和新的端口号，目标IP和端口不变<br>…远端的C/S将会用NAP IP地址，新端口号作为目标地址</p></li><li><p>记住每个转换替换对（在NAT转换表中）<br>.. 源IP，端口 vs NAP IP ，新端口</p></li><li><p>进入数据包：替换目标IP地址和端口号，采用存储在NAT表中的mapping表项，用（源IP，端口）</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426162545982.png" alt="NAT的实现"></p></li></ul></li><li><p>16-bit端口字段：所以NAT路由器可以实现6万多个同时连接，足以支撑一个局域网!</p></li><li><p>但是对NAT是有争议的:</p><ul><li>路由器只应该对第3层做信息处理，而这里对端口号（4层）作了处理</li><li>违反了end-to-end 原则<ul><li>端到端原则：复杂性放到网络边缘<ul><li>无需借助中转和变换，就可以直接传送到目标主机</li></ul></li><li>NAT可能要被一些应用设计者考虑, eg, P2P applications</li><li>外网的机器无法主动连接到内网的机器上</li></ul></li><li>地址短缺问题可以被IPv6 解决</li><li>NAT穿越问题： 如果客户端需要连接在NAT后面的服务器，如何操作</li></ul></li><li><p>NAT穿越问题：</p><ul><li><p>例如，客户端需要连接地址为10.0.0.1的服务器</p><ul><li>服务器地址10.0.0.1 LAN本地地址(客户端不能够使用其作为目标地址)</li><li>整网只有一个外部可见地址：138.76.29.7</li></ul></li><li><p>解决方案1：静态配置NAT：转发进来的对服务器特定端口连接请求</p><ul><li>e.g.,（138.76.29.7, port 2500）总是转发到10.0.0.1 port 25000，即将这个转换替换对固定写死到NAT router中。</li></ul></li><li><p>解决方案2：Universal Plug and Play(UPnP) Internet Gateway Device (IGD) 协议   </p><p>允许NATted主机可以:</p><ul><li>获知网络的公共IP地址即NAT router的IP地址(138.76.29.7)</li><li>主机可以获取NAT router所存在的端口映射</li><li>然后主机(在租用时间内)可以控制增/删端口映射，实现提前向NAT表写入转换替换对<br>i.e.，自动化静态NAT端口映射配置</li></ul></li><li><p>解决方案3：中继(used in Skype)</p><ul><li><p>NAT后面的服务器首先建立和中继的连接</p></li><li><p>之后外部的客户端链接到中继</p></li><li><p>中继在2个连接之间桥接，实现Client主动传给NAT后面的服务器</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426164349249.png" alt="中继方法"></p></li></ul></li></ul></li></ul></li></ul><h4 id="3-4-IPv6"><a href="#3-4-IPv6" class="headerlink" title="3.4 IPv6"></a>3.4 IPv6</h4><ul><li>初始动机：32-bit地址空间将会被很快用完</li><li>另外的动机：<ul><li>头部格式改变帮助加速处理和转发<ul><li>TTL每次经过路由器减一</li><li>头部checksum需要在路由器进行检验</li><li>分片需要在路由器完成</li><li>这些都给路由器增加了负担，从而导致传输速度的减慢</li></ul></li><li>头部格式改变帮助QoS<ul><li>IPv4的头部没有一些机制让网络对其支持QoS（Quality of Service，服务质量）</li></ul></li></ul></li><li>IPv6 数据报格式:<ul><li>固定的40字节头部</li><li>IP地址128位</li><li>数据报传输过程中不允许分片，即路由器不进行分片<ul><li>将会对源主机发送信息，通知其进行分片传输</li></ul></li></ul></li></ul><blockquote><p>IPv5 是一个实验版本，经过实验和研究后被废弃掉了。</p></blockquote><ul><li><p>IPv6 头部（Cont）</p><p>Priority：标示流中数据报的优先级<br>Flow Label：标示数据报在一个“flow.”( “flow”的概念没有被严格的定义)<br>Next header：标示上层协议<br>hop limit：类似于IPv 4的time to live的作用</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426165640088.png" alt="IPv6"></p></li><li><p>和IPv4相比的其它变化</p><ul><li>Checksum: 被移除掉，降低在每一段中的处理速度</li><li>Options: 允许，但是在头部之外, 被“Next Header” 字段标示</li><li>ICMPv6: ICMP的新版本<ul><li>附加了报文类型, e.g. “Packet Too Big”将会对源主机发送数据包太大的信息，通知其进行分片传输</li><li>多播组管理功能（即将IPv4中的组管理IGMP的功能合并到了ICMP中）</li></ul></li></ul></li><li><p>从IPv4到IPv6的平移过渡</p><ul><li><p>不是所有的路由器都能够同时升级的</p><ul><li>没有一个标记日“flag days”</li><li>在IPv4和IPv6路由器混合时，网络如何运转?</li></ul></li><li><p>隧道：在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报从而实现IPv6的传输</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426171014498.png" alt="隧道1"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426171517680.png" alt="隧道2"></p></li></ul></li></ul><h3 id="4-通用转发和SDN"><a href="#4-通用转发和SDN" class="headerlink" title="4 通用转发和SDN"></a>4 通用转发和SDN</h3><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426180452266.png" alt="网络层功能"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426180705788.png" alt="路由器的控制平面"></p><ul><li><p>传统网络层缺陷：数量众多、功能各异的中间盒</p><ul><li><p>路由器的网络层功能：</p><ul><li>IP转发：对于到来的分组按照路由表决定如何转发，数<br>据平面</li><li>路由：决定路径，计算路由表；处在控制平面</li></ul></li><li><p>还有其他种类繁多网络设备（中间盒）：</p><ul><li><p>交换机；防火墙；NAT；IDS；负载均衡设备</p></li><li><p>未来：不断增加的需求和相应的网络设备</p></li><li><p>需要不同的设备去实现不同的网络功能</p><p>每台设备集成了控制平面和数据平面的功能，控制平面分布式地实现了各种控制平面功能，导致升级和部署网络设备非常困难、改变工作方式非常困难</p></li></ul></li></ul></li><li><p>网络设备控制平面的实现方式特点</p><ul><li>互联网网络设备：传统方式都是通过分布式，功能由每台设备单独实现的方法来实现数据平面和控制平面功能<ul><li>垂直集成：每台路由器或其他网络设备，包括：<ul><li>1）硬件、在私有的操作系统；</li><li>2）互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li><li>从上到下都由一个厂商提供（代价大、被设备上“绑架”“）</li></ul></li><li>每个设备都实现了数据平面和控制平面的事情<ul><li>控制平面的功能是分布式实现的</li></ul></li><li>设备基本上只能（分布式升级困难）按照固定方式工作，控制逻辑固化。不同的网络功能需要不同的“middleboxes”：防火墙、负载均衡设备、NAT boxes, ..</li></ul></li><li>（数据+控制平面）集成&gt;（控制逻辑）分布-&gt;固化<ul><li>代价大；升级困难；管理困难等</li></ul></li></ul></li><li><p>传统方式实现网络功能的问题：</p><ul><li>垂直集成导致设备昂贵、不便于创新的生态</li><li>分布式、固化设备功能导致网络设备种类繁多<ul><li>无法改变路由等工作逻辑，无法实现流量工程等高级特性</li><li>配置错误影响全网运行；升级和维护会涉及到全网设备：管理困难</li><li>要增加新的网络功能，需要设计、实现以及部署新的特定设备，设备种类繁多</li></ul></li><li>~2005：开始重新思考网络控制平面的处理方式<ul><li>集中：远程的控制器集中实现控制逻辑</li><li>远程：数据平面和控制平面的分离</li></ul></li></ul></li><li><p>SDN：在逻辑上集中的控制平面</p><p>一个不同的（通常是远程）控制器和CA交互，控制器决定分组<br>转发的逻辑（可编程），CA所在设备执行逻辑。</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426201409779.png" alt="SDN"></p><ul><li><p>SDN的主要思路</p><ul><li><p>网络设备数据平面和控制平面分离</p></li><li><p>数据平面-分组交换机</p><ul><li><p>将路由器、交换机和目前大多数网络设备的功能进一步抽象成：按照流表（由控制平面设置的控制逻辑）进行PDU（帧、分组）的动作（包括转发、丢弃、拷贝、泛洪、阻塞）</p><blockquote><p>将功能的实现从路由器中抽离出来放在远程控制器中，从而简化路由器，降低路由器的成本，同时（将防火墙、路由等功能转换为软件控制实现）减少了网络设备的种类，便于管理以及功能的维护和升级</p></blockquote><blockquote><p>此外，远程控制器与CA之间都遵循南向接口，使得不同厂商的设备之间兼容性更好，远程控制器操作系统可以由不同企业竞争开发，而不会受到路由器品牌的限制</p></blockquote></li><li><p>统一化设备功能：SDN交换机（分组交换机），执行控制逻辑</p></li></ul></li><li><p>控制平面：控制器+网络应用</p><ul><li><p>分离、集中</p></li><li><p>计算和下发控制逻辑：流表</p><blockquote><p>通过网络应用产生控制逻辑并以流表形式下发给分组交换机，分组交换机就能按照此实现相应的功能，例如防火墙、路由等，从而减少了网络设备的种类，便于管理，也更加有利于功能的维护和升级</p></blockquote></li></ul></li></ul></li><li><p>SDN控制平面和数据平面分离的优势</p><ul><li>水平集成控制平面的开放实现（而非私有实现），创造出好的产业生态，促进发展<ul><li>分组交换机、控制器和各种控制逻辑网络应用app可由不同厂商生产，专业化，引入竞争形成良好生态</li></ul></li><li>集中式实现控制逻辑，网络管理容易：<ul><li>集中式控制器了解网络状况，编程简单，传统方式困难</li><li>避免路由器的误配置而导致的网络错误</li></ul></li><li>基于流表的匹配+行动的工作方式允许“可编程的”分组交换机<ul><li>实现流量工程等高级特性</li><li>在此框架下可以通过编程控制实现各种新型（未来）的网络设备</li></ul></li></ul></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426203756534.png" alt="类比"></p></li></ul></li><li><p>流量控制：传统路由比较困难</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426204214141.png" alt="传统路由1"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426204236934.png" alt="传统路由2"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426204300312.png" alt="传统路由3"></p><ul><li>而在SDN中，以上功能可以通过下发流表，然后根据流表进行实现</li></ul></li><li><p>SDN特点</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426204643282.png" alt="SDN特点"></p></li><li><p>SDN架构：</p><ul><li><p>数据平面交换机</p><ul><li><p>快速，简单，商业化交换设备采用硬件实现通用转发功能</p></li><li><p>流表被控制器计算和安装</p></li><li><p>基于南向API（例如OpenFlow），SDN控制器访问基于流的<br>交换机</p><ul><li>南向API定义了哪些可以被控制哪些不能</li><li>也定义了和控制器的协议(e.g., OpenFlow)</li></ul><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426204955226.png" alt="SDN架构"></p></li></ul></li><li><p>SDN控制器（网络操作系统）</p><ul><li><p>维护网络状态信息</p></li><li><p>通过上面的北向API和网络控制应用交互</p></li><li><p>通过下面的南向API和网络交换机交互</p></li><li><p>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性物理上采用分布式方法</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426205231080.png" alt="SDN控制器"></p></li></ul></li><li><p>网络控制应用</p><ul><li><p>控制的大脑： 采用下层提供的服务（SDN控制器提供的<br>API)，实现网络功能</p><ul><li>路由器交换机</li><li>接入控制防火墙</li><li>负载均衡</li><li>其他功能</li></ul></li><li><p>非绑定：可以被第三方提供，与控制器厂商以通常上不同，与分组交换机厂商也可以不同，使得市场竞争更加健康，小企业也有机会参与竞争</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426205710657.png" alt="网络控制应用"></p></li></ul></li><li><p>通用转发和SDN</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426205900819.png" alt="通用转发和SDN"></p></li><li><p>OpenFlow 数据平面抽象</p><ul><li><p>流: 由分组（帧）头部字段所定义</p></li><li><p>通用转发: 简单的分组处理规则</p><ul><li>模式: 将分组头部字段和流表进行匹配</li><li>行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器</li><li>优先权Priority : 几个模式匹配了，优先采用哪个，消除歧义</li><li>计数器Counters: #bytes 以及#packets</li></ul></li><li><p>路由器中的流表定义了路由器的匹配+行动规则（流表由控制器计算并下发）</p></li><li><p>OpenFlow: 流表的表项结构</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426223117141.png" alt="OpenFlow: 流表的表项结构"></p><p>例子：（*表示不用）</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426223441314.png" alt="SDN示例1"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426223508526.png" alt="SDN示例2"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426223614793.png" alt="OpenFlow抽象"></p><blockquote><p>OpenFlow可以实现对数据报传输路径的精确控制</p></blockquote><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210426223818684.png" alt="OpenFlow示例"></p></li></ul></li></ul></li><li><p>问题：转发表（基于目标的转发）和流表（通用转发）是如何计算出来的？<br>答案：通过控制平面</p></li></ul><h3 id="拓展-虚电路"><a href="#拓展-虚电路" class="headerlink" title="拓展  虚电路"></a>拓展  虚电路</h3><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210428213156089.png" alt="连接服务和无连接服务"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210428213747873.png" alt="虚电路"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210428220815009.png" alt="虚电路1"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210428221404114.png" alt="VC的具体表现"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210428221545179.png" alt="VC转发表"></p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210428222631834.png" alt="虚电路信令协议"></p><h3 id="拓展-ICMP协议-网络层协议"><a href="#拓展-ICMP协议-网络层协议" class="headerlink" title="拓展 ICMP协议(网络层协议)"></a>拓展 ICMP协议(网络层协议)</h3><ul><li><p>当报文出现错误等情况的时候，路由器或主机会将报文丢弃然后向源主机发送错误报告信息即ICMP报文。</p></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210429094851886.png" alt="ICMP协议报文"></p><ul><li><p>差错报告报文</p><ul><li><p>目的不可达</p><blockquote><p>报文到达目的主机，但是无法交递给目的主机、目的网络或目的端口时，报文会被丢弃，同时发送一个目的不可达的ICMP报文给源主机</p></blockquote></li><li><p>源抑制</p><blockquote><p>设计目的是为了实现拥塞控制，但是现实中未使用。当路由器发现自身缓冲队列已满的时候会丢弃接受的报文，同时向源主机发送ICMP报文</p></blockquote></li><li><p>超时/超期</p><blockquote><p>TTL超时，当报文TTL减为0时，路由器会将报文丢弃，并向源主机发送ICMP报文</p></blockquote></li><li><p>参数问题</p><blockquote><p>当一个路由器发现报文头部某些参数有问题时，会将报文丢弃，并发送ICMP报文给主机。</p></blockquote></li><li><p>重定向</p><blockquote><p>当路由器发现报文不应该经过自己转发时，会向主机发送ICMP报文给主机，让主机重新选择路由方向</p></blockquote></li></ul></li><li><p>网络探询报文</p><ul><li><p>回声请求与应答报文</p><blockquote><p>主机或路由器主动发送ICMP报文，用于检测目的主机是否可达或者网络情况，目的主机收到报文后会返回应答报文。例如ping命令。</p></blockquote></li><li><p>时间戳请求与应答报文</p><blockquote><p>获取时间戳</p></blockquote></li></ul></li></ul></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210429100532170.png" alt="ICMP报文"></p><p>类型值和编码值组合起来就代表了特定的ICMP报文。如80就代表ping命令。</p></li><li><p>例外情况：</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210429100917693.png" alt="例外情况"></p></li><li><p>ICMP报文格式</p><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210429101048491.png" alt="ICMP报文格式"></p><blockquote><p>ICMP报文的校验和是对整个ICMP报文进行校验</p></blockquote></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210429101334930.png" alt="ICMP差错报告报文"></p><p>UDP的前8字节就是全部头部，而TCP前8个字节是源端口、目的端口信息。</p></li><li><p><img src="/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_03%E7%BD%91%E7%BB%9C%E5%B1%82_%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/image-20210429101622431.png" alt="ICMP应用：Traceroute"></p><blockquote><p>注：traceroute每组报文一般是发3个报文。即TTL=1的三个，TTL=2的三个，TTL=3的三个…</p></blockquote><blockquote><p>短期内两个主机之间的路由路径不会发生改变。路由表更新没有那么快。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络重难点-滑动窗口</title>
      <link href="2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络重难点-滑动窗口"><a href="#计算机网络重难点-滑动窗口" class="headerlink" title="计算机网络重难点-滑动窗口"></a>计算机网络重难点-滑动窗口</h2><h3 id="1-回退N步（GBN）协议"><a href="#1-回退N步（GBN）协议" class="headerlink" title="1 回退N步（GBN）协议"></a>1 回退N步（GBN）协议</h3><h4 id="1-1-GBN的发送方"><a href="#1-1-GBN的发送方" class="headerlink" title="1.1 GBN的发送方"></a>1.1 GBN的发送方</h4><p>在回退N步协议中，允许发送方发送多个分组而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N.</p><p><img src="/2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/20200220164803465.png" alt="发送窗口"></p><p>如上图所示，显示了发送方看到的GBN协议的序号范围。将基序号（base） 定义为最早的未确认分组的序号，将下一个序号（nextseqnum） 定义为最小的未使用的序号（即下一个待发分组的序号。）</p><span id="more"></span><p>将序号范围分为了4段。[0,base−1]对应于已经发送并被确认的分组；[base,nextseqnum−1]段内的序号对用于已经发送但未被确认的序号;[nextseqnum,base+N−1]段内的序号能用于哪些要被立即发送的分组（如果有数据来自上层的话）；最后，大于或等于base+N的序号是不能使用的，知道当前流水线中未被确认的分组已得到确认为止。</p><p>根据上图，那些已经发送但未被确认的分组的许可或范围可以被看成是一个在序号范围内长度为N的窗口，随着协议的运行，该窗口在序号空间向前滑动。因此，N被称为窗口长度，GBN协议也常被称为滑动窗口协议。（为什么要限制这些被发送的，未被确认的分组数为N？为什么不允许这些分组为无限制的数目？这是因为流量控制是对发送发方的限制原因之一。）</p><p>在实践中，一个分组的序号承载在分组首部的一个固定长度字段中。如果分组序号字段的比特数为K比特，那么序号范围为[ 0 , 2<sup>k</sup> − 1 ]在一个有序的序号范围内，所有设计序号的运算必须使用模2<sup>k</sup>运算。</p><h4 id="1-2-下面是基于ACK-无NAK的GBN协议发方和接收方的扩展FSM"><a href="#1-2-下面是基于ACK-无NAK的GBN协议发方和接收方的扩展FSM" class="headerlink" title="1.2 下面是基于ACK,无NAK的GBN协议发方和接收方的扩展FSM."></a>1.2 下面是基于ACK,无NAK的GBN协议发方和接收方的扩展FSM.</h4><h5 id="1-2-1-发送方扩展FSM"><a href="#1-2-1-发送方扩展FSM" class="headerlink" title="1.2.1 发送方扩展FSM"></a>1.2.1 发送方扩展FSM</h5><p><img src="/2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/20200220164825495.png" alt="发送方扩展FSM"></p><p>详细解释</p><ul><li><p>1 表示初始化</p><p>将基序号（base） 定义为最早的未确认分组的序号，将下一个序号（nextseqnum） 定义为最小的未使用的序号（即下一个待发分组的序号。）</p></li><li><p>2 上层调用  传来数据rdt_send(data)</p><p>发送方行为：如果滑动窗口可以承载nextseqnum序号的报文段，则封装报文段并将其发送，如果此时base==nextseqnum即新发送的报文段是最早发送的，则开始计时，然后nextseqnum加一（即前沿加一）；如果不可以承载nextseqnum的报文段，则拒绝接收它。</p></li><li><p>3 超时事件</p><p>如果计时器超时了，即最早发送的报文段base一直没有被确定触发超时事件，发送方将会将base以及其之后所有的报文段重新发送。</p></li><li><p>4 发送方收到ACK并且ACK没有出错</p><p>则将ACK中序号取出，该序号加一即为新的base，这表示该ACK序号以及之前的报文段都被确认了，新的最早的未被确认报文段base变成了base+1。实际是滑动窗口后沿滑动。</p><p>然后如果新的最早的未被确认报文段base与下一个待发分组的序号nextseqnum一致表示滑动窗口为空，停止计时；否则滑动窗口不为空，开始新base的计时。</p></li><li><p>5 发送方收到ACK但是ACK出错</p><p>发送方不做任何动作</p></li></ul><h5 id="1-2-2-接收方扩展FSM"><a href="#1-2-2-接收方扩展FSM" class="headerlink" title="1.2.2 接收方扩展FSM"></a>1.2.2 接收方扩展FSM</h5><p><img src="/2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/20200220164839130.png" alt="接收方扩展FSM"></p><p>详细解释</p><ul><li><p>1 表示初始化</p><p>expectedseqnum=1 这里与发送方保持一致（协议要求）。</p><p>同时做好对前一个分组0确认sndpkt，但是没有发送</p></li><li><p>2 收到发送方报文段，没有出错，同时与期待的序号一致</p><p>则将报文段解封装，并将数据上传给上一层。然后将expectedseqnum对应ACK发送给发送方。</p><p>expectedseqnum++即滑动窗口滑动。</p></li><li><p>3 其他事件</p><p>发送最后一个正确接收的分组0确认sndpkt</p></li></ul><h4 id="1-3-下面是窗口长度为4个分组的GBN协议运行情况"><a href="#1-3-下面是窗口长度为4个分组的GBN协议运行情况" class="headerlink" title="1.3 下面是窗口长度为4个分组的GBN协议运行情况"></a>1.3 下面是窗口长度为4个分组的GBN协议运行情况</h4><p><img src="/2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/20200220164855988.png" alt="GBN协议运行"></p><p><img src="/2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/image-20210419205128687.png" alt="GBN协议运行"></p><h3 id="2-选择重传（SR）协议"><a href="#2-选择重传（SR）协议" class="headerlink" title="2 选择重传（SR）协议"></a>2 选择重传（SR）协议</h3><p><img src="/2021/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/image-20210419142220547.png" alt="SR运行"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-传输层</title>
      <link href="2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-传输层"><a href="#计算机网络-传输层" class="headerlink" title="计算机网络-传输层"></a>计算机网络-传输层</h2><ul><li><p>目标：</p><ul><li><p>理解传输层的工作原理</p><ul><li>多路复用/解复用</li><li>可靠数据传输 RDT</li></ul><blockquote><p>TCP是可靠的，但是它的下层IP服务是不可靠的，那么TCP应该以什么方式实现可靠传输。</p></blockquote><ul><li>流量控制</li><li>拥塞控制</li></ul><span id="more"></span></li><li><p>学习Internet的传输层协议</p><ul><li>UDP：无连接传输</li><li>TCP：面向连接的可靠传输</li><li>TCP的拥塞控制</li></ul></li></ul></li></ul><h3 id="1-概述和传输层服务"><a href="#1-概述和传输层服务" class="headerlink" title="1 概述和传输层服务"></a>1 概述和传输层服务</h3><ul><li><p>传输服务和协议</p><ul><li><p>为运行在不同主机上的应用<strong>进程</strong>以报文段为单位提供<strong>逻辑通信</strong></p></li><li><p>传输协议运行在端系统</p><ul><li>发送方：将应用层的报文分成报文段，然后传递给网络层</li></ul><blockquote><p>如果报文比较长，传输层会将报文分成若干报文段</p></blockquote><ul><li>接收方：将报文段重组成报文，然后传递给应用层</li></ul><blockquote><p>将报文段的段头去掉，然后按顺序将报文段结合起来成报文，然后以字节流方式上传</p></blockquote></li><li><p>有多个传输层协议可供应用选择</p><ul><li>Internet: TCP和UDP</li></ul><blockquote><p>向下，网络层就都是IP提供服务</p></blockquote></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210416225619983.png" alt="传输层服务"></p></li><li><p>传输层 vs. 网络层</p><ul><li><p>网络层服务：<strong>主机之间</strong>的逻辑通信</p></li><li><p>传输层服务：<strong>进程间</strong>的逻辑通信</p><blockquote><p>通过增加16位端口号的机制，实现了主机到进程的细化</p></blockquote><ul><li>依赖于网络层的服务<ul><li>延时、带宽</li></ul></li><li>并对网络层的服务进行增强<ul><li>对数据丢失、顺序混乱等处理-可靠性</li></ul></li><li>对数据进行加密-安全性<ul><li>复用/解复用</li></ul></li></ul></li></ul><blockquote><p>有些服务是可以加强的：不可靠 → 可靠；安全</p><p>但有些服务是不可以被加强的：带宽，延迟</p></blockquote><ul><li>传输层提供了复用/解复用的功能</li></ul><blockquote><p>类比：东西2个家庭的通信</p><p>Ann家的12个小孩给另Bill家的12个小孩发信共144封，分开传输代价太大，所以Ann打包到一封信一起给邮政公司传输（复用），然后到Bill家Bill再分开按照信的标识分别分发（解复用）给12个孩子</p><ul><li><p>主机 = 家庭   进程 = 小孩</p></li><li><p>应用层报文 = 信封中的信件</p></li><li><p>传输协议 = Ann和Bill</p><ul><li>为家庭小孩提供复用、解复用服务</li></ul></li><li><p>网络层协议 = 邮政服务</p><ul><li>家庭-家庭的邮包传输服务</li></ul></li></ul></blockquote></li><li><p>Internet传输层协议</p><ul><li>可靠的、保序的传输：TCP<ul><li>多路复用、解复用</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li><li>向上层应用层提供的是字节流的服务</li></ul></li><li>不可靠、不保序的传输：UDP<ul><li>多路复用、解复用</li><li>没有为尽力而为的IP服务添加更多的其它额外服务</li><li>向上层应用层提供的是数据报的服务</li></ul></li><li>都不提供的服务：<ul><li>延时保证</li><li>带宽保证</li></ul></li></ul></li></ul><h3 id="2-多路复用与解复用"><a href="#2-多路复用与解复用" class="headerlink" title="2 多路复用与解复用"></a>2 多路复用与解复用</h3><ul><li>多路复用/解复用</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419115834515.png" alt="多路复用/解复用"></p><p>多路复用：传输层对每个报文段进行封装相应的端口号。</p><p>多路解复用：传输层根据每个报文段的端口号将其传递给不同的Socket。</p><blockquote><p>数据主要根据网络层封装的IP地址寻找目标主机，然后在目标主机传输层解封装，根据传输层的头中的端口号解复用给对应目标进程</p></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210417145437105.png" alt="传输过程"></p><ul><li><p>多路解复用工作原理</p><ul><li>解复用作用：TCP或者UDP实体通过端口号，将报文段的数据部分交给正确的socket，从而交给正确的进程</li><li>主机收到IP数据报<ul><li>每个数据报有源IP地址和目标IP地址</li><li>每个数据报承载一个传输层报文段</li><li>每个报文段有一个源端口号和目标端口号 (特定应用有著名的端口号) </li></ul></li><li>主机联合使用IP地址和端口号将报文段发送给合适的套接字</li><li>TCP和UDP不同</li></ul></li><li><p>无连接（UDP）多路解复用</p><ul><li>创建套接字： </li></ul><p>服务器端： </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverSocket=socket(PF_INET,  SOCK_DGRAM,<span class="number">0</span>); </span><br><span class="line">bind(serverSocket, &amp;sad, <span class="keyword">sizeof</span>(sad));</span><br></pre></td></tr></table></figure><blockquote><p>serverSocket和Sad指定的端口号捆绑 </p></blockquote><p>客户端： </p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClientSocket=socket(PF_INET,  SOCK_DGRAM,<span class="number">0</span>); </span><br></pre></td></tr></table></figure><blockquote><p> 没有Bind，ClientSocket和OS为之分配的某个端口号隐式捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）</p></blockquote><ul><li><p>在接收端，UDP套接字用二元组标识 (目标IP地址、目标端口号即本地server的IP和端口号) </p></li><li><p>当主机收到UDP报文段： </p><ul><li>检查报文段的目标端口号</li><li>用该端口号将报文段定位给套接字</li></ul></li><li><p>如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</p></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210417151731561.png" alt="UDPsocket表"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210417153511155.png" alt="无连接多路复用"></p><blockquote><p><font color="red">疑问：这里来自不同主机和复用/解复用有什么关系？特别是复用？</font></p></blockquote></li><li><p>面向连接（TCP）的多路解复用</p><ul><li>TCP套接字:四元组本地标识：<ul><li>源IP地址 </li><li>源端口号 </li><li>目的IP地址 </li><li>目的端口号</li></ul></li><li>解复用：接收主机用这四个值来将数据报定位到合适的套接字</li><li>服务器能够在一个TCP端口上同时支持多个 TCP套接字：<ul><li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li></ul></li><li>Web服务器对每个连接客户端有不同的套接字 <ul><li>非持久对每个请求有不同的套接字</li></ul></li></ul></li></ul><h3 id="3-无连接传输：UDP（User-Datagram-Protocol）"><a href="#3-无连接传输：UDP（User-Datagram-Protocol）" class="headerlink" title="3 无连接传输：UDP（User Datagram Protocol）"></a>3 无连接传输：UDP（User Datagram Protocol）</h3><ul><li><p>网络层的IP服务是主机到主机的尽力而为的传输，UDP在其基础上增加端口号实现了进程到进程，但是没有增加其他额外的功能</p></li><li><p>“no frills,”“bare bones”Internet传输协议</p></li><li><p>“尽力而为”的服务，报文段可能丢失或者送到应用进程的报文段乱序 </p></li><li><p>无连接： </p><ul><li>UDP发送端和接收端之间没有握手 </li><li>每个UDP报文段都被独立地处理</li></ul></li><li><p>UDP 被用于: </p><ul><li>流媒体（丢失不敏感，速率敏感、应用可控制传输速率）</li><li>DNS</li><li>SNMP</li></ul></li><li><p>在UDP上可行可靠传输：</p><ul><li>在应用层增加可靠性</li><li>应用特定的差错恢复</li></ul></li><li><p>UDP报文段格式</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210417155905728.png" alt="UDP报文段格式"></p><ul><li>包括头部和载荷（sdu）</li><li>头部：8字节<ul><li>源端口号2字节    目的端口号2字节   </li><li>长度：报文段整个长度   包括头部</li><li>校验和<ul><li>EDC 差错校验码，判断包括头部、载荷在传输过程是否出错，如果出错则将报文丢失</li></ul></li></ul></li></ul></li><li><p>为什么要有UDP？</p><ul><li>不建立连接 （会增加延时）</li><li>简单：在发送端和接收端没有连接状态</li><li>报文段的头部head很小（cost开销小） 只有8个字节</li><li>无拥塞控制和流量控制，UDP可以尽可能快的发送报文段<ul><li>应用数据从应用层向下层传递的传输的速率近似等于主机到主机的网络传递的速率，来多快，传多快</li></ul></li></ul></li><li><p>UDP校验和</p><ul><li><p>目标： 检测在被传输报文段中的差错 (如比特反转)</p></li><li><p>发送方： </p><ul><li>将报文段的内容视为16比特的整数</li><li>校验和：报文段的加法和 （1的补运算） </li><li>发送方将校验和放在UDP的校验和字段</li></ul></li><li><p>接收方：</p><ul><li><p>计算接收到的报文段的校验和 </p></li><li><p>检查计算出的校验和与校验和字段的内容是否相等：</p><ul><li><p>不相等––检测到差错</p></li><li><p>相等––没有检测到差错，但也许还是有差错 </p><ul><li><p>残存错误</p><blockquote><p>例如，发送方UDP报文段包括：校验和EDC+其他数据D（头部其它内容+载荷+伪头部等），而接收方UDP报文段包括：校验和EDC’+其他数据D’（头部其它内容+载荷+伪头部等），巧合情况：D’计算出的校验和与校验和EDC’字段的内容相等</p></blockquote></li></ul></li></ul></li></ul></li></ul></li><li><p>Internet校验和的例子</p><ul><li><p>当数字相加时，在最高位的进位要回卷，再加到结果上 </p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210417162713542.png" alt="校验和示例"></p></li><li><p>Internet校验和，就是将D（头部其它内容+载荷+伪头部等）分为一个个16bit，然后进行一一相加、进位回滚、反码求出校验和。</p><p>然后目标端将收到的D’进行一一相加、进位回滚，然后加上校验和EDC’，如果结果等于1111111111111111则通过校验，否则没有通过校验</p><p>注：求和时，必须将进位回卷到结果</p></li></ul></li></ul><h3 id="4-可靠数据传输（RDT）的原理"><a href="#4-可靠数据传输（RDT）的原理" class="headerlink" title="4 可靠数据传输（RDT）的原理"></a>4 可靠数据传输（RDT）的原理</h3><ul><li><p>rdt在应用层、传输层和数据链路层都很重要</p></li><li><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418193316439.png" alt="RDT示意图"></p></li><li><p>信道的不可靠特点决定了可靠数据传输协议的复杂性</p><blockquote><p>IP协议不可靠，而要实现TCP的可靠传输。即在下层协议不可靠的情况下实现传输的可靠性。</p></blockquote></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418193748310.png" alt="RDT"></p><blockquote><p>red_send()和deliver_data()是上层与本层的接口/调用的原语，udt_send()和udt_rcv()是下层与本层的接口/调用的原语。</p></blockquote><h4 id="4-1-可靠数据传输原理演绎"><a href="#4-1-可靠数据传输原理演绎" class="headerlink" title="4.1 可靠数据传输原理演绎"></a>4.1 可靠数据传输原理演绎</h4><blockquote><p>我们将：</p><p>渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方</p><p>只考虑单向数据传输，但控制信息是双向流动的！双向的数据传输问题实际上是2个单向数据传输问题的综合。</p><p>使用有限状态机(FSM) 来描述发送方和接收方</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418194409229.png" alt="有限状态机FSM"></p></blockquote><ul><li><p>RDT1.0   在可靠信道上的可靠数据传输</p><ul><li><p>下层信道是完全可靠的</p><ul><li>不出错  没有比特出错 即没有比特翻转</li><li>不丢失  没有丢失</li></ul></li><li><p>发送方和接收方的FSM</p><ul><li><p>发送方将数据封装然后发送到下层信道</p></li><li><p>接收方从下层信道接收数据并解封装后传给上层</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418194644193.png" alt="rdt1.0"></p></li></ul></li></ul></li><li><p>RDT2.0   具有比特差错的信道</p><ul><li><p>下层信道可能会出错：将中的比特翻转</p><ul><li>解决方案：用校验和来检测比特差错</li></ul></li><li><p>问题：怎样从差错中恢复：</p><ul><li>确认(ACK)：接收方显式地告诉发送方已被正确接收</li><li>否定确认(NAK): 接收方显式地告诉发送方发生了差错，发送方收到NAK后，发送方重传</li></ul></li><li><p>rdt2.0中的新机制：采用差错控制编码进行差错检测</p><ul><li><p>发送方增加差错控制的编码功能，同时将数据暂时缓存（以便检错重传）</p><blockquote><p>发送端在发送完数据时，必须在其发送缓存中暂时保留这个数据的副本。这样才能在出差错时进行重传。只有确认对方已经收到这个数据时，才可以清除这个副本。</p></blockquote></li><li><p>接收方需要具备解码功能，使用编码来进行检错</p></li><li><p>接收方的反馈：控制报文（ACK，NAK）：接收方→发送方</p></li><li><p>发送方收到反馈相应的动作，收到ACK发送下一个数据或者结束对话；收到NAK对相应的数据进行重传。</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418200541880.png" alt="RDT2.0"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418201116156.png" alt="RDT2.0无差错时"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418201142077.png" alt="RDT2.0有差错"></p></li></ul></li></ul></li><li><p>RDT2.0的致命错误 -&gt;改进成RDT2.1</p><ul><li><p>RDT2.0的致命错误：如果ACK/NAK传输出错了怎么办？</p><ul><li>发送方不知道接收方发送了什么，传递过来的ACK/NAK信号出错后无意义了。发送方如果重传，可能数据重复；如果不重传，可能死锁（或出错）。</li></ul></li><li><p>解决方案：引入序号机制，解决重复问题</p><ul><li>发送方在每个中加入序号，如果ACK/NAK出错，发送方重传当前，接收方通过序号判断后丢弃重复（不发送给上层）并传递回去ACK（为了让发送方接着发下面的数据）</li></ul></li><li><p>停止等待协议（stop-and-wait）：发送方发送一个之后，等待接收方的应答以后才继续发下一个协议</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418202450287.png" alt="RDT2.1  发送方处理出错的协议"></p><blockquote><p>corrupt(rcvpkt)表示接收到的ACK/NCK出错，则重新发送数据；notcorrupt(rcvpkt)表示接收到的ACK/NAK未出错</p></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418202547391.png" alt="RDT2.1  接收方处理出错的协议"></p><blockquote><p>注：接收方的序号要和发送方保持一致，发送方从0（或1）开始，那么接收方也要从0（或1）开始</p></blockquote><blockquote><p>其中，has_seq0(rcvpkt)表示接收到序号为0的，has_seq1(rcvpkt)表示接收到序号为1的，如果接收到的序号和接收方等待的序号相同，则表示没有出错；否则表示重复传送，接收方会将重复的丢弃（即不向上层传输），并且会发送一个ACK给发送方，以便继续下一个传输，同时使得双方序号一致。</p></blockquote><blockquote><p>其中，ACK/NAK传输需要先打包sndpkt=make_pkt(ACK/NAK,chksum)，再进行传输udt_send(sndpkt)。这是为了加入校验和机制，保证发送方收到正确的ACK/NAK</p></blockquote></li><li><p>RDT2.1的讨论</p><ul><li><p>发送方：</p><ul><li>在中加入序列号seq # </li><li>两个序号seq. #’s (0,1) 将够用. <ul><li>一次只发送一个未经确认的（停止等待协议）</li></ul></li><li>必须检测ACK/NAK是否出错（需要EDC来检验确认）</li><li>状态数变成了两倍<ul><li>必须记住当前的序列号为0还是1</li></ul></li></ul></li><li><p>接收方：</p><ul><li><p>必须检测接收到的是否是重复的</p><ul><li>状态指示是否0(/1)是所期待的序号seq #</li></ul></li><li><p>注意：接收方并不知道发送方是否正确收到了其ACK/NAK</p><ul><li><p>没有安排确认的确认</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418205915906.png" alt="没有安排确认的确认"></p></li></ul></li></ul></li></ul></li></ul></li><li><p>RDT2.2    无NAK的协议  （为流水线做准备）</p><ul><li><p>功能同rdt2.1，但只使用ACK（ack 要编号）</p></li><li><p>接收方对最后正确接收的发ACK，以替代NAK</p><ul><li>接收方必须显式地包含被正确接收的序号</li></ul></li><li><p>当收到重复的ACK（duplicate ACK 冗余ACK）（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前</p></li><li><p>为后面的一次发送多个数据单位做一个准备</p><ul><li>一次能够发送多个数据</li><li>每一个的应答都有：ACK，NACK；麻烦</li><li>使用对前一个数据单位的ACK，代替本数据单位的nak</li><li>确认信息减少一半，协议处理简单</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418210919540.png" alt="RDT2.2运行方式"></p><p>​                        <img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418211349297.png" alt="RDT2.2  如果ack出错"></p><blockquote><p>如果ack出错，发送方会将再次发送，接受方收到以后与期望的序号对比然后进行处理（同RDT2.1)。</p></blockquote></li><li><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210418211633987.png" alt="RDT2.2"></p></li></ul></li><li><p>rdt3.0：具有比特差错和丢失的信道</p><ul><li><p>新的情况：下层信道可能会丢失（数据或ACK），这将导致死锁现象</p></li><li><p>解决方法：引入新的机制：超时重传</p><blockquote><p>timeout的时间设置和传输的往返时间有关。链路层的往返时间分布比较集中，所以链路层的timeout时间一般是确定的。而传输层timeout与网络情况等因素有关，分布可能比较分散，所以传输层timeout时间是适应式的、动态的。</p></blockquote><ul><li>发送方超时重传：发送方等待ACK一段合理的时间，如果到时没有收到ACK，则进行重传</li><li>问题：如果（或ACK）只是被延迟了或者ACK丢失了，那么重传将会导致数据重复。<ul><li>不过这个问题可以利用前面的序列号进行处理</li><li>所以接收方必须指明被正确接收的序列号</li></ul></li><li>超时重传机制需要一个倒计数定时器</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419083256752.png" alt="RDT3.0  发送方"></p><blockquote><p>左上角和右下角rdt_rcv(rcvpkt)是为了防止在发送方等待上层调用时，有延迟的ACK被传来回来，这时候发送方会丢弃这个ACK不做任何动作</p></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419083409132.png" alt="RDT3.0的运行"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419084157276.png" alt="RDT3.0的运行"></p><blockquote><p>（d）的情况是过早超时（延迟的ACK），即超时时间timeout设置地不合理，虽然因为有序号机制RDT也能正常工作，但是有一半的和确定是重复的，效率较低。</p></blockquote></li><li><p>RDT3.0的性能</p><ul><li><p>rdt3.0可以工作，但链路容量比较大的情况下，性能很差</p><ul><li>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419084555631.png" alt="RDT3.0在链路容量较大时性能很差"></p><blockquote><p>信道利用率很低   </p></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419093235656.png" alt="RDT3.0的停等操作导致信道利用率很低"></p></li></ul></li></ul></li><li><p>流水线协议</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419093417023.png" alt="流水线提高链路利用率"></p><blockquote><p>有的局域网中链路带宽很小，没有必要使用流水线协议</p></blockquote><p>流水线：允许发送方在未得到对方确认的情况下一次发送多个</p><ul><li><p>必须增加序号的范围:用多个bit表示的序号</p></li><li><p>在发送方/接收方要有缓冲区</p><ul><li><p>发送方缓冲：存放未得到确认，可能需要重传的；</p></li><li><p>接收方缓存：上层用户取用数据的速率≠接收到的数据速率接收到的数据，需要暂存；同时可能乱序，需要进行排序交付（可靠）</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419094003599.png" alt="流水线方式"></p><ul><li>两种通用的流水线协议：回退N步(GBN)和选择重传(SR)<ul><li>stop-and-wait   sw(发送窗口)=1   rw(接收窗口)=1 </li><li>GBN     sw&gt;1   rw=1</li><li>SR        sw&gt;1   rw&gt;1</li></ul></li></ul></li></ul></li></ul></li><li><p>通用：滑动窗口（slide window）协议</p><ul><li><p>发送缓冲区</p><ul><li>形式：内存中的一个区域，落入缓冲区的可以发送</li><li>功能：用于存放已发送，但是没有得到确认的</li><li>必要性：需要重发时可用</li></ul></li><li><p>发送缓冲区的大小：一次最多可以发送多少个未经确认的</p><ul><li>停止等待协议发送缓冲区=1</li><li>流水线协议发送缓冲区&gt;1，合理的值，不能很大，链路利用率不能够超100%</li></ul></li><li><p>发送缓冲区中的</p><ul><li>未发送的：落入发送缓冲区的，可以连续发送出去；</li><li>已经发送出去的、等待对方确认的：发送缓冲区的只有得到确认才能删除<ul><li>已经发送出去的、等待对方确认的的最大数量称之为发送窗口大小</li></ul></li></ul></li><li><p>发送窗口：发送缓冲区内容的一个范围，即那些已发送但是未经确认的序号构成的空间</p><ul><li><p>发送窗口的最大值&lt;=发送缓冲区的值</p></li><li><p>一开始：没有发送任何一个</p><ul><li>后沿=前沿</li><li>之间为发送窗口的尺寸=0</li></ul></li><li><p>每发送一个，前沿前移一个单位</p><ul><li><p>发送窗口前沿移动的极限：不能够超过发送缓冲区</p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419100050976.png" alt="发送窗口" style="zoom:85%;"><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419100109447.png" alt="发送窗口大小不能超过发送缓冲区"></p></li><li><p>用相对表示方法来表示发送窗口滑动过程</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419100425909.png" alt="相对表示法表示窗口滑动"></p><blockquote><p>真正滑动应该是进行左滑，缓冲区不动。为了方便，采用不动，缓冲区右滑来表示相对滑动。</p></blockquote></li></ul></li><li><p>每收到一个确认ACK，后沿前移一个单位</p><ul><li><p>条件：收到老的确认</p></li><li><p>结果：发送缓冲区中去除掉老的缓冲，新的可以加入进来</p></li><li><p>移动极限：后沿不能够超过前沿</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419101004094.png" alt="后沿的移动"></p></li></ul></li><li><p>滑动窗口技术的发送窗口</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419101202950.png" alt="滑动窗口技术的发送窗口"></p></li></ul></li><li><p>接收窗口（receiving window）= 接收缓冲区</p><ul><li><p>接收窗口用于控制哪些可以接收；</p><ul><li>只有收到的的序号落入接收窗口内，这个才允许接收</li><li>若序号在接收窗口之外，则丢弃这个；</li></ul></li><li><p>接收窗口尺寸Wr=1，则只能顺序接收；     – GBN</p></li><li><p>接收窗口尺寸Wr&gt;1 ，则可以乱序接收        – SR</p><ul><li>但提交给上层的，要按序传给上层，所以接受窗口不是收到一个就右移一次，有可能不移动，有可能一次移动多个窗口</li></ul></li><li><p>例子：Wr＝1，在0的位置；只有0号可以接收；向前滑动一个，罩在1的位置，如果来了第2号，则丢弃；</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419101516246.png" alt="接收窗口"></p></li><li><p>接收窗口的滑动和发送确认</p><ul><li><p>发送确认：</p><ul><li><p>接收窗口尺寸=1 ； 发送连续收到的最大的确认（累计确认）</p></li><li><p>接收窗口尺寸&gt;1 ； 收到，发送那个的确认（非累计确认）</p><ul><li>低序号的到来，接收窗口滑动；</li><li>高序号乱序到，缓存但不交付（因为要实现rdt不允许失序），不滑动</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419102556866.png" alt="非累计确认的滑动"></p></li></ul></li></ul></li></ul></li><li><p>两个窗口互动</p><ul><li>正常情况下两个窗口互动</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419102740204.png" alt="正常情况下两个窗口的互动"></p><ul><li><p>异常情况下GBN的两窗口互动</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419102912491.png" alt="异常情况下GBN的两窗口互动"></p><blockquote><p>接收方接收到一个乱序的后，会将这个丢弃，并发送最新一个已被确认过的老的确认给发送方。</p><p>GBN中发送方只有一个计时器，即为最早等待确认的进行计时。超时时，将会发送序号大于等于这个的所有的。</p><p><font color="red">发送方收到已被确认过的老的确认后，不会做任何动作，直到最早等待确认的计时超时触发超时重发机制，</font>然后将发送窗口中的即所有的未确认过的依次重新发送。（因为虽然发送方可能有的之前发送过了，但是这些被接收方接收时可能还是乱序的。）</p></blockquote></li><li><p>异常情况下SR的两窗口互动</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419102947500.png" alt="异常情况下SR的两窗口互动"></p><blockquote><p>接收方收到乱序的（只要它的序号在接收窗口范围内）仍会接收，然后发送给发送方相应序号的ACK确定。发送方收到这个确认就会将这个对应的计时器关闭。</p><p>例如发送方发送了1，2，3三个序号的，会对应启动这三个的计时器，接受方先收到了1，3，接收方会接收这两并发送对应的ACK给发送方，但只会将1传给上层，而不会传3。然后发送方的发送缓冲区和窗口也只会移动一个单位将1移除（因为2还没有确定）。如果直到计时器超时，接收方还未收到2，那么发送方将重新发送2，直到接收方收到ACK2。接收方会将2，3顺序传递给上层并发送ACK2给发送方，发送方才会终止2的计时器并且发送窗口才会滑动到2，3离开窗口的位置。</p></blockquote></li></ul></li><li><p>GBN协议和SR协议的异同</p><ul><li>相同之处<ul><li>发送窗口&gt;1，一次能够发送多个未经确认的</li></ul></li><li>不同之处<ul><li>GBN的接收窗口=1<ul><li>接受端只能按顺序接收</li><li>发送端从表现来看，一旦一个没有发成功，如：0、1、2、3、4，如果1未成功，234即使发送出去了，仍要返回1重新开始从1的发送，即GB1。</li></ul></li><li>SR的接收窗口&gt;1<ul><li>接收端可以乱序接收</li><li>发送端发送0、1、2、3、4，即使1未发送成功超时了，2、3、4已发送就不需要重传，只需要选择1重新发送即可</li></ul></li></ul></li></ul></li><li><p>流水线协议：总结</p><ul><li>Go-back-N:<ul><li>发送端最多在流水线中有n个未确认的分组</li><li>接收端只是发送累计型确认cumulative ack<ul><li>接收端如果发现gap，不确认新到来的分组</li></ul></li><li>发送端拥有对最老的未确认分组的定时器<ul><li>只需设置一个定时器</li><li>当定时器到时时，重传所有未确认分组</li></ul></li></ul></li><li>Selective Repeat:<ul><li>发送端最多在流水线中有n个未确认的分组</li><li>接收方对每个到来的分组单独确认individual ack（非累计确认）</li><li>发送方为每个未确认的分组保持一个定时器<ul><li>当超时定时器到时，只是重发到时的未确认分组</li></ul></li></ul></li></ul></li></ul></li><li><p>GBN</p><ul><li><p>发送方扩展的FSM</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419135257158.png" alt="GBN发送方扩展的FSM"></p><blockquote><p>将基序号（base） 定义为最早的未确认分组的序号，将下一个序号（nextseqnum） 定义为最小的未使用的序号（即下一个待发分组的序号。）</p></blockquote></li><li><p>接收方扩展的FSM</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419135339216.png" alt="接收方扩展的FSM"></p><ul><li>只发送ACK：对顺序接收的最高序号的分组<ul><li>可能会产生重复的ACK</li><li>只需记住expectedseqnum；接收窗口=1<ul><li>只一个变量就可以表示接收窗口</li></ul></li></ul></li><li>对乱序的分组<ul><li>丢弃（不缓存）-&gt;在接收方不被缓存</li><li>对顺序接收的最高序号的分组进行确定-累计确认</li></ul></li></ul></li><li><p> 运行中的GBN<img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419140517502.png" alt="运行中的GBN"></p></li></ul></li><li><p>选择重传SR</p><ul><li><p>接收方对每个正确接收的分组，分别发送ACK(n)（非累积确认）</p><ul><li>接收窗口&gt;1，可以缓存乱序的分组</li><li>最终将分组按顺序交付给上层</li></ul></li><li><p>发送方只对那些没有收到ACK的分组进行重发-选择性重发</p><ul><li>发送方为每个未确认的分组设定一个定时器</li></ul></li><li><p>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</p></li><li><p>发送方</p><ul><li>从上层接收数据：<ul><li>如果下一个可用于该分组的序号可在发送窗口中，则发送</li></ul></li><li>timeout(n):<ul><li>重新发送分组n，重新设定这个分组的定时器</li></ul></li><li>ACK(n) in [sendbase,sendbase+N]:<ul><li>将分组n标记为已接收</li><li>如n为最小未确认的分组序号，将base移到下一个未确认序号</li></ul></li></ul></li><li><p>接收方</p><ul><li>分组n [rcvbase, rcvbase+N-1]<ul><li>发送ACK(n)</li><li>乱序：缓存</li><li>有序：该分组及以前缓存的序号连续的分组交付给上层，然后将窗口移到下一个仍未被接收的分组</li></ul></li><li>分组n [rcvbase-N, rcvbase-1]<ul><li>ACK(n)</li></ul></li><li>其它：<ul><li>忽略该分组</li></ul></li></ul></li><li><p>SR运行</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419142220547.png" alt="SR运行"></p></li></ul></li><li><p>对比GBN和SR</p><table><thead><tr><th></th><th>GBN</th><th>SR</th></tr></thead><tbody><tr><td>优点</td><td>简单，所需资源少（接收方一个缓冲单元）</td><td>出错时，重传一个代价小</td></tr><tr><td>缺点</td><td>一旦出错，回退N步代价大</td><td>复杂，所需要资源多（接收方多个缓存单元）</td></tr></tbody></table><ul><li>适用范围<ul><li>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理</li><li>链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大</li></ul></li></ul></li><li><p>窗口的最大尺寸</p><ul><li><p>如果用n个bit来标识序号，则GBN的最大发送窗口：2<sup>n</sup>-1        SR的最大发送窗口：2<sup>n-1</sup></p></li><li><p>例如：n=2; 序列号：0, 1, 2, 3</p></li><li><p>GBN =3        SR=2</p></li><li><p>SR的例子：</p></li><li><p>接收方看不到二者的区别！将重复数据误认为新数据(a)</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419143134083.png" alt="窗口最大长度示例"></p></li></ul></li></ul><h3 id="5-面向连接的传输TCP"><a href="#5-面向连接的传输TCP" class="headerlink" title="5 面向连接的传输TCP"></a>5 面向连接的传输TCP</h3><ul><li><p>TCP概述 RFCs：793  1122  1323  2018  2581</p><ul><li><p>点对点：一个发送方，一个接收方</p></li><li><p>向上层提供可靠的、按顺序的字节流：没有报文边界</p></li><li><p>管道化（流水线）：TCP拥塞控制和流量控制设置窗口的大小</p></li><li><p>发送和接收缓存</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419143702496.png" alt="发送和接收缓存"></p></li><li><p>全双工数据传输：在同一连接中数据流双向流动</p><ul><li><p>MSS：最大报文段大小</p><blockquote><p>每一个物理网络都有自己的最大传输单元MTU，例如以太网是1500字节，一次传输的帧的载荷部分最长就是1500字节。</p><p>所以应用层传给传输层的报文如果比较长的话，就需要分成一个个MSS（1460字节）的大小数据。然后再加上TCP的头部（20字节）；之后到了IP层面（20字节），再加上IP的头部。正好可以封装在以太网帧的载荷部分中，就是1500字节。</p><p>最大报文段长度（MSS）与最大传输单元（Maximum Transmission Unit, MTU）均是协议用来定义最大长度的。不同的是，MTU应用于OSI模型的第二层数据链接层，并无具体针对的协议。MTU限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小。例如，如果已知某局域网的MTU为1500字节，则在网络层的因特网协议（Internet Protocol, IP）里，最大的数据包大小为1500字节（包含IP协议头）。MSS针对的是OSI模型里第四层传输层的TCP协议。因为MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制。 </p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3" alt="MSS与MTU的区分"></p></blockquote></li></ul></li><li><p>面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方和接收方的状态</p></li><li><p>有流量控制：发送方不会淹没接收方</p></li><li><p>有拥塞控制</p></li></ul></li></ul><h4 id="5-1-段结构"><a href="#5-1-段结构" class="headerlink" title="5.1 段结构"></a>5.1 段结构</h4><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419143940708.png" alt="TCP报文段结构"></p><ul><li><p>源端口号（16比特）     目的端口号（16比特）</p></li><li><p>接收窗口：接收方能够接收的字节数量  用于流量控制</p></li><li><p>TCP序号：报文段数据部分的首字节的在整个报文字节流的偏移量</p><blockquote><p>与RDT中的序号不同</p></blockquote><blockquote><p>TCP序号：一个报文从应用层传递给传输层，将会按照MSS进行划分成多个MSS，这些MSS就是每个报文段的数据部分（body部分），每个MSS的第一个字节的相对于整个报文字节流首字节的偏移量（offset）就是它这个报文段的序号。</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419214811124.png" alt="TCP序号"></p><blockquote><p>这里第一个报文段的序号不一定是0，是由TCP传输双方经过协商以后决定，往往是其他数。</p></blockquote></blockquote></li><li><p>TCP确认号：期望从另一方收到的下一个字节的序号</p><ul><li>累计确认  类似GBN</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419144502276.png" alt="TCP序号和确认号"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419144706945.png" alt="序号和确认号场景"></p><blockquote><p>‘C’占用1个字节</p></blockquote><ul><li>问题：接收方如何处理乱序的报文段？-没有规定，可以进行缓存，也可以抛弃</li></ul></li><li><p>头部包括固定20字节的固定头部和可选项</p></li><li><p>TCP往返延时（RTT）和超时</p><ul><li><p>怎样设置TCP超时？</p><ul><li>比RTT要长<ul><li>但RTT是变化的</li></ul></li></ul></li><li><p>太短：太早超时，会导致不必要的重传</p></li><li><p>太长：对报文段丢失反应太慢，消极</p><ul><li><p>由于TCP的RTT与网络情况有关，所以TCP超时采用一种自适应的、动态的计算出的超时时间</p><blockquote><p>局域网中RTT较为集中，所以TCP可以是一个固定的值</p></blockquote></li></ul></li><li><p>怎样估计RTT？</p><ul><li>SampleRTT：测量某一个报文段从发出到收到确认的时间</li><li>如果有重传，忽略此次测量</li><li>SampleRTT会变化，因此估计的RTT应该比较平滑</li><li>对几个最近的测量值求平均，而不是仅用当前的SampleRTT（收到网络环境影响大）</li></ul></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419145433496.png" alt="超时时间计算"></p><blockquote><p>EstimatedRTT表示RTT均值，反应的是一段时间内的RTT<br>$$<br>当前EstimatedRTT = 前一时刻EstimatedRTT * (1-\alpha) + \alpha * 当前样本SampleRTT<br>$$</p></blockquote><ul><li>设置超时<ul><li><p>EstimtedRTT + 安全边界时间</p></li><li><p>EstimatedRTT变化大(方差大)→较大的安全边界时间（4*‘方差’）</p></li><li><p>SampleRTT会偏离EstimatedRTT多远（近似方差）：<br>$$<br>DevRTT = (1-\beta)<em>DevRTT+\beta</em>|SampleRTT-EstimatedRTT|<br>$$</p><p>$$<br>(推荐值：\beta = 0.25)<br>$$</p></li></ul></li><li>超时时间间隔设置为：<img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210419145624856.png" alt="超时时间间隔"></li></ul></li></ul><h4 id="5-2-可靠数据传输"><a href="#5-2-可靠数据传输" class="headerlink" title="5.2 可靠数据传输"></a>5.2 可靠数据传输</h4><ul><li><p>TCP在IP不可靠服务的基础上建立了RDT</p><ul><li>管道化的报文段，更接近于GBN与SR的混合体<ul><li>累计确认-类似GBN</li><li>单个重传定时器-类似GBN</li><li>是否接收乱序报文段-没有规定</li><li>通过以下事件可以触发重传：<ul><li>超时（只重发那个最早的未确定的段 -SR）</li><li>重复的确认（例如：收到ACK50之后又收到了3个ACK50）</li></ul></li></ul></li></ul></li><li><p>首先看一下简化版的TCP发送方</p><ul><li>忽略重复的确认</li><li>忽略流量控制和拥塞控制</li></ul></li><li><p>TCP发送方（简化版）</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420085437329.png" alt="TCP发送方（简化版）"></p><blockquote><p>这里左上初始化，NextSeqNum和SendBase是由双方协商确定而不是一个固定的值，原因：为了避免老的数据传输对新数据传输的影响</p></blockquote><blockquote><p>右上角表示发送方的前沿向前移动。上层传输数据后，先根据NextSeqNum为序号封装报文段，传递报文段，NextSeqNum加上传输的数据字节长就是新的NextSeqNum。然后如果时间定时器没有开始就开始计时。</p></blockquote><blockquote><p>定时器与最早未确认的报文段关联。定时器超时时，只传输最老的那个数据段，然后重新启动定时器</p></blockquote><blockquote><p>左下，收到了ACK，如果ACK中的序号y大于SendBase，SendBase移动到y这个位置，即发送方后沿向前移动。同时如果窗口中还有未被确认的报文段，定时器重新开始计时，否则定时器关闭。</p></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420091332921.png" alt="TCP简化的发送方"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420093051113.png" alt="TCP简化发送方的运行1"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420093120785.png" alt="TCP简化发送方的运行2"></p><ul><li>产生TCP ACK的建议    [RFC 1122，RFC 2581]</li></ul><table><thead><tr><th>接收方的事件</th><th>TCP接收方动作</th><th>目的</th></tr></thead><tbody><tr><td>所期望序号的报文段按序到达。所有在期望序号之前的数据都已经被确认</td><td>对前一个按序报文段的到达不直接发ACK，而是等待最多500ms。如果下一个报文段在这个时间间隔内没有到达，则发送这个段的ACK，如果到了发新来的段的ACK表示多个段的接收。</td><td>为了提高效率，一个ACK对多个段表示接收。</td></tr><tr><td>比期望序号大的报文段乱序到达。检测出数据流中的间隔（gap）。</td><td>立即发送接收方期待的段的ACK，让发送方尽快传输需要的段。</td><td></td></tr><tr><td>比期望序号大的报文段乱序到达之后又来了能部分或完全填充接收数据间隔的报文段到达。</td><td>若该报文段起始于间隔（gap）的低端，则立即发送ACK。</td><td>对已被接收的段发ACK</td></tr></tbody></table><ul><li><p>快速重传</p><ul><li><p>超时周期往往太长：在重传丢失报文段之前的延时太长</p></li><li><p>通过重复的ACK来检测报文段丢失</p><ul><li><p>发送方通常连续发送大量报文段</p></li><li><p>如果报文段丢失，通常会引起多个重复的ACK</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420202315682.png" alt="三个重复ACK"></p></li></ul></li><li><p>如果发送方收到同一数据的3个冗余ACK，重传最小序号的段：</p><ul><li><p>快速重传：在定时器过时之前重发报文段</p></li><li><p>它假设最小序号的未被确认段的数据丢失了</p><ul><li><p>第一个ACK是正常的；</p></li><li><p>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段；</p></li><li><p>收到第3，4个该段的ack，表示接收方收到该段之后的2个，3个乱序段，可能性非常大段丢失了</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420203027955.png" alt="TCP快速重传"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420203103596.png" alt="快速重传算法"></p></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="5-3-流量控制"><a href="#5-3-流量控制" class="headerlink" title="5.3 流量控制"></a>5.3 流量控制</h4><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420203636707.png" alt="流量控制"></p><ul><li><p>捎带技术（Piggybacking）：A发送给B的ACK和A接收缓冲区的大小都捎带在A发给B的TCP报文段中，即A向B发数据的同时对B发送过来的数据进行确认ACK并告知对方自己接收缓冲区的剩余大小。</p></li><li><p>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小</p><ul><li>RcvBuffer大小通过socket选项设置(典型默认大小为4096 字<br>节)</li><li>很多操作系统自动调整RcvBuffer</li></ul></li><li><p>发送方限制未确认(“inflight”)字节的个数≤接收方发送过来的rwnd 值</p></li><li><p>保证接收方不会被淹没</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420204620799.png" alt="接收方buffer"></p></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420204658667.png" alt="接收窗口"></p><h4 id="5-4-连接管理"><a href="#5-4-连接管理" class="headerlink" title="5.4 连接管理"></a>5.4 连接管理</h4><h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><ul><li><p>在正式交换数据之前，发送方和接收方握手建立通信关系:</p><ul><li><p>同意建立连接（每一方都知道对方愿意建立连接）</p></li><li><p>同意连接参数，参数置位</p><blockquote><p>特别是报文段初始序号的设定，以及双方rcvBuffer的大小</p></blockquote></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420205541533.png" alt="连接建立交换的数据"></p></li><li><p>两次连接进行建立连接可行吗？</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420210008611.png" alt="两次连接进行建立连接可行吗？"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420210037664.png" alt="两次连接建立不可行"></p></li><li><p>三次握手</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420210317096.png" alt="三次握手"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420213346432.png" alt="三次握手解决半连接和接收老数据问题"></p><blockquote><p>接收老数据的解决方案的前提：建立的连接双方序号seq每次由双方协定且临近的连接不相同</p></blockquote></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420213428313.png" alt="三次握手FSM"></p><h5 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h5><ul><li>客户端，服务器分别关闭它自己这一侧的连接</li><li>发送FIN bit = 1的TCP段</li><li>一旦接收到FIN，用ACK回应</li><li>接到FIN段，ACK可以和它自己发出的FIN段一起发送</li><li>可以处理同时的FIN交换</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210420214604099.png" alt="TCP关闭连接"></p><h3 id="6-拥塞控制原理"><a href="#6-拥塞控制原理" class="headerlink" title="6 拥塞控制原理"></a>6 拥塞控制原理</h3><ul><li><p>拥塞：</p><ul><li>非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力”</li><li> 与流量控制不同</li></ul></li><li><p>拥塞的表现：</p><ul><li> 分组丢失(路由器缓冲区溢出)</li><li> 分组经历比较长的延迟(在路由器的队列中排队)</li></ul></li><li><p>拥塞的原因：</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421090224814.png" alt="场景1"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421090537037.png" alt="场景2"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421090857894.png" alt="场景2-1"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421090947944.png" alt="场景2-2"></p><blockquote><p>丢失后才重发，导致入<sup>‘</sup><sub>in</sub>＞入<sub>out</sub></p></blockquote><blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421092459240.png" alt="场景2-现实情况"></p></blockquote><blockquote><p>输出比输出少的原因：</p><ol><li>入<sup>‘</sup><sub>in</sub>越接近 R/2，段丢失的越来越多，需要重发的越多，有效的发送越少。</li><li>网络拥塞导致一些段没有丢失，但是超时了，发送方重发了这些没必要重传的重复分组。</li></ol></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421093234808.png" alt="场景2-现实情况分析"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421095325872.png" alt="场景3"></p><blockquote><p>上面，蓝线和红线竞争，因为蓝色已经被路由器过滤了一次，相对小一些，蓝线的段被抛弃</p><p>右边，红线和绿线竞争，因为红色已经被路由器过滤了一次，相对小一些，红线的段被抛弃</p></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421095505428.png" alt="场景3分析"></p><blockquote><p>入<sup>‘</sup><sub>in</sub>越大入<sub>out</sub>，最后导致死锁现象</p></blockquote></li><li><p>拥塞控制方法：</p><ul><li>端到端拥塞控制：<ul><li>没有来自网络的显式反馈</li><li>端系统根据延迟和丢失事件推断是否有拥塞</li><li>TCP采用的方法</li></ul></li><li>网络辅助的拥塞控制：<ul><li>路由器提供给端系统以反馈信息<ul><li>单个bit置位，显示有拥塞(SNA，DECbit，TCP/IP ECN，ATM)</li><li>显式提供发送端可以采用的速率</li></ul></li></ul></li></ul></li><li><p>网络辅助的拥塞控制案例学习：ATM ABR 拥塞控制</p><ul><li><p>ABR: available bit rate：</p><ul><li>“弹性服务”</li><li>如果发送端的路径“轻载”，发送方使用可用带宽</li><li>如果发送方的路径拥塞了，发送方限制其发送的速度到一个最小保障速率上</li></ul></li><li><p>RM (资源管理) 信元：</p><ul><li><p>由发送端发送,在数据信元中间隔插入</p></li><li><p>RM信元中的比特被交换机设置(“网络辅助”)</p><ul><li><p>NI bit: no increase in rate (轻微拥塞)速率不要增加了</p></li><li><p>CI bit: congestion indication 拥塞指示</p><blockquote><p>路由器、交换机会根据网络情况将RM中的NI和CI位置1或0</p></blockquote></li></ul></li></ul></li></ul></li><li><p>发送端发送的RM信元被接收端返回</p><p>  <img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421100325517.png" alt="ATM ABR拥塞控制"></p><ul><li>在RM信元中还有2个字节的ER (explicit rate)字段<ul><li>ER记录的是交换机、路由器支持的最小的速率，拥塞的交换机、路由器会将ER降低</li><li>发送端通过ER获知路径上所支持的是最低速率</li></ul></li><li>数据信元中的EFCI bit：被拥塞的交换机设置成1<ul><li>如果在管理信元RM前面的数据信元EFCI被设置成了1, 接收端在返回的RM信元中设置CI bit</li></ul></li></ul></li></ul><h3 id="7-TCP拥塞控制"><a href="#7-TCP拥塞控制" class="headerlink" title="7 TCP拥塞控制"></a>7 TCP拥塞控制</h3><ul><li><p>TCP拥塞控制机制：端到端的拥塞控制机制</p><ul><li>路由器不向主机有关拥塞的反馈信息<ul><li>路由器的负担较轻</li><li>符合网络核心简单的TCP/IP架构原则</li></ul></li><li>端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</li></ul></li><li><p>拥塞控制的几个问题</p><ul><li>如何检测拥塞<ul><li>轻微拥塞</li><li>拥塞</li></ul></li><li>控制策略<ul><li>在拥塞发送时如何动作，降低速率<ul><li>轻微拥塞，如何降低</li><li>拥塞时，如何降低</li></ul></li><li>在拥塞缓解时如何动作，增加速率</li></ul></li></ul></li><li><p>发送端如何探测到拥塞？</p><ul><li>某个段超时了（丢失事件）：拥塞<ul><li>超时时间到，某个段的确认没有来</li><li>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大</li><li>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小</li><li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li></ul></li><li>有关某个段的3次重复ACK：轻微拥塞<ul><li>段的第1个ack，正常，确认绿段，期待红段</li><li>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</li><li>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了，红段都没到）</li><li>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</li></ul></li></ul></li><li><p>如何控制发送端发送的速率？</p><ul><li><p>维持一个拥塞窗口的值：CongWin</p></li><li><p>发送端限制已发送但是未确认的数据量（的上限）:<br>LastByteSent-LastByteAcked ≤ CongWin</p></li><li><p>从而粗略地控制发送方的往网络中注入数据的速率rate</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421101313128.png" alt="拥塞窗口"></p></li><li><p>CongWin是动态的，是感知到的网络拥塞程度的函数</p><ul><li>超时或者3个重复ack，CongWin↓<ul><li>超时时：CongWin降为1MSS，进入SS阶段然后再倍增到CongWin/2（每个RTT），从而进入CA阶段</li><li>3个重复ack ：CongWin降为CongWin/2，CA阶段</li></ul></li><li>否则（正常收到Ack，没有发送以上情况）：CongWin跃跃欲试↑<ul><li>SS阶段：加倍增加(每个RTT)</li><li>CA阶段：线性增加(每个RTT)</li></ul></li></ul></li></ul></li><li><p>TCP拥塞控制和流量控制的联合动作，联合控制的方法：</p><ul><li>发送端控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求<ul><li>发送窗口SendWin=min{拥塞窗口CongWin, 对方接收窗口RecvWin}</li><li>同时满足拥塞控制和流量控制要求</li></ul></li></ul></li><li><p>TCP拥塞控制策略</p><ul><li><p>慢启动</p><ul><li>连接刚建立, CongWin = 1MSS<ul><li>如: MSS = 1460bytes &amp;RTT = 200 msec，则初始速率= 58.4kbps</li></ul></li><li>可用带宽可能&gt;&gt;MSS/RTT<ul><li>应该尽快加速，到达希望的速率</li></ul></li><li>当连接开始时，指数性增加发送速率，直到发生丢<br>失的事件<ul><li>启动初值很低</li><li>但是速度很快</li></ul></li><li>当连接开始时，指数性增加（每个RTT）发送速率<br>直到发生丢失事件<ul><li>每一个RTT， CongWin加倍</li><li>每收到一个ACK时，CongWin加1（与CongWin加倍概念一致）</li><li>慢启动阶段：只要不超时或3个重复ack，一个RTT，<br>CongWin加倍</li></ul></li><li>总结: 初始速率很慢，但是加速却是指数性的<ul><li>指数增加，SS时间很短，长期来看可以忽略</li></ul></li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421102444017.png" alt="TCP慢启动"></p><p>改进</p><ul><li>Q：什么时候应该将指数性增长变成线性？</li><li>A：在超时之前，当CongWin变成上次发生超时的窗口的一半</li><li>实现：<ul><li>变量：Threshold</li><li>出现丢失，Threshold设置成CongWin的1/2</li></ul></li></ul></li><li><p>AIMD：线性增加、乘性减少</p><ul><li>乘性减：<br>丢失事件后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段（倍增直到CongWin/2）</li><li>加性增：<br>当CongWin&gt;阈值时，一个RTT如没有发生丢失事件，将CongWin加1MSS：探测</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421102659652.png" alt="AIMD"></p><ul><li><p>当收到3个重复的ACKs：</p><ul><li><p>CongWin 减半</p></li><li><p>窗口（缓冲区大小）之后线性增长</p><blockquote><p>3个重复的ACK表示网络还有一定的段传输能力，超时之前的3个重复的ACK表示“警报”</p></blockquote></li></ul></li><li><p>当超时事件发生时：</p><ul><li>CongWin被设置成1MSS，进入SS阶段</li><li>之后窗口指数增长</li><li>增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加</li></ul></li></ul></li></ul></li><li><p>总结：TCP拥塞控制</p><ul><li>当CongWin＜Threshold, 发送端处于慢启动阶段（slow-start）, 窗口指数性增长。</li><li>当CongWin＞Threshold, 发送端处于拥塞避免阶段（congestion-avoidance）, 窗口线性增长。</li><li>当收到三个重复的ACKs (triple duplicate ACK)，Threshold设置成CongWin/2，**<font color="red">CongWin=Threshold+3？？？</font>**。</li><li>当超时事件发生时timeout，Threshold=CongWin/2，CongWin=1 MSS，进入SS阶段。</li></ul><table><thead><tr><th>事件</th><th>状态</th><th>TCP发送端行为</th><th>解释</th></tr></thead><tbody><tr><td>以前没有收到ACK的data被ACKed</td><td>慢启动(SS)</td><td>CongWin = CongWin + MSSIf (CongWin &gt; Threshold)状态变成“CA”</td><td>每一个RTT CongWin 加倍</td></tr><tr><td>以前没有收到ACK的data被ACKed</td><td>拥塞避免(CA)</td><td>CongWin = CongWin+MSS *(MSS/CongWin)</td><td>加性增加, 每一个RTT对CongWin 加一个1 MSS</td></tr><tr><td>通过收到3个重复的ACK，发现丢失的事件</td><td>SS or CA</td><td>Threshold = CongWin/2,CongWin = Threshold+3,状态变成“CA”</td><td>快速重传, 实现乘性的减.CongWin 没有变成1MSS.</td></tr><tr><td>超时</td><td>SS or CA</td><td>Threshold = CongWin/2,CongWin = 1 MSS,状态变成“SS”</td><td>进入slow start</td></tr><tr><td>重复的ACK</td><td>SS or CA</td><td>对被ACKed 的segment， 增加重复ACK的计数</td><td>CongWin and Threshold不变</td></tr></tbody></table><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421104036896.png" alt="TCP拥塞控制 FSM"></p></li><li><p>TCP吞吐量</p><ul><li><p>TCP的平均吞吐量是多少，使用窗口window尺寸W和RTT来描述？</p><ul><li>忽略慢启动阶段，假设发送端总有数据传输</li></ul></li><li><p>W：发生丢失事件时的窗口尺寸（单位：字节）</p><ul><li>平均窗口尺寸（#in-flight字节）：3/4W</li><li>平均吞吐量：RTT时间吞吐3/4W</li></ul><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421104344393.png" alt="TCP吞吐量"></p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421104410539.png" alt="TCP未来"></p></li></ul></li><li><p>TCP公平性</p><p>公平性目标: 如果K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为R/K</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421104457692.png" alt="TCP公平性"></p><ul><li><p>为什么TCP是公平的？</p><ul><li><p>2个竞争的TCP会话：</p><ul><li>加性增加，斜率为1, 吞吐量增加</li></ul></li><li><p>乘性减，吞吐量比例减少</p><blockquote><p>最终效果：对于同一带宽R，竞争的n个会话均分，各占用R/n</p></blockquote><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421104625576.png" alt="TCP为什么是公平的"></p></li></ul></li><li><p>公平性和UDP</p><ul><li>多媒体应用通常不是用TCP<ul><li>应用发送的数据速率希望不受拥塞控制的节制</li></ul></li><li>使用UDP：<ul><li>音视频应用泵出数据的速率是恒定的, 忽略数据的丢失</li></ul></li><li>研究领域: TCP 友好性</li></ul></li><li><p>公平性和并行TCP连接</p><ul><li>2个主机间可以打开多个并行的TCP连接</li><li>占用带宽与会话个数有关：例如: 带宽为R的链路支持了9个连接;<ul><li>如果新的应用要求再建1个TCP连接,获得带宽R/10</li><li>如果新的应用要求再建11个TCP连接,获得带宽11R/20</li></ul></li></ul></li></ul></li><li><p>Explicit Congestion Notification (ECN)显示拥塞通告</p><ul><li><p>网络辅助拥塞控制：</p></li><li><p>TOS字段中2个bit被网络路由器标记，用于指示是否发生拥塞</p></li><li><p>拥塞指示被传送到接收主机</p></li><li><p>在接收方-到发送方的ACK中，接收方(在IP数据报中看到了拥塞指示）设置ECE bit，指示发送方发生了拥塞</p><p><img src="/2021/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_02%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210421105009143.png" alt="ECN"></p></li></ul></li></ul><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h3><ul><li>传输层提供的服务<ul><li>应用进程间的逻辑通信<ul><li>Vs 网络层提供的是主机到主机的通信服务</li></ul></li><li>互联网上传输层协议：UDP TCP<ul><li>特性</li></ul></li></ul></li><li>多路复用和解复用<ul><li>端口：传输层的SAP</li><li>无连接的多路复用和解复用</li><li>面向连接的多路复用和解复用</li></ul></li><li>实例1：无连接传输层协议UDP<ul><li>多路复用解复用</li><li>UDP报文格式</li><li>检错机制：校验和</li></ul></li><li>可靠数据传输原理<ul><li>问题描述</li><li>停止等待协议：<ul><li>Rdt1.0 rdt2.0,2.1 ,2.2 Rdt 3.0</li></ul></li><li>流水线协议<ul><li>GBN</li><li>SR</li></ul></li></ul></li><li>实例2：面向连接的传输层协议-TCP<ul><li>概述：TCP特性</li><li>报文段格式<ul><li>序号，超时机制及时间</li></ul></li><li>TCP可靠传输机制</li><li>重传，快速重传</li><li>流量控制</li><li>连接管理<ul><li>三次握手</li><li>对称连接释放</li></ul></li></ul></li><li>拥塞控制原理<ul><li>网络辅助的拥塞控制</li><li>端到端的拥塞控制</li></ul></li><li>TCP的拥塞控制<ul><li>AIMD</li><li>慢启动</li><li>超时之后的保守策略</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统-00基础学习路线</title>
      <link href="2021/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_00%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>2021/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F_00%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li>《MySQL必知必会》 - Ben forta </li><li>《高性能MySQL（第3版）》 - Baron Schwartz </li></ul><h3 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h3><ul><li><a href="http://db.lcs.mit.edu/6.830/index.php">麻省理工学院 MIT 6.830</a></li><li><a href="http://www.icourse163.org/course/HIT-1001516002">哈尔滨工业大学 数据库系统</a></li></ul><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计-00基础学习路线</title>
      <link href="2021/04/16/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_00%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>2021/04/16/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_00%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li><p>《Probability and Statistics》 -Morris H.Degroot</p></li><li><p>《概率论与数理统计》 -陈希孺</p></li></ul><h3 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1Zy4y1J7vM?p=2">概率数学基础 - 台湾大学叶丙成</a></li><li><a href="https://www.bilibili.com/video/BV1ot411y7mU?from=search&seid=5596277735640438059">《概率论与数理统计》教学视频全集（宋浩）</a></li></ul><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-00基础学习路线</title>
      <link href="2021/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_00%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>2021/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_00%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li>《现代操作系统》 - Andrew S. Tanenbaum</li><li>《深入理解计算机系统》</li><li>《操作系统导论》- Remzi，H. </li></ul><h3 id="推荐视频"><a href="#推荐视频" class="headerlink" title="推荐视频"></a>推荐视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=9067503727200252128">操作系统（哈工大李治军老师）32讲</a></li><li><a href="https://www.lanqiao.cn/courses/115">操作系统（哈工大李治军老师）32讲 -配套实验课</a></li><li><a href="https://www.bilibili.com/video/BV1iW411d7hd?from=search&seid=13353650717207742800d?from=search&seid=13353650717207742800">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统</a></li></ul><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><ul><li><a href="https://github.com/Exely/CSAPP-Labs">CSAPP-Labs</a></li></ul><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语单词</title>
      <link href="2021/04/12/English01/"/>
      <url>2021/04/12/English01/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>主要参考：<ul><li><a href="https://www.bilibili.com/video/BV12E411B7A5/?spm_id_from=333.788.recommend_more_video.0">朱伟考研英语-恋词序列一：题源7000词</a></li></ul></li></ul></blockquote><h2 id="Unit-One"><a href="#Unit-One" class="headerlink" title="Unit One"></a>Unit One</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ol><li>v. 声称，宣称</li><li>n. 政府  国家  <strong>州</strong> ；<strong>状况，情况</strong></li><li>adj. 国家的 国有的</li></ol><span id="more"></span><blockquote><p>例句  He stated that “all hell will break loose, politically and morally, all over the world. “</p><p>hell 地狱</p><p>break loose 松开</p><p>politically 政治地</p><p>morally  道德地</p></blockquote><blockquote><p>考点  to seek permission from state regulators</p><p>permission  n.允许   permit  v.允许</p><p>a state of mind  思想状况    a state of affairs  事情状况</p></blockquote><p>派生：statement   n.  评论，宣称、声明</p><ul><li><p>拓展词汇：</p><p>understate   v. 轻描淡写地表述；淡化（某事的严重性）</p><p>overstate v. 夸大，夸张（=exaggerate）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识</title>
      <link href="2021/04/12/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/04/12/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li>python是一门完全开源的高级编程语言，拥有优雅的语法和丰富的第三方库。</li><li>编程语言，是一种用于编写计算机程序的语言，用于控制计算机的行为。</li><li>按照语言在执行之前是否需要编译区分，可以将编程语言分为需要编译的编译型语言和不需要编译的解释型语言。</li></ul><p><img src="/2021/04/12/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210413224609458.png" alt="编程语言"></p><blockquote><p> 解释型语言运行要比编译型语言慢。</p></blockquote><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-01绪论</title>
      <link href="2021/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_01%E7%BB%AA%E8%AE%BA/"/>
      <url>2021/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_01%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统绪论"><a href="#操作系统绪论" class="headerlink" title="操作系统绪论"></a>操作系统绪论</h2><blockquote><ul><li>主要参考书籍：<ul><li>《操作系统导论》（Remzi H. Arpaci-Dusseau、Andrea C. Arpaci-Dusseau)</li><li>《操作系统概念》（Abraham Silberschatz、Peter Bear  Galvin、Greg  Gagne）</li></ul></li><li>主要参考视频：<ul><li><a href="https://www.bilibili.com/video/BV1d4411v7u7?from=search&seid=9067503727200252128">操作系统（哈工大李治军老师）32讲（全）超清</a></li></ul></li></ul></blockquote><span id="more"></span><h3 id="1-操作系统介绍"><a href="#1-操作系统介绍" class="headerlink" title="1 操作系统介绍"></a>1 操作系统介绍</h3><ul><li><p>程序运行时会发生什么？</p><p>一个正在运行的程序会做一件非常简单的事：执行指令。</p><p>处理器从内存中获取（fetch）一条指令，对其进行解码（decode）（弄清楚这是哪一条指令），然后执行</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-应用层</title>
      <link href="2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-应用层"><a href="#计算机网络-应用层" class="headerlink" title="计算机网络-应用层"></a>计算机网络-应用层</h2><ul><li><p>学习目标：</p><ul><li><p>网络应用的原理：网络应用协议的概念和实现方面</p><ul><li>网络应用的体系结构：<ul><li>客户-服务器模式     对等模式（peer-to-peer）     混合结构</li></ul></li><li>网络应用的服务需求：<ul><li>可靠性     带宽     时延</li></ul></li></ul><span id="more"></span></li><li><p>传输层提供的服务模型</p><ul><li>TCP、UDP 如何为应用层提供的支持？</li></ul></li><li><p>内容分发网络</p></li><li><p>网络应用的实例：互联网流行的应用层协议</p><ul><li>web应用–HTTP协议</li><li>文件传输应用–FTP协议</li><li>email应用–SMTP、POP3、IMAP协议</li><li>实现网络核心应用功能的DNS</li></ul></li><li><p>编程：如何开发网络应用程序？</p><ul><li>Socket API</li></ul></li></ul></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/20190324183705231.png" alt="应用层知识点框图"></p><h3 id="1-网络应用体系结构"><a href="#1-网络应用体系结构" class="headerlink" title="1 网络应用体系结构"></a>1 网络应用体系结构</h3><p>​    网络应用在不同的端系统上运行。网络应用通过网络基础设施提供的服务，应用进程彼此之间通信。例如web应用，web服务器软件和浏览器软件通信。</p><p>​    在网络核心中没有应用层软件，网络核心中没有应用层功能，网络应用只在端系统上存在，更方便网络应用的开发和部署。</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165338821.png" alt="网络应用开发和部署"></p><h4 id="1-1-客户机-服务器结构（Client-Server，C-S）"><a href="#1-1-客户机-服务器结构（Client-Server，C-S）" class="headerlink" title="1.1 客户机/服务器结构（Client-Server，C/S）"></a>1.1 客户机/服务器结构（Client-Server，C/S）</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165429573.png" alt="C/S"></p><ul><li><p>服务器</p><ul><li>一直运行</li><li>永久性访问地址/域名</li><li>利用大量服务器实现可拓展性，服务器场，数据中心进行扩展</li></ul></li><li><p>客户机</p><ul><li>主动与服务器通信，使用服务器提供的服务</li><li>间接性接入网络</li><li>可能是动态IP地址</li><li>不会与其他客户机直接通信</li></ul></li><li><p>缺点：</p><ul><li>可拓展性差，服务器有限的服务能力，链路带宽限制；</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210401180447699.png" alt="C/S拓展性差"></p><ul><li>可靠性差，依赖于服务器</li></ul></li></ul><blockquote><p>通常，如果仅有一台服务器处理所有的请求，那么服务器系统将很快变得不堪重负，为此，配备大量主机的数据中心常被用于创建强大的虚拟的服务器，一个数据中心可以有数十万台服务器，它们需要供电和维护，同时服务提供商还需要支付不断出现的互联和带宽费用，以及发送和接收到达/来自数据中心的数据。</p></blockquote><ul><li>应用例子：Web、FTP、Telnet和电子邮件</li></ul><h4 id="1-2-P2P结构"><a href="#1-2-P2P结构" class="headerlink" title="1.2 P2P结构"></a>1.2 P2P结构</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165453140.png" alt="P2P"></p><ul><li><p>（几乎）无永远在线的服务器</p></li><li><p>任意端系统/节点之间可以直接通讯</p></li><li><p>每一节点既是客户端又是服务器</p><ul><li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li></ul><blockquote><p>比如在文件共享应用中，对等方可能通过向文件的原始拥有者发出请求而产生工作量，但是对等方也有可能通过为其他对等方传送文件而为原始拥有者分担压力。</p></blockquote></li><li><p>节点间接性接入网络且可能改变IP地址</p></li><li><p>优点：高度可拓展性</p></li><li><p>缺点：</p><ul><li>ISP友好。大多数住宅ISP受制于非对称带宽应用，也就是下载比上传要多得多。但是P2P视频和文件分发应用改变了从服务器到住宅ISP的上传流量，因而给ISP带来压力；</li><li>安全性。因为其高度的分布和开放式，P2P应用也可能给安全带来挑战；</li><li>激励。如何说服用户资源向应用提供带宽、存储和计算资源？这是一个问题；</li></ul></li><li><p>应用例子：目前，流量密集型应用都是P2P体系结构的。这些应用包括文件共享（例如BitTorrent）、协助下载（例如迅雷）、因特网电话（例如Skype）和IPTV(例如迅雷看看)。</p></li></ul><h4 id="1-3-混合结构"><a href="#1-3-混合结构" class="headerlink" title="1.3 混合结构"></a>1.3 混合结构</h4><ul><li><p>Napster</p><ul><li><p>文件传输使用P2P结构</p><ul><li>任意Peer节点之间</li></ul></li><li><p>文件的搜索采用C/S结构–集中式</p><ul><li>每个结点向中央服务器登记自己的资源信息</li><li>每个结点向中央服务器提交查询请求，查找相应资源</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210331234531220.png" alt="Napster"></p></li></ul></li><li><p>例：即时通信</p><ul><li>在线检测：集中<ul><li>当用户上线时，向中心服务器注册其IP地址</li><li>用户与中心服务器联系，以找到其在线好友的位置</li></ul></li><li>两个用户之间聊天：P2P</li></ul></li></ul><h3 id="2-网络应用的进程间通信"><a href="#2-网络应用的进程间通信" class="headerlink" title="2 网络应用的进程间通信"></a>2 网络应用的进程间通信</h3><p>在操作系统中，实际进行通信的是进程而不是应用程序。<br>当进程运行在同一个端系统上时，它们使用进程间通信机制相互通信；而进程间通信的规则是由端系统上的操作系统确定的。<br>当进程运行在不同的端系统上时，它们通过跨越计算机网络的报文相互通信；发送进程产生报文并且向网络中发送，接收进程接收报文并对此作出响应（不响应也是一种响应）。</p><h4 id="2-1-进程间通信基本概念"><a href="#2-1-进程间通信基本概念" class="headerlink" title="2.1 进程间通信基本概念"></a>2.1 进程间通信基本概念</h4><ul><li><p>网络应用的基础：进程间通信</p></li><li><p>进程：主机上运行的程序</p></li><li><p>同一主机上运行的进程之间如何通信？</p><ul><li>进程间通信控制（由操作系统提供）</li></ul></li><li><p>不同主机上运行的进程间如何通信？</p><ul><li><p>按照网络应用协议进行消息交换（例如报文交换）</p><ul><li>借助传输层提供的服务</li></ul></li><li><p>同时使用OS提供的通信服务</p></li></ul></li><li><p>客户机进程/服务器进程</p><ul><li>客户机进程：发起通信的进程</li><li>服务器进程：等待通信请求的进程</li></ul><blockquote><p> 在P2P架构的应用中也存在客户机进程、服务器进程这样进程关系。在某些P2P应用中，一个进程可能既是客户也是服务器，因为在一个文件共享应用中，一个进程的确既能请求文件也能发送文件。所以从进程所扮演的角色来区分是客户进程还是服务器进程不够精确，所以我们从发起通信的顺序来定义它们：<strong>在给定的一对进程之间，首先发起通信的进程被标记为客户进程，在会话开始时等待联系的进程被称为服务器进程。</strong></p></blockquote></li></ul><h4 id="2-2-分布式进程间通信实现机制"><a href="#2-2-分布式进程间通信实现机制" class="headerlink" title="2.2 分布式进程间通信实现机制"></a>2.2 分布式进程间通信实现机制</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410172627902.png" alt="分布式进程间通信"></p><ul><li><p>分布式进程间通信需要解决的问题：</p><ul><li><p>问题1：进程标示和寻址问题（服务用户） </p><ul><li>对进程进行编址：进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）<ul><li>主机：唯一的32位IP地址<ul><li>仅仅有IP地址不能够唯一标识一个进程：在一台端系统上有很多进程在运行</li></ul></li><li>端口号（Port Numbers）（16bit）：确定是哪一个进程</li><li>所采用的传输层协议：TCP or UDP<ul><li>常见端口号例子：<ul><li>HTTP：TCP 80</li><li>Mail：TCP 25</li><li>FTP：TCP 2</li></ul></li></ul></li></ul></li><li>一个进程：用IP+port标示 端节点(end-point)</li><li>本质上，一对主机进程之间的通信由2个端结点构成</li></ul></li><li><p>问题2：传输层-应用层提供服务是如何（服务） </p><ul><li>传输层提供的服务-应用层与传输层层间接口必须要传递的信息：<ul><li>要传输的报文（对本层来说：SDU）</li><li>谁传的：对方的应用进程的标示：IP+TCP（UDP）端口号</li><li>传给谁：对方的应用进程的标示：对方的IP+TCP（UDP）端口号</li></ul></li><li>传输层实体（TCP或者UDP实体）根据应用层传输的信息进行TCP报文段（或者UDP报文段）的封装<ul><li>源端口号，目标端口号等封装为报文段头部，数据等封装到报文段负载</li><li>并将IP地址（源IP，目标IP）往下交给IP实体，用于封装IP数据报</li></ul></li></ul><p>​    如果每次两个主机的两个特定应用程序一段时间内多次进行信息传递或者进行信息传递比较频繁，每次传递信息都需要传递自己的和对方的IP+端口号，都携带如此多信息，太繁琐易错，不便于管理。</p><p>​    所以在应用层和传输层之间引入了Socket，用一个本地代号来标识通信的双方（TCP）或者单方（UDP）。就像是OS打开文件返回的句柄一样，对句柄的操作，就是对文件的操作，而不用再使用这个文件的目录名、文件名。</p><ul><li><p><strong>TCP socket：</strong></p><p>TCP服务，两个进程之间的通信需要通信之前就建立连接<font color="#A9A9A9">(两个进程通信会持续一端时间，通信关系稳定)</font>。可以用一个整数即Socket（类似句柄）来在本地对两个应用实体之间的通信关系进行标示。这样两个应用实体之间通信时，穿过层间接口的信息就只需要包含所需传递的消息数据。</p><p>对于使用面向连接服务（TCP）的应用而言，TCP socket是4元组的一个具有<strong>本地意义</strong><font color="#A9A9A9">(只有本地的应用层和传输层知道)</font>的标示。4元组：源IP，源端口，目标IP，目标端口</p><blockquote><p>TCP socket唯一的指定了一个会话（两个进程之间的会话关系）</p><p>应用使用这个标示与远程的应用进程进行通信，不必在每个报文的发送都指定这4元组。</p><p>简单，便于管理；同时减少穿过层间的数据</p></blockquote></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411094526831.png" alt="TCP socket"></p><ul><li><strong>UDP socket：</strong></li></ul><p>UDP服务，两个进程之间的通信之前无需建立连接<font color="#A9A9A9">（每个报文都是独立传输的，前后报文可能给不同的分布式进程）</font>。因此只能用一个整数表示本应用实体的标示。</p><p>UDP socket是2元组（源IP，源端口）的一个具有本地意义的标示。UDP套接字指定了应用所在的一个端结点（end-point）。</p><p>在发送数据报时，采用创建好的本地套接字（标示ID），就不必再发送每个报文中自己的ip和port。但是传输报文时，必须提供目的IP和目的端口号。接受报文的时候，传输层同样需要上传对方的IP和端口号。</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411100319390.png" alt="UDP socket"></p><ul><li><p>套接字（Socket）</p><ul><li>进程向套接字发送报文或者从套接字接受报文</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411100617644.png" alt="套接字"></p></li><li><p>传输层-应用层提供服务的：</p><p>位置：层间界面的SAP （TCP/IP ：socket） </p><p>形式：应用程序接口API （TCP/IP ：socket API）</p></li></ul></li><li><p>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）</p><ul><li><p>定义应用层协议，协议定义了运行在不同端系统上的应用进程如何相互交换报文</p><ul><li>交换报文类型：请求和应答报文</li><li>各种报文类型的语法：报文中的各字段及其描述</li><li>字段的语义：即字段取值的含义</li><li>进程何时、如何发送报文及对报文进行响应的规则</li></ul><blockquote><p>应用协议仅是应用的一个组成部分。例如：web应用包含了HTTP协议，web客户端，web服务器，HTML等</p></blockquote><blockquote><p>实体：仅仅和网络交互有关的、遵守协议的且是运行中的软件模块和硬件模块被称为实体。</p></blockquote><blockquote><p>公开协议：</p><p>​    由RFC文档定义</p><p>​    允许互操作</p><p>​    如HTTP，SMTP</p><p>专用（私有）协议：</p><p>​    协议不公开，如：Skype</p></blockquote></li><li><p>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等；</p><ul><li>传输基础设施向进程提供API<ul><li>传输协议的选择</li><li>参数的设置<h3 id="3-Internet传输层服务模型"><a href="#3-Internet传输层服务模型" class="headerlink" title="3 Internet传输层服务模型"></a>3 Internet传输层服务模型</h3></li></ul></li></ul></li></ul></li></ul></li><li><p>问题4：应用需要传输层提供什么样的服务？如何描述传输层的服务？</p><h4 id="3-1-描述传输层指标"><a href="#3-1-描述传输层指标" class="headerlink" title="3.1 描述传输层指标"></a>3.1 描述传输层指标</h4><ul><li>数据丢失率<ul><li>有些应用（如音频）能容忍一定比例以下的数据丢失</li><li>有些应用则要求100%的可靠数据传输（如文件）</li></ul></li><li>延迟<ul><li>一些应用出于有效性的考虑，对数据传输有严格的时间限制<ul><li>Internet电话、交互式游戏</li></ul></li></ul></li><li>吞吐<ul><li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li></ul></li><li>一些应用能充分利用可供使用的吞吐（弹性应用）</li><li>安全性</li><li>机密性   完整性   可认证性（鉴别）</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102836028.png" alt="常见应用对传输服务的要求"></p><h4 id="3-2-Internet传输层提供什么样的服务？"><a href="#3-2-Internet传输层提供什么样的服务？" class="headerlink" title="3.2 Internet传输层提供什么样的服务？"></a>3.2 Internet传输层提供什么样的服务？</h4><ul><li>TCP服务：<ul><li>可靠的传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐保证和安全保证</li><li>面向连接：要求通信前在客户端进程和服务器进程之间建立连接。（仅在端系统实现连接，而不对网络核心提供服务和维护）</li></ul></li><li>UDP服务<ul><li>不可靠数据传输</li><li><strong>不</strong>提供的服务：可靠，流量控制，拥塞控制，时间，带宽保障，建立连接</li><li>为什么要有UDP？（UDP存在的必要性）<ul><li>能够区分不同的进程，而IP服务不能</li><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li><li>无需建立连接，省去了建立连接时间，适合事务性的应用</li><li>不做可靠性的工作，例如检错重发，适合那些对实时 性要求比较高而对正确性要求不高的应用<ul><li> 因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发等）</li></ul></li><li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据 <ul><li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li></ul></li></ul></li></ul><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411103950494.png" alt="Internet应用及其应用层协议和传输协议"></li><li>安全TCP<blockquote><p>TCP和UDP都没有加密，明文通过互联网传输信息，甚至密码，安全性很低</p></blockquote><ul><li>SSL<pre><code>在TCP之上实现，提供加密的TCP连接。保证私密性。数据完整性以及端到端的鉴别。SSL在应用层中：应用采用SSL库形式与应用一起运行，然后SSL库使用TCP通信SSL socket API：应用通过API将明文交给socket，SSL将其加密后在互联网传输</code></pre><blockquote><p>例如https，HTTP协议运行在SSL之上，SSL运行在TCP协议之上，实现了web应用的安全可靠传输。</p></blockquote></li></ul><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411132650541.png" alt="进程、SSL与TCP关系"></li></ul></li></ul><h3 id="4-特定网络应用以及协议"><a href="#4-特定网络应用以及协议" class="headerlink" title="4 特定网络应用以及协议"></a>4 特定网络应用以及协议</h3><h4 id="4-1-Web与HTTP"><a href="#4-1-Web与HTTP" class="headerlink" title="4.1 Web与HTTP"></a>4.1 Web与HTTP</h4><ul><li><p>一些术语：</p><ul><li>web页：由一些对象组成</li></ul><blockquote><p>web页含有一个基本的HTML文件，该基本HTML文件本身就是一个对象，其中还包含其他对象的引用（以链接URL的形式）</p></blockquote><ul><li><p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p></li><li><p>通过URL对每个对象进行引用</p><ul><li><p>每个对象都有唯一的URL进行标识</p></li><li><p>访问协议：用户名、口令字、端口等</p></li><li><p>URL格式：<img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411112003845.png" alt="URL格式"></p><ul><li><p>协议名：以什么协议来访问对象（HTTP/FTP等）</p></li><li><p>用户:口令：访问对象用什么用户:口令访问</p><blockquote><p>有的网站支持匿名访问，无需提供用户:口令</p></blockquote></li><li><p>端口：如果未指定端口，会采用协议的默认端口号（如HTTP的默认端口80）</p></li></ul></li></ul></li></ul></li></ul><h5 id="4-1-1-HTTP概况"><a href="#4-1-1-HTTP概况" class="headerlink" title="4.1.1 HTTP概况"></a>4.1.1 HTTP概况</h5><ul><li><p>HTTP ：超文本传输协议</p><ul><li>Web的应用层协议</li><li>客户/服务器模式<ul><li>客户：请求、接受和显示Web对象的浏览器</li><li>服务器：对请求进行响应，发送对象的Web服务器</li></ul></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411131620123.png" alt="HTTP协议"></p><ul><li><p>HTTP 1.0 ：RFC 1945</p><p>HTTP 1.1 ：RFC 2068</p></li><li><p>使用TCP</p><ol><li>客户发起一个与服务器的TCP连接（建立socket），端口号为80</li><li>服务器接受客户的TCP连接</li><li>在浏览器（HTTP客户端）与Web服务器（HTTP服务器server）交换HTTP报文（应用层协议报文）</li><li>TCP连接关闭</li></ol><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411134148359.png" alt="HTTP建立连接示意图"></p></li><li><p>HTTP是无状态的</p><ul><li>服务器并不维护关于客户的任何信息，即交换过HTTP报文以后就断开TCP连接，不会存储客户信息，客户之后对报文更改与服务器无关</li><li>优点：简单；无状态的服务器能够支持更多的客户端</li></ul><blockquote><p>维护状态的协议很复杂！</p><ul><li>必须维护历史信息（状态）</li><li>如果服务器/客户端死机，它们的状态信息可能不一致，而必须维护成信息一致的</li></ul></blockquote></li></ul></li></ul><h5 id="4-1-2-HTTP连接"><a href="#4-1-2-HTTP连接" class="headerlink" title="4.1.2 HTTP连接"></a>4.1.2 HTTP连接</h5><ul><li><p>非持久HTTP</p><ul><li>每个TCP连接在服务器最多发送一个对象后就会关闭，也就是每个TCP只传送一个请求报文和响应报文</li><li>下载多个对象需要多个TCP连接</li><li>HTTP/1.0使用非持久连接</li></ul><p>假设用户输入URL:<a href="http://www.someschool.edu/someDept/home.index">www.someSchool.edu/someDept/home.index</a>  (假设这个web中包含文本和10个jpeg图像的引用)</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411140316400.png" alt="非持久HTTP"></p><ul><li><p>响应时间模型</p><ul><li>往返时间RTT（round-trip-time）</li></ul><p>一个小的分组从客户端到服务器，再回到客户端的时间（RTT包括分组的传播时延、排队时延、处理时延（因为是短分组，所以其传输时延可不计））</p><ul><li>响应时间：<ul><li>一个RTT用来发起TCP连接</li><li>一个RTT用来HTTP请求并等待HTTP响应</li><li>文件传输时间</li><li>共2RTT+传输时间</li></ul></li></ul></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411140846744.png" alt="响应时间模型"></p><ul><li>非持久HTTP的缺点：<ul><li>每个对象传输要2个RTT+传输时间</li><li>操作系统必须为每个TCP连接分配资源</li><li>但浏览器通常打开并行TCP连接，以获取引用对象</li></ul></li></ul></li><li><p>持久HTTP</p><ul><li>服务器在发送响应后，仍保持TCP连接；在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li><li>多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</li><li>HTTP/1.1默认使用持久连接</li><li>持久HTTP分为非流水方式的持久HTTP和流水方式的持久HTTP<ul><li>非流水方式（no-pipeline）的持久HTTP<ul><li>客户端只能在收到前一个响应后才能发出新的请求</li><li>每个引用对象花费一个RTT</li></ul></li><li>流水方式（pipeline）的持久HTTP、<ul><li>HTTP/1.1的默认方式</li><li>客户端遇到一个引用对象就立即产生一个请求</li><li>所以引用（小）对象只花费一个RTT是可能的</li></ul></li></ul></li></ul></li></ul><h5 id="4-1-3-HTTP报文格式：请求报文和响应报文"><a href="#4-1-3-HTTP报文格式：请求报文和响应报文" class="headerlink" title="4.1.3 HTTP报文格式：请求报文和响应报文"></a>4.1.3 HTTP报文格式：请求报文和响应报文</h5><ul><li><p>两种类型的HTTP报文：请求、响应</p></li><li><p>HTTP请求报文：</p><ul><li><p>ASCII    -具有可读性</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411143216745.png" alt="HTTP请求报文"></p><ul><li><p>一个请求报文具有至少一行的内容。请求报文的第一行称为请求行，其后继的各行被称为首部行。</p></li><li><p>请求行包含三个内容：方法字段、URL字段、HTTP版本；其中方法字段可为：GET、POST、PUT、DELETE、HEAD等。URL字段里可以传递请求对象的标志。</p></li><li><p>首部行包含是否在发送完响应报文后关闭TCP连接的Connection、请求的主机地址（该头部信息被Web高速缓存所要求）Host、客户端用户代理（浏览器）版本User-agent、可接受的语言Accept-language等头部信息；</p></li><li><p>在首部行之后一个空行，之后便是请求的“实体体”。</p><blockquote><p>该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等。</p><p>值得注意的是，表单也不一定必须使用POST方法。</p><ul><li>方法类型：</li></ul><p>HTTP/1.0 : GET、POST、HEAD</p><p>HTTP/1.1 : GET、POST、HEAD、PUT、DELETE</p><p>get，实体主体为空，上载内容会显示在URL的参数中。服务器将会用一个HTTP响应报文进行响应，报文中包含请求的对象。</p><p>Head类似于get方法，服务器将会用一个HTTP报文进行响应，但是不返回请求对象，经常用作调试跟踪。</p><p>put方法允许用户上传对象到URL指定的Web服务器上指定的路径。</p><p>Delete方法允许用户或应用程序删除URL指定的Web服务器上的对象。</p></blockquote></li></ul></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411144156506.png" alt="请求报文格式"></p><ul><li>HTTP请求报文也可向服务器提交内容，提交表单输入有如下两种方式：<ul><li>Post方式<ul><li>网页通常包括表单输入</li><li>提交的内容包含在实体体（entity body）中，然后被提交到服务器</li></ul></li><li>URL方式<ul><li>方法：GET</li><li>表单输入通过请求行的URL字段上载</li><li>例如：<a href="http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3%E9%80%9A%E8%BF%87URL%E4%B8%AD%E7%9A%84">http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3通过URL中的</a> 参数：wd，cl 参数值：XX+YY+zzz，3 形式信息</li></ul></li></ul></li></ul></li><li><p>HTTP响应报文</p><ul><li><p>ASCII    -具有可读性</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411145603153.png" alt="HTTP响应报文"></p><ul><li><p>响应报文总体上也分三个部分，第一部分是状态行，包含HTTP版本、状态以及状态信息等内容；第二部分是首部行，包含发送日期、服务器类型、上一次修改请求资源的时间、内容的长度和内容的类型等内容。第三部分是实体主体。实体主体包含请求对象本身。</p></li><li><p>首部行中的内容的长度是用于描述HTTP消息实体的传输长度，为了让应用层区分报文的边界</p><blockquote><p>因为TCP向上层应用层传递的是字节流，是不区分边界的，因此应用层要通过Content-Length来维护报文的界限</p></blockquote></li><li><p>首部行的Date是从文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。</p></li><li><p>HTTP响应状态码：位于服务器→客户端的响应报文中的首行</p></li></ul><blockquote><p>一些状态码的例子：</p><p>200 OK </p><p>&emsp;请求成功，请求对象包含在响应报文的后续部分 </p><p>301 Moved Permanently </p><p>&emsp;请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定</p><p>&emsp;客户端软件自动用新的URL去获取对象 </p><p>400 Bad Request </p><p>&emsp;一个通用的差错代码，表示该请求不能被服务器解读 </p><p>404 Not Found</p><p>&emsp;请求的文档在该服务上没有找到 </p><p>505 HTTP Version Not Supported</p></blockquote></li></ul></li></ul><h5 id="4-1-4-用户与服务器的交互：Cookie"><a href="#4-1-4-用户与服务器的交互：Cookie" class="headerlink" title="4.1.4 用户与服务器的交互：Cookie"></a>4.1.4 用户与服务器的交互：Cookie</h5><ul><li><p>HTTP是无状态协议，但是Web站点为了识别用户身份或者限制用户访问的时间或者将用户访问的内容同用户身份相关联，Web站点可以使用Cookie技术实现用户信息存储。</p></li><li><p>Cookie技术包含4个组成部分</p><ol><li>HTTP响应报文里增加一个关于Cookie的首部行；</li><li>HTTP请求报文里增加一个关于Cookie的首部行；</li><li>用户端系统中保留一个Cookie文件，由用户的浏览器维护和管理；</li><li>在Web站点后端数据库建立Cookie和用户身份的关联；</li></ol><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411161744290.png" alt="Cookies:维护状态"></p><blockquote><p>用户首次访问web服务器时，HTTP请求报文中无Cookie，在访问时，服务器会为用户建立Cookie，然后响应报文中首部行会有Cookie标示内容，用户收到响应报文后，用户浏览器会将cookie保存在本地cookies文件中，然后之后用户再次HTTP请求报文都会携带有cookie。</p></blockquote></li><li><p>Cookies能带来功能：</p><ul><li>用户验证</li><li>购物车</li><li>推荐</li><li>用户状态（Web e-mail）等</li></ul></li><li><p>如何维护状态：</p><ul><li>协议端节点：在多个事物上，发送端和接收端维持状态</li><li>cookies：HTTP报文携带状态信息</li></ul></li><li><p>Cookies的隐私泄露问题：</p><ul><li>Cookies允许站点知道许多关于用户的信息，站点可能将它知道的东西卖给第三方</li><li>使用重定向和cookie的搜索引擎还能知道用户更多的信息<ul><li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li></ul></li><li>广告公司从站点获得信息</li></ul></li></ul><h5 id="4-1-5-Web缓存（代理服务器）"><a href="#4-1-5-Web缓存（代理服务器）" class="headerlink" title="4.1.5 Web缓存（代理服务器）"></a>4.1.5 Web缓存（代理服务器）</h5><p>Web缓存器也被称为代理服务器，它代表初始web服务器来满足HTTP请求。它具有自己的存储空间，并在存储空间里保持有最近请求过的对象的副本；可以通过配置浏览器，将所有指向初始服务器的请求首先指向代理服务器。</p><p>当代理服务器收到一个HTTP请求后，它将检查本地是否缓存过该对象，如果缓存过该对象，将检查是否过期，如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p><ul><li>目标：不访问原始服务器，就满足客户的请求</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163153908.png" alt="代理服务器示意图"></p><ul><li><p>Web缓存既是客户端又是服务器</p></li><li><p>通常缓存是由ISP安装（大学、公司、居民区ISP）</p></li><li><p>Web缓存优点：</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internet接入链路上的流量，减少原始服务器负担</li><li>互联网大量使用了缓存，可以使较弱的ICP也能够有效提供内容</li></ul></li><li><p>缓存示例：</p></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163746751.png" alt="正常情况"></p><blockquote><p>接入链路流量强度接近于1，所以排队延迟（d<sub>queue</sub> = (I/(1-I))*(L/R)）将会很大，用户访问的时间因此而很大。</p></blockquote><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163945732.png" alt="更快的接入链路"></p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163959897.png" alt="安装本地缓存1"></p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411164018449.png" alt="安装本地缓存2"></p><h5 id="4-1-6-条件GET方法"><a href="#4-1-6-条件GET方法" class="headerlink" title="4.1.6 条件GET方法"></a>4.1.6 条件GET方法</h5><p>高速缓存器的使用，带来很多好处，但是有一个问题就是代理服务器对缓存对象的管理：如何确保所请求的对象是最新的？</p><p>其实HTTP提供了一种机制，允许缓存器证实其使用的对象是最新的，这种机制就是条件GET方法。</p><p>使用条件GET方法只需在使用GET方法的时候，增加一个If-Modified-Since首部行，其对应的内容是一个时间，如果所请求的资源在指定日期后(与Last-Modified比较)被修改了，那么服务器将返回新的对象，否则服务器将返回一个包含空实体主体的报文。这样代理服务器就可以确认缓存是否过期了。</p><ul><li>目标：即时更新缓存中的对象拷贝。<ul><li>如果缓存拷贝需要更新，返回 HTTP/1.0  200  OK，实体主体中包含对象</li><li>如果缓存拷贝不需要更新，则返回HTTP/1.0  304  Not Modified，且实体主体中不包含对象</li></ul></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411165916546.png" alt="条件Get方法"></p><h4 id="4-2-FTP：文件传输协议"><a href="#4-2-FTP：文件传输协议" class="headerlink" title="4.2 FTP：文件传输协议"></a>4.2 FTP：文件传输协议</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411194534840.png" alt="FTP"></p><ul><li>FTP应用包括FTP用户接口、FTP客户端、本地文件系统、界面等。而FTP服务器有服务器的文件系统，守候在21号端口，等待连接。</li><li>FTP协议中，用户通过FTP客户端可以向远程主机上传输文件或从远程主机接受文件</li><li>客户/服务器模式<ul><li>客户端：发起传输的一方</li><li>服务器：远程主机</li></ul></li><li>FTP：RFC 959</li><li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议<ul><li>客户端通过控制连接获得身份确认</li><li>客户端通过控制连接发送命令浏览远程目录</li></ul></li><li>但是，当服务器收到一个文件传输命令时，服务器打开第二个TCP数据连接（服务器20号端口到客户端的数据连接）来传输文件。</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411202825985.png" alt="FTP端口连接"></p><ul><li><p>控制连接：带外（out of band）传送</p></li><li><p>FTP带内是传输数据的（20号端口），带外是传送控制信号（21号端口）</p></li><li><p>FTP是有状态的协议</p><ul><li>FTP服务器维护用户的状态信息：当前路径、用户账户与控制连接对应</li></ul></li><li><p>FTP命令、响应都是ASCII文本形式</p><ul><li>FTP命令：在控制连接上以ASCII文本方式传送</li></ul><blockquote><p>USER username</p><p>PASS password </p><p>LIST：请服务器返回远程主机当前目录的文件列表 </p><p>RETR filename：从远程主机的当前目录检索文件 (gets) </p><p>STOR filename：向远程主机的当前目录存放文件(puts)</p></blockquote><blockquote><p>注：</p><p>上载：客户端向服务器发数据</p><p>下载：服务器向客户端发数据</p></blockquote><ul><li>返回码：</li></ul><blockquote><p>状态码和状态信息（同HTTP）</p><p>331 Username OK,  password required </p><p>125 data connection  already open;  transfer starting </p><p>425 Can’t open data  connection </p><p>452 Error writing  file</p></blockquote></li></ul><h4 id="4-3-EMail"><a href="#4-3-EMail" class="headerlink" title="4.3 EMail"></a>4.3 EMail</h4><ul><li><p>email的3个主要组成部分：</p><ul><li><p>用户代理</p><ul><li>又名“邮件阅读器”</li><li>撰写、编辑和阅读邮件，如Outlook、Foxmail等</li><li>输出和输入邮件保存在服务器上</li></ul></li><li><p>邮件服务器</p><ul><li>邮件服务器中输出报文队列保存并依此发送待发送邮件报文</li><li>邮箱中管理和维护发送给用户的邮件</li><li>邮件服务器之间的SMTP协议：发送Email报文<ul><li>客户端：发送方邮件服务器</li><li>服务器：接受方邮件服务器</li></ul></li></ul><blockquote><p>一封邮件发送过程：<br>用户通过用户代理撰写邮件，然后通过用户代理经SMTP协议发送邮件到邮件服务器中的输出邮件队列中。该服务器作为发送方邮件服务器，通过SMTP协议找到并将邮件接收方邮件服务器。接受方服务器将接受到的邮件放到服务器中相应用户邮箱中，目标用户再经用户代理通过拉取邮件的协议（POP3等）拉取邮箱中自己收到的邮件。</p></blockquote><blockquote><p>用户代理向服务器发邮件，用户是client，邮件服务器是sever。</p><p>发送方邮件服务器向接收方邮件服务器发邮件，发送方邮件服务器是client，接收方邮件服务器是sever。</p></blockquote><blockquote><p>发送方的邮件服务器必须能处理接收方服务器的故障，如果发送方的服务器不能将邮件交付给接收方的服务器，发送方将在一个报文队列中保持该邮件并之后再尝试发送报文，如果一直失败，服务器就会删除该邮件，并以邮件方式通知发送用户。</p></blockquote></li><li><p>简单邮件传输协议：SMTP</p><ul><li><p>SMTP使用TCP在客户端和服务器之间传送报文，端口号为25</p></li><li><p>SMTP为直接传输：从发送方服务器到接收方服务器，邮件并不在中间的某个服务器停留</p></li><li><p>传输的3个阶段：</p><ul><li>握手</li><li>持续传输报文</li><li>关闭</li></ul><blockquote><p>SMTP是持续连接：如果发送邮件服务器有多个邮件，它可以通过同一TCP连接连续发送这些邮件。</p></blockquote><blockquote><p>所以邮件有时是先存储在发送队列的，等到多个邮件一起传递，以此来减少服务器耗能等。</p></blockquote></li><li><p>命令/响应交互</p></li><li><p>命令：ASCII文本</p></li></ul></li><li><p>响应：ASCII   状态码和状态信息</p></li><li><p>SMTP要求报文（首部和主体）必须为7位ASCII码</p><blockquote><p>命令、响应和邮件本身的内容的组成字符必须是在7位ASCII码字符集描述的范围之内的。超过7位ASCII码字符集表示的范围的数据不能通过SMTP传输。</p></blockquote></li></ul><blockquote><p>这将限制SMTP的数据传输，即在SMTP传输邮件之前，需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应ASCII码邮件解码还原成多媒体数据。HTTP传输不需要将多媒体数据编码成ASCII码。</p></blockquote><ul><li>SMTP服务器使用CRLF.CRLF决定报文的尾部<img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411205241273.png" alt="EMail原理"></li><li>SMTP与HTTP比较：<ul><li>HTTP：拉（pull） SMTP：推（push）</li><li>两者都是ASCII形式的命令、响应交互、状态码</li></ul><blockquote><p>但是传输的内容，HTTP可以不一定是用ASCII码，而SMTP只能用ASCII码字符。</p></blockquote><ul><li>HTTP：每个对象封装在各自的响应报文中，一个响应报文只能有一个对象</li><li>SMTP：多个对象包含在一个报文中</li></ul><blockquote><p>解释：</p><p>例如一个web页面对象，其中有多个对象（图片等）的引用，HTTP的一个响应报文中只有这一个web页面对象的数据，其他对象需要通过引用再去经过各自的响应报文传递过来。</p><p>而如果是一个邮件，其中有图片、音频等多个对象，SMTP将会将这个邮件的所有内容包含到同一个报文中，一次传递过来。</p></blockquote><ul><li><p>SMTP：交换Email报文的协议     </p></li><li><p>RFC 822：邮件内容文本报文的标准：</p><ul><li><p>首部行：包含</p><ul><li>To:           发送给谁<ul><li>From:      来自谁</li></ul></li><li>Subject:   主题</li><li>还有 cc  （抄送）等</li></ul></li><li><p>主体</p><ul><li>报文，只能是ASCII码字符<blockquote><p>这个是邮件报文内容的格式，与SMTP命令格式不同</p></blockquote></li></ul></li></ul></li><li><p>多媒体拓展的报文格式</p><ul><li><p>MIME：多媒体邮件扩展（multimedia mail extension）   RFC  2045，2056</p><blockquote><p>用来拓展SMTP传输内容，使得SMTP能够传输ASCII码字符之外的字符。</p></blockquote><ul><li>在报文首部用额外的行声明MIME内容类型</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210412145320300.png" alt="MIME"></p><blockquote><p>将不在ASCII码值的内容用规定的格式（如base64）编码为较长的7位ASCII码值，然后通过SMTP传送。接受端受到该数据后再经过解码，获得原来的数据，以此实现拓展ASCII码传输内容。</p></blockquote></li></ul></li></ul></li></ul></li><li><p>EMail协议</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210412145541524.png" alt="Email协议"></p><ul><li><p>发送的协议：简单邮件传输协议：SMTP</p><blockquote><p>用户代理到发送方邮件服务器</p><p>发送方邮件服务器传送到接受方的邮件服务器</p></blockquote></li><li><p>拉取的协议：POP3，IMAP，HTTP   </p><blockquote><p>用于邮件访问</p></blockquote></li></ul></li><li><p>邮件访问协议</p><ul><li>邮件访问协议：从服务器访问邮件<ul><li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul><li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li></ul><blockquote><p>POP3是一个非常简单的协议，因为简单，所以功能有限；POP3使用端口110来建立TCP连接（SMTP使用端口25）；POP3按照三个阶段进行工作：特许、事务处理和更新；在特许阶段，用户代理发送密码和用户名，进行身份鉴别；第二阶段，用户代理取回报文，同时还可以做删除、取消删除等标记或者统计邮件信息；第三个阶段是在用户退出后，POP3结束会话，删除被标记的邮件。</p></blockquote></li><li>IMAP：Internet邮件访问协议（Internet Mail Access  Protocol）[RFC 1730] <ul><li><p>与POP3类似作用，但是多了更多特性 (更复杂) </p><blockquote><p>POP3协议无法为用户提供邮件分类管理的功能，虽然用户可以通过将邮件下载到本地，然后由用户代理程序做分类管理，但是处理的结果是无法同步到其他查看设备上的。为了解决这一问题，IMAP诞生了。IMAP是一个邮件访问协议，比POP3要复杂的多。</p><p>（远程）IMAP将每一份邮件和一个一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX相关联。收件人可以将邮件移到新创建的文件夹，阅读邮件，删除邮件等。IMAP允许用户在不同文件夹里移动邮件并且查询邮件。</p><p>值得注意的是，IMAP服务器维护了IMAP会话的用户状态信息（目录名、报文ID与目录名之间映射等状态信息），但是POP3并不在会话时维护状态信息。</p><p>IMAP协议还允许用户代理获取报文组件而不是报文整体。</p></blockquote></li><li><p>在服务器上处理存储的报文</p></li></ul></li><li>HTTP：Hotmail , Yahoo! Mail等 <ul><li>方便</li></ul><blockquote><p>这种方式主要是指，用户使用HTTP协议和邮件服务器通信。用户代理就是普通的浏览器，但是，邮件服务器之间还是使用SMTP协议的</p></blockquote></li></ul></li><li>POP3协议<ul><li><p>用户确认阶段 </p><ul><li>客户端可发出命令： <ul><li>user: 申明用户名</li><li>pass: 口令 </li></ul></li><li>服务器响应 <ul><li>+OK</li><li>-ERR </li></ul></li></ul></li><li><p>事物处理阶段, </p><ul><li>客户端可以发送以下命令： <ul><li><p>list: 报文号列表 </p></li><li><p>retr: 根据报文号检索报文 </p></li><li><p>dele: 删除 </p><blockquote><p>一个需要注意的是，POP3用户代理可以使用两种事务处理模式：一种是下载并删除，另一种是下载保留；POP3代理发出的命令和其工作模式相关；下载并删除的方法存在的问题是，如果用户在一台设备上查看了邮件（下载了邮件）后，邮件将被删除，那么在其他设备上将无法查看邮件；这给用户带来一定的不便。使用下载保存方式，则用户下载邮件后，邮件还在服务器上。</p></blockquote></li><li><p>quit</p></li></ul></li></ul></li><li><p>POP3在会话中是无状态的</p><blockquote><p>POP3只是维护用户谁登录了，需要获取哪些邮件，而不会维护用户对邮件目录等操作的状态。</p></blockquote><blockquote><p>在用户代理与邮箱服务器之间的POP3会话期间，该POP3服务器保留了一些状态信息，特别是标记了哪些用户报文被标记为删除了。但是POP3服务器并不在POP3会话过程中去携带和实现状态信息，大大简化了POP3的服务。</p></blockquote></li></ul></li></ul></li></ul><h4 id="4-4-DNS（Domain-Name-System）"><a href="#4-4-DNS（Domain-Name-System）" class="headerlink" title="4.4 DNS（Domain Name System）"></a>4.4 DNS（Domain Name System）</h4><ul><li><p>提供给应用使用的应用</p></li><li><p>DNS的必要性 </p><ul><li><p>IP地址标识某一时刻网络中唯一的主机、路由器，但IP地址不好记忆，不便人类使用(没有意义)，人类一般倾向于使用一些有意义的字符串来标识 Internet上的设备。 </p><blockquote><p>例如：<a href="mailto:&#113;&#122;&#x68;&#101;&#x6e;&#x67;&#x40;&#117;&#115;&#116;&#99;&#x2e;&#x65;&#100;&#117;&#x2e;&#99;&#x6e;">&#113;&#122;&#x68;&#101;&#x6e;&#x67;&#x40;&#117;&#115;&#116;&#99;&#x2e;&#x65;&#100;&#117;&#x2e;&#99;&#x6e;</a> 所在的邮件服务器<br> <a href="http://www.ustc.edu.cn/">www.ustc.edu.cn</a> 所在的web服务器 </p></blockquote></li><li><p>存在着“字符串”—IP地址的转换的必要性</p></li><li><p>DNS提供的主要服务：人类用户提供要访问机器的“字符串”名称，然后由DNS负责转换成为二进制的网络地址</p></li></ul><blockquote><p>DNS通常被其他应用层协议使用，比如：HTTP、SMTP和FTP等。这些协议在正式工作以前，首先利用DNS提供的服务，将主机名转换为IP地址，可以发现的是，DNS为用户带来方便的同时，也为网络应用带来额外的时延——查询DNS服务器的时延。</p></blockquote></li><li><p>DNS系统需要解决的问题 </p><ul><li><p>问题1：如何命名设备？</p><ul><li>用有意义的字符串：好记，便于人类使用</li><li>解决一个平面命名的重名问题：采用层次化命名方式</li></ul><blockquote><p>一个平面进行命名会出现问题：设备越来越多，不重复的命名越来越难实现</p></blockquote></li><li><p>问题2：如何完成名字到IP地址的转换？ </p><ul><li>一台设备集中解决域名到IP地址转换实际上难以实现，因为服务器负载有限，易出现错误。所以采用分布式的数据库维护和响应名字查询。</li></ul></li><li><p>问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作？</p></li></ul></li><li><p>DNS 的历史</p></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413165837322.png" alt="ARP ANET"></p><ul><li><p>DNS的主要思路</p><ul><li><p>分层的、基于域的命名机制</p></li><li><p>若干分层的DNS服务器组成的分布式数据库完成名字到IP地址的转换</p></li><li><p>运行在UDP之上端口号为53的应用服务</p><blockquote><p>采用UDP原因：DNS只是需要通过域名查询相应的IP地址，采用TCP需要耗费很长时间进行建立联系。</p></blockquote></li><li><p>DNS属于Internet的核心功能，但以端系统的应用层协议实现的</p><ul><li>Internet在网络边缘处理互联网的复杂功能</li></ul></li></ul></li><li><p>DNS主要目的：</p><ul><li><p>实现主机域名-IP地址的转换(name/IP translate) </p></li><li><p>其它目的 </p><ul><li>主机别名到规范名字的转换：Host aliasing </li></ul><blockquote><p>应用服务（例如某一域名<a href="http://www.xxx.com）往往是大量的服务器进行提供维护，对于每一台服务器都有一个规范的主机名来标识，例如：某一地点的某一机房的某一机柜的某一刀片服务器+该域名，为了便于使用，这大量的服务器都被称为www.xxx.com，这个就是主机别名。">www.xxx.com）往往是大量的服务器进行提供维护，对于每一台服务器都有一个规范的主机名来标识，例如：某一地点的某一机房的某一机柜的某一刀片服务器+该域名，为了便于使用，这大量的服务器都被称为www.xxx.com，这个就是主机别名。</a></p><p>规范主机名为了便于管理，而主机别名是为了便于访问。</p></blockquote><blockquote><p>所以DNS往往是实现：主机别名转换为规范主机名再到IP地址的转换</p></blockquote><ul><li>邮件服务器别名到邮件服务器的正规名字的转换：Mail server  aliasing </li></ul><blockquote><p>DNS同样也提供邮件服务器主机名和别名的转换服务，实际上，公司的邮件服务器和Web服务器（如<a href="http://www.xxx.com)可以使用相同的主机别名,就可以使用该公司域名来作为邮件服务器地址(www.xxx.com);mx记录允许一个公司的邮件服务器和web服务器使用相同的主机名./">www.xxx.com）可以使用相同的主机别名，就可以使用该公司域名来作为邮件服务器地址（www.xxx.com）；MX记录允许一个公司的邮件服务器和Web服务器使用相同的主机名。</a></p></blockquote><ul><li>负载均衡：Load Distributio</li></ul><blockquote><p>应用服务（例如某一域名<a href="http://www.xxx.com)往往是大量的服务器进行提供维护,这些服务器都使用同一个主机别名(www.xxx.com),然后该域名收到请求以后,dns将会按照一定原则和依据将任务分配给这些服务器中的一台服务器来提供服务,从而达到负载均衡./">www.xxx.com）往往是大量的服务器进行提供维护，这些服务器都使用同一个主机别名（www.xxx.com），然后该域名收到请求以后，DNS将会按照一定原则和依据将任务分配给这些服务器中的一台服务器来提供服务，从而达到负载均衡。</a></p></blockquote></li></ul></li><li><p>问题1：DNS名字空间</p><ul><li><p>DNS域名结构</p><ul><li><p>一个层面命名设备会有很多重名</p></li><li><p>NDS采用层次树状结构的命名方法实现DNS域名命名</p></li><li><p>Internet 根被划为几百个顶级域(top lever domains) </p><ul><li><p>通用的(generic)</p><p> .com; .edu ; .gov ; .int ; .mil ; .net ; .org .firm ; .hsop ; .web ; .arts ; .rec ; </p></li><li><p>国家的(countries) </p></li></ul><p>.cn ; .us ; .nl ; .jp </p></li><li><p>每个(子)域下面可划分为若干子域(subdomains) </p></li><li><p>树叶是主机</p></li><li><p>根名字服务器有13个</p></li></ul><blockquote><p>如果只有一个，可能出现一个宕机，整个DNS不能使用</p></blockquote><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413183435963.png" alt="DNS根名字服务器"></p><ul><li>DNS域名结构</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413183541230.png" alt="DNS名字空间"></p><ul><li><p>域名(Domain Name)</p><ul><li><p>从本域往上，直到树根</p></li><li><p>中间使用“.”间隔不同的级别</p><blockquote><p>例如: ustc.edu.cn   auto.ustc.edu.cn        <a href="http://www.auto.ustc.edu.cn/">www.auto.ustc.edu.cn</a></p></blockquote></li><li><p>域的域名:可以用于表示一个域  </p><blockquote><p>从树枝往上找</p></blockquote></li><li><p>主机的域名:一个域上的一个主机</p><blockquote><p>从树叶往上找</p></blockquote></li></ul></li><li><p>域名的管理</p><ul><li>一个域管理其下的子域<ul><li>.jp被划分为ac.jp    co.jp</li><li>.cn被划分为edu.cn   com.cn</li></ul></li><li>创建一个新的域，必须征得它所属域的同意</li></ul></li><li><p>域与物理网络无关</p><ul><li>域遵从组织界限，而不是物理网络<ul><li>一个域的主机可以不在一个网络</li><li>一个网络的主机不一定在一个域</li></ul></li><li>域的划分是逻辑的，而不是物理的</li></ul></li></ul></li></ul></li><li><p>问题2：如何解析域名为IP地址问题-名字服务器(Name Server)</p><ul><li><p>只采用一个服务器作为名字服务器的问题</p><ul><li>可靠性问题：单点故障</li><li>扩展性问题：通信容量</li><li>维护问题：远距离的集中式数据库 </li></ul></li><li><p>所以采用分布式服务器来解决域名解析为IP地址的问题，大致来说，存在三种DNS服务器：根DNS服务器、顶级域DNS服务器和权威DNS服务器</p></li><li><p>顶级域(TLD)服务器：</p><ul><li>负责顶级域名（如com, org, net,  edu和gov）和国家级的顶级域名（如cn, uk, fr, ca,  jp ）<ul><li>Network solutions 公司维护com TLD服务器 </li><li>Educause公司维护edu TLD服务器</li></ul></li></ul></li><li><p>将名字空间划分为若干互不相交的区域(zone) </p><ul><li>区域的划分有区域管理者自己决定</li><li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li><li>名字服务器：<ul><li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record) ，组织机构的DNS服务器，提供组织机构服务器可以访问的主机和IP之间的映射</li><li>名字服务器允许被放置在区域之外，以保障可靠性</li></ul></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413185005911.png" alt="Zone"></p><ul><li><p>区域名字服务器通过维护资源记录来维护区域内各域名和主机之间的信息数据</p><ul><li><p>资源记录(resource records) </p><ul><li><p>作用：维护 域名-IP地址(其它)的映射关系</p></li><li><p>位置：Name Server的分布式数据库中 </p></li><li><p>RR格式: (domain_name, ttl, type,class,Value) </p><ul><li><p>Domain_name: 域名 </p></li><li><p>Ttl: time to live : 生存时间</p><blockquote><p>某一域名的RR在它的权威服务器中是无限大的，而在其他服务器中缓冲记录是有限的，一段时间后会将该域名RR删除。</p><p>缓冲目的是为了提高效率<br>删除缓存目的是为了维护一致性</p></blockquote></li><li><p>Class 类别 ：对于Internet，值为IN </p></li><li><p>Value 值：可以是数字，域名或ASCII串等，存的是域名对应的IP地址</p></li><li><p>Type 类别：资源记录的类型</p></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413195554207.png" alt="Type类型举例"></p></li></ul></li></ul></li></ul></li><li><p>DNS大致工作过程</p><ul><li>应用调用解析器（resolver）</li><li>解析器作为客户向Local Name Server发出查询报文（封装在UDP段中）</li><li>Name Server返回响应报文（name/ip）</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413211302361.png" alt="DNS大致工作过程"></p></li><li><p>本地名字服务器（Local Name Server）</p><ul><li>并不严格属于DNS服务器的层次结构<ul><li>一般是距离主机最近的名字服务器</li></ul></li><li>每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器<ul><li>也称为“默认名字服务器”</li></ul></li><li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器 <ul><li>起着代理的作用，将查询转发到层次结构中去解析主机名</li><li>名字解析过程：<ul><li>目标名字在Local Name Server中<ul><li><p>情况1：查询的名字在Local Name Server区域内部</p></li><li><p>情况2：Local Name Server中有对应主机的缓存(cashing)</p><blockquote><p>缓冲是为了效率，一段时间后会删除缓冲，是为了保持一致性</p></blockquote></li></ul></li><li>当与本地名字服务器不能解析名字时，联系根名字服务器顺着根-TLD 一直找到权威名字服务器<ul><li><p>递归查询</p><ul><li>名字解析负担都放在当前联络的名字服务器上</li><li>问题：根服务器的负担太重</li><li>解决： 迭代查询 （iterated  queries）</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413234354328.png" alt="递归查询"></p></li><li><p>迭代查询</p><p>主机cis.poly.edu 想知道主机 gaia.cs.umass.edu 的IP地址</p><ul><li>根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</li><li>最后由权威名字服务器给出解析结果</li><li>当前联络的服务器给出可以联系的服务器的名字“我不知道这个名字，但 可以向这个服务器请求”</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413234546250.png" alt="迭代查询"></p></li></ul></li></ul></li></ul></li></ul></li><li><p>DNS协议报文</p><ul><li><p>DNS协议的查询和响应报文的报文格式相同，靠标识位flags来判断查询/应答</p><ul><li><p>报文首部：</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413235044154.png" alt="DNS报文"></p><blockquote><p>ID是为了实现流水线并行查询DNS</p></blockquote><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413235107155.png" alt="DNS报文内容"></p></li></ul></li></ul></li><li><p>提高性能：缓存 </p><ul><li>一旦名字服务器学到了一个映射，就将该映射缓存起来 </li><li>根服务器通常都在本地服务器中缓存着 <ul><li>使得根服务器不用经常被访问 </li></ul></li><li>目的：提高效率 </li><li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</li><li>解决方案：TTL（默认2天）</li></ul><blockquote><p>TTL结束后，删除缓存的内容</p></blockquote></li></ul></li><li><p>问题3：维护问题：新增一个域怎么维护？</p><ul><li><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名 和 域名服务器的地址</p></li><li><p>在新增子域 的名字服务器上运行名字服务器，负责本域 的名字解析： 名字-&gt;IP地址 </p><blockquote><p>例子：在com域中建立一个“Network Utopia” </p><ul><li>到注册登记机构注册域名networkutopia.com <ul><li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字 和IP地址</li><li>登记机构在com TLD服务器中插入两条RR记录: (networkutopia.com, dns1.networkutopia.com, NS) (dns1.networkutopia.com, 212.212.212.1, A) </li></ul></li><li>在networkutopia.com的权威服务器中确保有<ul><li>用于Web服务器的<a href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a></li><li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li></ul></li></ul></blockquote></li></ul></li><li><p>攻击DNS，DNS总的来说比较健壮</p><ul><li><p>DDoS 攻击</p><ul><li><p>对根服务器进行流量轰炸攻击：发送大量ping </p><ul><li>没有成功 </li><li>原因１：根目录服务器配置了流量过滤器，防火墙 </li><li>原因２：Local DNS 服务器缓存了TLD服务器的IP地址,  因此无需查询根服务器</li></ul></li><li><p>向TLD服务器流量轰炸攻击 ：发送大量查询 </p><ul><li>可能更危险 </li><li>效果一般，大部分DNS缓存了TLD</li></ul><blockquote><p><font color="red">这里不是很明白，为什么缓存了顶级域名就不会访问根域名了？迭代、递归不都是先访问根域名服务器吗？然后才知道访问哪个顶级域名吗？本地域名服务器可以知道应该访问哪个顶级域名服务器吗？</font></p><p>先访问根域名服务器是为了获得顶级域名服务器的IP地址，本地域名服务器中有相应的缓存即对应IP地址，就可以直接去访问顶级域名，而不用再去访问根域名服务器。</p></blockquote></li></ul></li><li><p>重定向攻击</p><ul><li>中间人攻击 <ul><li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li></ul></li><li>DNS中毒<ul><li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li></ul></li><li>技术上较困难：分布式截获和伪造</li></ul></li><li><p>利用DNS基础设施进行DDoS</p><ul><li>伪造某个IP进行查询， 攻击这个目标IP</li><li>查询放大，响应报文比查询报文大 </li><li>效果有限</li></ul></li></ul></li></ul><h4 id="4-5-P2P应用"><a href="#4-5-P2P应用" class="headerlink" title="4.5 P2P应用"></a>4.5 P2P应用</h4><ul><li><p>纯P2P架构</p><ul><li>没有（或极少）一直运行的服务器</li><li>任意端系统都可以直接通信</li><li>利用peer的服务能力</li><li>Peer节点间歇上网，每次IP地址都有可能变化</li><li>例子：<ul><li>文件分发（BitTorrent）</li><li>流媒体（KanKan）</li><li>VoIP（Skype）</li></ul></li></ul></li><li><p>文件分发：C/S vs P2P</p><p>问题：从一台服务器分发文件（大小F）到N个peer需要多少时间？</p><blockquote><p>Peer节点上下载能力是有限的资源</p></blockquote><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414082756872.png" alt="文件分发"></p><ul><li><p>C/S模式的文件分发时间</p><ul><li><p>服务器传输： 都是由服务器发送给peer，服务器必须顺序 传输（上载）N个文件拷贝: </p><ul><li>发送一个copy: F/u<sub>s</sub></li><li>发送N个copy： NF/u<sub>s</sub> </li></ul></li><li><p>客户端: 每个客户端必须下载一个文件拷贝 </p><ul><li><p>d<sub>min</sub> = 客户端最小的下载速率 </p></li><li><p>下载带宽最小的客户端下载的时间：F/d<sub>min</sub></p><blockquote><p>下载带宽最小的客户端是所有客户端中下载所耗费时间最长的</p></blockquote></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414083126229.png" alt="C/S模型文件分发时间"></p><blockquote><p>客户端较少的时候，下载带宽最小的客户端下载时间是瓶颈；客户端较大时，服务器上载能力是瓶颈。</p></blockquote></li></ul></li><li><p>P2P模式文件分发时间</p><ul><li><p>服务器传输：最少需要上载一份拷贝</p><ul><li>发送一个拷贝的时间：F/u<sub>s</sub> </li></ul></li><li><p>客户端: 所有客户端最终都需要下载一个拷贝 </p><ul><li>最小下载带宽客户单耗时：F/d<sub>min</sub></li></ul></li><li><p>NF文件上载时间：所有客户端总体下载量为NF，而服务器和其他所有Peer节点的总的最大上载带宽是：<br>$$<br>u_s + \Sigma u_i<br>$$</p><blockquote><p>除了服务器可以上载，其他所有的peer节点都可以上载</p></blockquote><p>所以NF文件上载时间：<br>$$<br>\frac {NF}{u_s+\Sigma u_i}<br>$$</p></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414085223889.png" alt="P2P文件分发"></p><blockquote><p>每个Peer节点的加入，请求资源的节点在增加，同时服务能力也在增加</p></blockquote><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414085509474.png" alt="C/S  vs  P2P"></p></li></ul></li><li><p>P2P文件共享两大问题：</p><ul><li><p>如何定位所需资源</p></li><li><p>如何处理对等方的加入与离开</p></li><li><p>可能的方案：P2P系统的管理模式</p><ul><li><p>非结构化P2P</p><ul><li>Peer节点邻居之间有协作关系则有边，然后各个Peer和他们的协作关系构成了应用层逻辑上的网络Overlay（覆盖网）</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414091248820.png" alt="非结构化覆盖网"></p><blockquote><p>Peer节点之间构成的协作关系（即边）是随机的</p></blockquote><ul><li><p>非结构化的P2P可以分为：</p><ul><li><p>集中式目录</p><p>将每个Peer节点有什么资源和节点上下线等信息作为目录存储在一个服务器上，用户需要什么资源，然后向服务器请求，服务器告知哪个Peer有这个资源，然后用户再与该Peer节点建立联系下载文件，此时用户是客户端，而拥有资源的服Peer节点是服务器。下载完成后，该用户也成为拥有该资源的服务器。</p><blockquote><p>例：Alice在其笔记本电脑上运行P2P客户端程序，间歇性地连接到 Internet，每次从其 ISP得到新的IP地址，假设Alice请求“双截棍.MP3” ，应用程序显示其他有“ 双截棍.MP3” 拷贝的对等方。Alice选择其中一个对等方，如Bob。文件就会从Bob’s PC传送到 Alice的笔记本上：HTTP 。当Alice下载后，其他用户也可以从Alice处下载“ 双截棍.MP3”。</p><p>此外，Alice在下载Bob的内容时，他也可以同时作为其他人的服务器上载自己拥有的其他文件。</p></blockquote><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414114834512.png" alt="集中式目录"></p><blockquote><p>文件传输是分散的，但是目录定位内容是高度集中在目录服务器的</p></blockquote><ul><li>集中式目录中存在的问题：<ul><li>单点故障</li><li>性能瓶颈</li><li>侵犯版权</li></ul></li></ul></li><li><p>完全分布式</p><ul><li><p>目录查询、文件传输都采用P2P形式</p></li><li><p>例子：Gnutella</p><ul><li><p>全分布式，没有中心服务器</p><p>开放文件共享协议</p><p>许多Gnutella客户端实现了Gnutella协议</p><p>​    类似HTTP有许多的浏览器</p></li><li><p>覆盖网络：图 </p><p>如果X和Y之间有一个 TCP连接，则二者之间存在一条边</p><p>所有活动的对等方和边就是覆盖网络</p><p>边并不是物理链路，而是传输连接</p><p>给定一个对等方，通常所连接的节点少于10个</p></li><li><p>协议</p></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414203646040.png" alt="Gnutella协议"></p><blockquote><p>查询文件方式：洪泛（flooding），A向它的所有邻居B、C、D进行查询，然后B、C、D在向自己的所有邻居进行查询，一直向下延续</p></blockquote><ul><li>Gnutella的Peer节点的加入</li></ul><ol><li>新加入的对等方X的Gnutella客户端应用必须首先携带某些已经在覆盖网络中的其他对等方的IP地址：使用可用对等方列表</li></ol><blockquote><p>自己维持一张对等方列表（经常开机的对等方的IP） 联系维持列表的Gnutella站点 </p></blockquote><ol start="2"><li><p>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</p></li><li><p>X向Y发送一个Ping报文，Y向自己连接的节点转发该Ping报文</p></li><li><p>所有收到Ping报文的对等方以Pong报文响应X，回复自己的IP地址、共享文件的数量及总字节数等信息</p></li><li><p>X收到许多Pong报文，然后它能建立起与其他节点的TCP连接</p></li></ol><ul><li>Gnutella的Peer节点的离开</li></ul><p>该节点向邻居发送离开的报文，然后它的邻居会将该节点的信息删除，然后选择一个覆盖网络其他的节点补充为新的邻居，从而维持覆盖网络的服务能力</p></li></ul></li><li><p>混合式</p><ul><li>例子：KaZaA</li><li>每个对等方要么是一个组长，要么隶属于一个组长 <ul><li>对等方与其组长之间有 TCP连接 </li><li>组长对之间有TCP连接</li></ul></li><li>组长跟踪其所有的孩子的内容</li><li>组长与其他组长联系<ul><li>转发查询到其他组长</li><li>获得其他组的数据拷贝</li></ul></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414205526041.png" alt="混合式"></p><ul><li><p>查询方式</p><ul><li>每个文件有一个散列标识码和一个描述符 </li></ul><blockquote><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414210256736.png" alt="组长记录组内目录"></p></blockquote><ul><li>客户端向其组长发送关键字查询</li></ul><blockquote><p>通过关键字与描述匹配查询相应文件</p></blockquote><ul><li><p>组长用匹配进行响应：</p><ul><li>对每个匹配：元数据、散列标识码和IP地址</li></ul></li><li><p>如果组长将查询转发给其他组长，其他组长也以匹配进行响应</p></li><li><p>客户端选择要下载的文件</p><ul><li>向拥有文件的对等方发送一个带散列标识码的HTTP请求</li></ul><blockquote><p>通过唯一的散列标识码进行确定需要下载的文件</p></blockquote></li></ul></li></ul></li></ul></li></ul></li><li><p>结构化的P2P（DHT 基于分布式散列表的结构化管理）</p><blockquote><p>Overlay是结构化的，例如环、树等，可以进一步深入拓展等</p></blockquote><ul><li>例如：环状结构化P2P</li></ul><p>每个节点映射成唯一的16位的哈希值作为标识，按照哈希值大小有序地首尾相接构成环状有序拓扑。文件同样映射成唯一16位的哈希值，然后按照0-88标识的文件由88节点管理、89-100文件由100节点管理等形式来有序管理文件，查询时只需按照文件标识即可实现快速查询。</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414225432242.png" alt="环状结构化P2P"></p></li></ul></li></ul></li><li><p>非结构化P2P应用实例：BitTorrent</p><ul><li>文件被分为一个个块256KB，然后每个客户端有各自的bitmap，bitmap用来标识文件的有无（有为“1”，无为“0”）</li><li>网络中这些Peers发送接受文件块，相互服务</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414210942114.png" alt="BitTorrent"></p><blockquote><p>tracker记录了洪流中节点的IP地址等信息。新的Peer进来，需要向tracker登记自己信息，同时获得洪流中其他节点的IP信息。</p></blockquote><ul><li><p>新Peer加入torrent：  </p><ul><li><p>新Peer一开始没有块，但是将会通过向其他节点请求来累积文件块 </p><blockquote><p>前几次请求是随机请求，后面几次优先请求稀缺的块，为了保证稀缺的块不会由于其拥有者的下线而丢失，同时，稀缺的块被其他Peer节点所需要，通过提高上载速率来获得更好的下载速率（由下面的tit-for-tat机制决定）</p></blockquote></li><li><p>向跟踪服务器注册，获得peer节点列表，和部分peer 节点构成邻居关系 (“连接 ”) </p></li></ul></li><li><p>当peer下载时，该peer可以同时向其他节点提供上载服务</p></li><li><p>扰动churn: peer节点可能会上线或者下线，但是整体来说维持着文件内容的充分性，P2P服务能力稳定</p></li><li><p>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</p></li><li><p>请求块： </p><ul><li>在任何给定时间，不同 peer节点拥有一个文件块的子集</li><li>周期性的，各个Peer节点向邻居询问他们拥有哪些块的信息 ，即交换bitmap，然后各个Peer向邻居请求它希望的块，稀缺的块</li></ul></li><li><p>发送块：一报还一报 tit-for-tat</p><ul><li><p>每个节点同时只能向4个peer发送块提供服务，来保证提供的带宽较大，而其他peer将被该节点阻塞 (将不会从Alice处获得服务)</p><ul><li><p>所以节点会选择给自己提供带宽较大的、服务较多的4个Peer邻居作为自己服务对象，并且每10秒重新评估一次前4位来优先服务</p><blockquote><p>这种机制有利于激励其他节点提高自己的上载速率，从而提高整个洪流的服务能力</p></blockquote></li><li><p>同时每隔30秒：将随机选择其他peer节点，向这个节点发送块，来 “优化疏通” 这个节点。</p><blockquote><p>原因是新选择的节点所包含的资源有可能是自己需要的，尝试提高给他的服务，有可能有利于之后自己收到它的服务质量的提高</p></blockquote></li></ul></li></ul></li></ul></li></ul><h4 id="4-6-CDN"><a href="#4-6-CDN" class="headerlink" title="4.6 CDN"></a>4.6 CDN</h4><ul><li><p>视频流量：占据着互联网大部分的带宽。</p><p>Netflix，Youlube:占据37%，16%的ISP下行流量<br><del>1B YouTube用户，</del>75M Netflix用户</p><p>挑战:规模性-如何服务者~1B 用户？</p><p>​    单个超级服务器无法提供服务</p><p>挑战:异构性</p><pre><code>不同用户拥有不同的能力（例如:有线接入和移动用户；带宽丰富和受限用户)</code></pre><p>解决方案:分布式的，应用层面的基础设施</p></li><li><p>多媒体：视频</p><ul><li><p>视频：固定速度显示的图像序列，e.g. 24 images/sec</p></li><li><p>网络视频特点：</p><ul><li>高码率：&gt;10x于音频，高的网络带宽需求</li><li>可以被压缩</li><li>90%以上的网络流量是视频 </li></ul></li><li><p>数字化图像：像素的阵列</p></li><li><p>每个像素被若干bits表示</p></li><li><p>编码：使用图像内和图像间的冗余来降低编码的比特数 </p><ul><li>空间冗余（图像内） </li><li>时间冗余（相邻的图像间）</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415125750098.png" alt="编码方式示例"></p><ul><li><p>编码标准：</p><p>CBR: (constant bit  rate): 以固定速率编码 </p><p>VBR: (variable bit  rate): 视频编码速率随时间的变化而变化</p></li></ul></li></ul></li><li><p>存储视频的流化服务</p><p>对于视频文件，并不是将文件全部下载完成以后才进行播放，而是边下载边播放</p></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415125951929.png" alt="场景示例"></p><ul><li><p>多媒体流化服务示例：DASH</p><ul><li>DASH: Dynamic, Adaptive Streaming over HTTP</li></ul><blockquote><p>通过HTTP协议传送数据</p></blockquote><ul><li><p>可以解决不同客户端、不同网络情况、不同需求的问题</p></li><li><p>服务器: </p><ul><li>将视频文件分割成多个块</li><li>每个块独立存储，编码于不同码率（8-10种）</li></ul><blockquote><p>对于每一个块都可以有不同版本，可以是不同清晰度的、不同编码方式的、不同码率的</p></blockquote><ul><li>告示文件（manifest file）: 提供不同块的URL </li></ul><blockquote><p>告示文件提供块的数量、格式、版本以及相应的URL等信息</p></blockquote></li><li><p>客户端: </p><ul><li><p>先获取告示文件</p><blockquote><p>客户端会周期性地测量服务器到客户端的带宽</p></blockquote></li><li><p>查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围</p><ul><li>会根据带宽、客户端需求等信息选择下载块的什么版本等，使得播放流畅质量相对高</li><li>如果带宽足够，选择最大码率的视频块</li><li>会话中的不同时刻，可以切换请求不同的编码块（取决于当时的可用带宽等）</li></ul></li></ul></li><li><p>“智能”客户端：客户端自适应决定</p><ul><li>什么时候去请求块 (不至于缓存挨饿，或者溢出)</li><li>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块) </li><li>哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求) </li></ul></li></ul></li><li><p>挑战：服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)？</p><ul><li><p>选择1：单个的、大的超级服务中心“mega-server” </p><ul><li>服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿 </li><li>“二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差） </li><li>单点故障点，性能瓶颈</li></ul><blockquote><p>一个服务器的服务能力有限</p></blockquote><ul><li>周边网络的拥塞</li></ul><blockquote><p>对于网络拥塞问题，服务器难以解决</p></blockquote><ul><li>评价：相当简单，但是这个方法不可扩展</li></ul></li><li><p>选项2：通过CDN（Content distribution networks），全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p><ul><li><p>CDN部署节点方式：</p><ul><li>enter deep：将CDN服务器深入到许多接入网，将缓存节点部署到local ISP<ul><li>更接近用户，服务质量高，但是数量多，离用户近所以管理困难</li><li>例子：Akamai, 1700个位置</li></ul></li><li>bring home：部署在少数(10个左右)关键位置，如将服务器簇安装于POP附近（离若干1<sup>st</sup> ISP POP较近）<ul><li>采用租用线路将服务器簇连接起来，部署节点少还保证质量较高，但是跳数较多</li><li>例子：Limelight</li></ul></li></ul></li><li><p>CDN实现内容加速示例：</p><ul><li>提供内容服务者首先将内容的备份通过专用链路拷贝到CDN服务商部署的缓存节点中，然后用户申请资源时，先向内容提供者的源服务器请求，然后源服务器提供给他一个告示文件（manifest file），告示文件中有用户所需内容在各缓存节点中的版本信息、URL存储位置等信息，然后用户客户端可以根据网络情况、距离、用户需求等就近从CDN缓存中获取文件块。</li><li>用户从CDN中请求内容<ul><li>重定向到最近的拷贝，请求内容 </li><li>如果网络路径拥塞，可能选择不同的拷贝</li></ul></li></ul></li><li><p>CDN是应用层协议，是在网络边缘来加速网络运营服务、来提供服务的     over the top</p></li><li><p>OTT （over the top）面临的挑战：在拥塞的互联网上复制 </p><ul><li>从哪个CDN节点中获取内容？</li><li>用户在网络拥塞时的行为？</li><li>在哪些CDN节点中存储什么内容？</li></ul></li></ul></li></ul></li></ul><h3 id="5-Socket（套接字）编程"><a href="#5-Socket（套接字）编程" class="headerlink" title="5 Socket（套接字）编程"></a>5 Socket（套接字）编程</h3><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210329092824673.png" alt="网络程序设计接口"></p><ul><li><p>网络应用是在应用层中运行的应用进程之间的通信。应用进程使用<strong>传输层提供的服务</strong>才能够交换报文，实现<strong>应用层协议</strong>，实现应用</p></li><li><p>应用进程与底层协议之间的桥梁：应用编程接口API</p><p>API就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。应用进程通过API将控制权交给操作系统，操作系统调用相应过程，然后将结果传输回应用进程。</p><blockquote><p>传输层以及以下的四层往往由操作系统控制。</p></blockquote></li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210329094838806.png" alt="五层结构"></p><ul><li><p>典型的应用编程接口：</p><ul><li>Berkeley UNIX操作系统   套接字接口（socket interface），简称套接字（socket）</li><li>Windows 上     基于socket的稍不同的API：  WINSOCK</li><li>AT&amp;T为其UNIX系统V定义的一种API：TLI（Transport Layer Interface）</li></ul></li><li><p>TCP/IP  应用进程使用Socket API访问传输服务</p><p>地点：界面上的SAP（socket）方式： Socket API  </p><p>socket: 分布式应用进程之间的门，传输层协议提供的端到端 服务接口</p></li><li><p>传输层服务的协议，决定了socket也是两种类型</p><ul><li>TCP：可靠的、字节流的服务</li></ul><blockquote><p>字节流不提供报文的边界区分</p></blockquote><ul><li>UDP：不可靠的（数据UDP数据报）服务</li></ul></li><li><p>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户</p></li></ul><h4 id="5-1-TCP-Socket"><a href="#5-1-TCP-Socket" class="headerlink" title="5.1 TCP Socket"></a>5.1 TCP Socket</h4><ul><li><p>TCP套接字编程</p><ul><li><p>服务器首先运行，等待连接建立 </p></li><li><p>服务器进程必须先处于运行状态：</p><ul><li>创建欢迎socket和对应的一个套接字整数</li><li>和本地端口捆绑</li><li>在欢迎socket上阻塞式等待接收用户的连接</li></ul><blockquote><p>阻塞式，即没有用户连接，则程序停止在该函数，不向下进行</p></blockquote></li><li><p>客户端需要时，将主动和服务器建立连接： </p><ul><li>创建客户端本地套接字（隐式捆绑到本地port）</li><li>然后指定服务器进程的IP地址和端口号，与服务器进程连接</li></ul><blockquote><p>向服务器请求连接时，服务器的响应未到达时，客户端的socket函数也是阻塞状态</p></blockquote></li><li><p>当客户端的连接请求到达服务器时：</p><p>服务器接受来自用户端的请求 ，解除阻塞式等待，返回一个 新的socket（与欢迎socket不 一样），与客户端通信</p><ul><li>允许服务器与多个客户端通信</li><li>使用源IP和源端口来区分不同的客户端</li></ul></li><li><p>连接API调用有效时，客户端与服务器建立了TCP连接</p></li></ul></li><li><p>TCP socket应用示例</p><p>C/S模式的应用样例: </p><ol><li>客户端从标准输入装置读取一行字符，发送给服务器</li><li>服务器从socket读取字符</li><li>服务器将字符转换成大写 ，然后返回给客户端</li><li>客户端从socket中读取一行字符，然后打印出来</li></ol><p>实际上，这里描述了C-S之间交互的动作次序</p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415191855698.png" alt="TCP socket 示例"></p><ul><li><p>socket中涉及的数据结构介绍</p><ol><li>数据结构 sockaddr_in</li></ol><p>IP地址和port捆绑关系的数据结构（标示进程的端节点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> sin_family; <span class="comment">//AF_INET</span></span><br><span class="line">      <span class="comment">/*地址族 简单来说就是底层是使用的哪种通信协议来递交数据的，如 AF_INET 用的是 TCP/IPv4；AF_INET6使用的是 TCP/IPv6；而 AF_LOCAL 或者 AF_UNIX 则指的是本地通信（即本次通信是在当前主机上的进程间的通信），一般用绝对路径的形式来指明*/</span></span><br><span class="line">  u_short sin_port; <span class="comment">//port  端口号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> ;</span><span class="comment">/*IP address, unsigned long*/</span></span><br><span class="line">  <span class="keyword">char</span> sin_zero[<span class="number">8</span>];  <span class="comment">//align  </span></span><br><span class="line">      <span class="comment">/*起对齐作用，为了让其他格式的不同长度IP地址和TCP/IP格式中的IP地址对齐*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>数据结构 hostent</li></ol><p>域名和IP地址的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *h_name;<span class="comment">//主机域名</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;<span class="comment">//主机的一系列别名</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;</span><br><span class="line"><span class="keyword">int</span> h_length;<span class="comment">/*地址的长度*/</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">//存储一系列IP地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作为调用域名解析函数时的参数返回后，将IP地址拷贝到 sockaddr_in的IP地址部分</p></li><li><p>C/S socket 交互：TCP </p><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/TCPsocket.png" alt="TCPsocket交互过程"></p></li></ul><blockquote><p>黑色箭头是TCP的建立连接过程，红色箭头是TCP Socket传输数据</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//argv[]</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server   服务器的信息sockaddr_in结构*/</span> </span><br><span class="line"><span class="keyword">int</span> clientSocket; <span class="comment">/* socket descriptor 客户端socket整数*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry 指针指向hostent的结构体*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];  </span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];  </span><br><span class="line">    <span class="comment">//argv[0]存应用程序本身名字</span></span><br><span class="line">    host = argv[<span class="number">1</span>]; <span class="comment">//argv[1]存服务器域名 字符串</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]); <span class="comment">//argv[2]存服务器端口号 字符串   //atoi()  字符串转为整形</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Create client socket, connect to server</span></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//建立TCP socket</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure 清零sad*/</span>  </span><br><span class="line">    sad.sin_family = AF_INET; <span class="comment">/* set family to Internet 地址族*/</span>  </span><br><span class="line">    sad.sin_port = htons((u_short)port); <span class="comment">//(u_short)  port先转为无符号短整型   然后htons再变成网络次序（大端/小端）</span></span><br><span class="line">    ptrh = gethostbyname(host);  <span class="comment">/* Convert host name to IP address 由域名得到有效IP地址*/</span> </span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length);  <span class="comment">//将IP地址拷贝到sad.sin_addr </span></span><br><span class="line">    connect(clientSocket,(struct sockaddr*)&amp;sad,<span class="keyword">sizeof</span>(sad));<span class="comment">//将客户端与服务器建立连接</span></span><br><span class="line">    </span><br><span class="line">    gets(Sentence);<span class="comment">//Get input stream from user 标准input获得用户输入</span></span><br><span class="line">    n=write(clientSocket, Sentence,<span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>); <span class="comment">//Send line to server</span></span><br><span class="line">n=read(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence)); <span class="comment">//Read line from server</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n”,modifiedSentence);</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">close(clientSocket); //Close connection</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server服务器本地的sockaddr_in*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/*client的sockaddr_in */</span></span><br><span class="line"><span class="keyword">int</span> welcomeSocket, connectionSocket; <span class="comment">/* socket descriptor 套接字*/</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> clientSentence[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>]; </span><br><span class="line">    </span><br><span class="line">port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//Create welcoming socket at port &amp; Bind a local address</span></span><br><span class="line">welcomeSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span> </span><br><span class="line">sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span> </span><br><span class="line">bind(welcomeSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));<span class="comment">//和自己的IP、端口绑定</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Specify the maximum number of clients that can be queued 可以并行10个进程，超过将会拒绝其他连接*/</span></span><br><span class="line">listen(welcomeSocket, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">connectionSocket=accept(welcomeSocket, (struct sockaddr *)&amp;cad, &amp;alen);<span class="comment">//Wait, on welcoming socket for contact by a client</span></span><br><span class="line">n=read(connectionSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line"><span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span> </span><br><span class="line">    n=write(connectionSocket, capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>); <span class="comment">//Write out the result to socket</span></span><br><span class="line">close(connectionSocket); <span class="comment">//End of while loop,loop back and wait for another client connection</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-UDP-Socket"><a href="#5-2-UDP-Socket" class="headerlink" title="5.2 UDP Socket"></a>5.2 UDP Socket</h4><ul><li>UDP：在客户端和服务器之间没有连接 <ul><li>没有握手</li><li>发送端必须在每一个报文中明确地指定目标的IP地址和端口号</li><li>服务器必须从收到的分组中提取出发送端的IP地址和端口号 </li></ul></li><li>UDP：传送的数据可能乱序，也可能丢失。UDP为客户端和服务器提供不可靠的字节组的传送服务。</li><li>UDP交互过程：</li></ul><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415232630215.png" alt="UDP socket 交互"></p><blockquote><p>UDP的socket包括socket套接字整数值、自己的IP、自己的端口号，而无对方的IP和端口号</p></blockquote><blockquote><p><font color="red">疑问：是不是UDP不能并行？只有一个Socket</font></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span> </span><br><span class="line"><span class="keyword">int</span> clientSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span> modifiedSentence[<span class="number">128</span>]; </span><br><span class="line"></span><br><span class="line">    host = argv[<span class="number">1</span>]; port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);<span class="comment">//创建客户端 socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine the server&#x27;s address */</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">sad.sin_port = htons((u_short)port); </span><br><span class="line">ptrh = gethostbyname(host);</span><br><span class="line"><span class="comment">/* Convert host name to IP address */</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length); </span><br><span class="line">    <span class="comment">//无connect  客户端socket没有连接到服务器</span></span><br><span class="line">    </span><br><span class="line">gets(Sentence);<span class="comment">//Get input stream from user</span></span><br><span class="line">addr_len =<span class="keyword">sizeof</span>(struct sockaddr); </span><br><span class="line">n=sendto(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>,(struct sockaddr *) &amp;sad, addr_len); <span class="comment">//Send line to server  要指明服务器IP和端口号</span></span><br><span class="line">    </span><br><span class="line">n=recvfrom(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence),(struct sockaddr *) &amp;sad, &amp;addr_len);<span class="comment">//Read line from server 要指明服务器IP和端口号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n”,modifiedSentence); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">close(clientSocket); //Close connection</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line"><span class="keyword">int</span> serverSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>]; </span><br><span class="line"><span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>]; </span><br><span class="line"></span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//Create welcoming socket at port &amp; Bind a local address</span></span><br><span class="line"></span><br><span class="line">    serverSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span> </span><br><span class="line">sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span> </span><br><span class="line">bind(serverSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));<span class="comment">//和自己的IP、端口绑定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line"></span><br><span class="line">        n=recvfrom(serverSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence), <span class="number">0</span> (struct sockaddr *) &amp;cad, &amp;addr_len );<span class="comment">//Receive messages from clients</span></span><br><span class="line"><span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span></span><br><span class="line"></span><br><span class="line">        n=sendto(serverSocket , capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>,(struct sockaddr *) &amp;cad, &amp;addr_len); <span class="comment">//Write out the result to socket</span></span><br><span class="line">&#125; <span class="comment">//End of while loop,loop back and wait for another client connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h3><h4 id="6-1-章节整体框架"><a href="#6-1-章节整体框架" class="headerlink" title="6.1 章节整体框架"></a>6.1 章节整体框架</h4><ul><li>应用程序体系结构<ul><li>客户-服务器</li><li>P2P </li><li>混合</li></ul></li><li>应用程序需要的服务品质描述：<ul><li>可靠性、带宽、延时、安全</li></ul></li><li>Internet传输层服务模式 <ul><li>可靠的、面向连接的服务： TCP</li><li>不可靠的数据报：UDP</li></ul></li><li>流行的应用层协议：<ul><li>HTTP</li><li>FTP</li><li>SMTP, POP, IMAP </li><li>DNS </li></ul></li><li>Socket编程</li></ul><h4 id="6-2-复习部分协议内容"><a href="#6-2-复习部分协议内容" class="headerlink" title="6.2 复习部分协议内容"></a>6.2 复习部分协议内容</h4><ul><li>应用层协议报文类型：请求/响应报文：<ul><li>客户端请求信息或服务</li><li>服务器以数据、状态码进行响应 </li></ul></li><li>报文格式： <ul><li>首部：关于数据信息的字段</li><li>数据：被交换的信息</li></ul></li><li>控制报文 vs. 数据报文<ul><li>带内（控制与数据报文一起传输）、带外（控制报文与数据报文不在同一端口传输）</li></ul></li><li>集中式 vs. 分散式</li><li>无状态 vs. 维护状态</li><li>可靠的 vs. 不可靠的报文传输 </li><li>在网络边缘处理复杂性</li><li>一个协议定义了在两个或多个通信实体之间交换报文的格式和次序、以及就一条报文传输和接收或其他事件采取的动作</li></ul><hr><p>终于肝完了，然而我们老师已经讲到了链路层，泪目…  </p><p>之后会加快学习进度 /汗  求支持</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-00绪论</title>
      <link href="2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/"/>
      <url>2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络-绪论"><a href="#计算机网络-绪论" class="headerlink" title="计算机网络-绪论"></a>计算机网络-绪论</h2><blockquote><ul><li>主要参考书籍：<ul><li>《计算机网络：自顶向下方法》（James F.Kurose、Keith W.Ross)</li></ul></li><li>主要参考视频：<ul><li><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=8">中科大郑烇老师全套《计算机网络》</a></li><li><a href="https://www.bilibili.com/video/BV1Up411Z7hC?p=1&share_medium=android&share_plat=android&share_source=COPY&share_tag=s_i&timestamp=1598544022&unique_k=eeA2CI">哈尔滨工业大学 计算机网络</a></li><li><a href="https://www.bilibili.com/video/av64605483/">计算机网络微课堂</a></li></ul></li><li>其他参考文献：<ul><li><a href="https://blog.csdn.net/qq_39326472/article/details/88089747?utm_source=app&app_version=4.5.4">计算机网络（自顶向下方法）学习笔记(头秃的女程序员)</a></li></ul></li></ul></blockquote><span id="more"></span><h3 id="1-计算机网络定义"><a href="#1-计算机网络定义" class="headerlink" title="1. 计算机网络定义"></a>1. 计算机网络定义</h3><ul><li><p>计算机网络=通信技术+计算机技术</p></li><li><p>计算机网络就是一种通信网络。</p></li><li><p>定义：计算机网络就是互连的、自治的计算机集合。</p><ul><li>自治-无主从关系</li><li>互连-互联互通<br>距离远、数量大如何保证互连？通过交换网络互连主机<h3 id="2-Internet"><a href="#2-Internet" class="headerlink" title="2. Internet"></a>2. Internet</h3></li></ul></li><li><p>全球最大的互联网络：Internet<br>ISP(Internet Service Provider)网络互连的“网络之网络”</p></li><li><p>Internet组成：<br>计算设备集合</p><blockquote><p>· 主机（hosts）=端系统（end systems）<br>· 运行各种网络应用</p></blockquote><p>通信链路</p><blockquote><p>光纤，铜缆，无线电，卫星……</p></blockquote><p>分组交换：转发分组（数据包）</p><blockquote><p>路由器（routers）和交换机（switches）</p></blockquote></li><li><p>Internet提供的服务：</p><ul><li><p>为网络应用提供通信服务的通信基础设施</p><blockquote><p>Web, VoIP, email, 网络游戏, 电子商务, 社交网络, …</p></blockquote></li><li><p>为网络应用提供应用编程接口（API）</p><blockquote><p>· 支持应用程序“连接” Internet，发送/接收数据<br>· 提供类似于邮政系统的数据传输服务</p></blockquote></li></ul></li></ul><h3 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3. 网络协议"></a>3. 网络协议</h3><ul><li>协议是计算机网络有序运行的重要保证<br>硬件（主机、路由器、通信链 路等）是计算机网络的基础<br>计算机网络中的数据交换必须遵守事先约定好的规则</li><li>网络通信：<br>通信主体是“机器”<br>交换“电子化”或 “数字化”消息<br>计算机网络的所有通信过程都必须遵守某种/些规则—协议</li><li>网络协议(network protocol)，简称为协议 ，是为进行网络中的数据交换而建立的规 则、标准或约定。<br>协议规定了通信实体之间所交换的消息的 格式、意义、顺序以及针对收到信息或发 生的事件所采取的“动作”（actions）</li><li>协议的三要素：<br>语法（Syntax） <blockquote><p> 数据与控制信息的结构或格式  信号电平 </p></blockquote></li></ul><p>语义（Semantics） </p><blockquote><p> 需要发出何种控制信息  完成何种动作以及做出何种响应  差错控制  </p></blockquote><p>  时序（Timing） </p><blockquote><p> 事件顺序  速度匹配</p></blockquote><ul><li><p>Internet协议标准<br>RFC: Request for Comments<br>IETF:互联网工程任务组（ Internet Engineering Task  Force）</p><h3 id="4-计算机网络的结构"><a href="#4-计算机网络的结构" class="headerlink" title="4. 计算机网络的结构"></a>4. 计算机网络的结构</h3><h4 id="4-1-计算机网络的结构"><a href="#4-1-计算机网络的结构" class="headerlink" title="4.1 计算机网络的结构"></a>4.1 计算机网络的结构</h4></li><li><p>网络边缘</p><blockquote><p>主机<br>网络应用</p></blockquote></li><li><p>接入网络，物理介质</p><blockquote><p>有线或无线通信链路</p></blockquote></li><li><p>网络核心（核心网络）</p><blockquote><p>互联的路由器（或分组转发设备）<br>网络之网络</p></blockquote></li></ul><h4 id="4-2-网络边缘"><a href="#4-2-网络边缘" class="headerlink" title="4.2 网络边缘"></a>4.2 网络边缘</h4><ul><li>主机（端系统）<ul><li>位于“网络边缘”</li><li>运行网络应用程序<blockquote><ul><li>客户/服务器（client/server）应用模型<ul><li>客户发送请求，接受服务器响应</li></ul></li><li>对等（peer-peer，P2P）应用模型<ul><li>无（或不仅依赖）专用服务器</li><li>通信在对等实体之间直接进行</li></ul></li></ul></blockquote></li></ul></li><li>如何将网络边缘接入核心网（边缘路由器）？   接入网络</li></ul><h4 id="4-3-接入网络"><a href="#4-3-接入网络" class="headerlink" title="4.3 接入网络"></a>4.3 接入网络</h4><ul><li>接入网络：数字用户线路（DSL）<ul><li>利用已有的电话线连接中心局的DSLAM</li><li>非对称的 ：<br>上行传输速率&lt;2.5Mbps     下行传输速率&lt;24Mbps</li><li>FDM ：频分多路复用<br>50 kHz - 1 MHz用于下行 4 kHz - 50 kHz用于上行 0 kHz - 4 kHz用于传统电话</li></ul></li><li>接入网络：电缆网络<ul><li>HFC:混合光纤同轴电缆（ hybrid fiber coax）<br>非对称: 下行高达30Mbps传输速率，上行为2 Mbps传 输速率</li><li>频分多路复用</li><li>各家庭（设备）通过电缆网络→光纤接入ISP路由器<br>各家庭共享家庭至电缆头端的接入网络<br>不同于DSL的独占至中心局的接入</li></ul></li><li>机构（企业）接入网络（Ethernet）<br><em>Ethernet</em>一般指以太网。以太网是一种计算机局域网技术。<br>主要用于公司、高校、企业等组织机构<br>典型传输速率：10 Mbps, 100Mbps, 1Gbps, 10Gbps<br>目前，端系统通常直接连接以太网交换机（switch）</li><li>无线接入网络<br>通过共享的无线接入网络连接端系统与路由器 （通过基站（base station）或称为“接入点”（access point））</li></ul><p>  <img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324200838785.png" alt="image-20210324200838785"></p><h4 id="4-4-网络核心"><a href="#4-4-网络核心" class="headerlink" title="4.4 网络核心"></a>4.4 网络核心</h4><ul><li><p>网络核心：互联的路由器网络</p></li><li><p>网络核心的关键功能：路由+转发</p></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324201246749.png" alt="image-20210324201246749"></p><ul><li><p>ISP（互联网服务提供商（Internet Service Provider））</p></li><li><p>端系统通过接入ISP（access ISPs ）连接到 Internet，接入ISP必须进一步互连，这样任意两个主机才可以互相发送分组 。这就构成复杂的网络互连的网络。（经济和国家政策是网络演进的主要驱动力）</p></li><li><p>接入ISP包括住宅、学校、公司、移动网络的基站等</p></li><li><p>Internet结构</p><blockquote><p>access net 接入网络    ISP 互联网服务提供商</p></blockquote></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324202751918.png" alt="image-20210324202751918"></p><blockquote><p>对等链路、IXP都是连接ISP的结构，其中IXP可以实现多个ISP的连接</p></blockquote><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324202847419.png" alt="image-20210324202847419"></p><blockquote><p>局域ISP进一步细化</p></blockquote><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324202906584.png" alt="image-20210324202906584"></p><blockquote><p>ISP是提供接入网络的<br>ICP（内容供应商）是提供业务、服务的<br>ICP也需要ISP来接入网络，成本高，提供网质量不高，所以后来大型的ICP（例如Google等）在全球部署数据中心机房（DC）利用专用电缆、光缆将DC连接，再接入ISP，来降低成本，提高用户体验</p></blockquote><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324202942386.png" alt="image-20210324202942386"></p><ul><li>Internet结构<ul><li>划分方式一：互联网分为结点和链路。主机结点称为网络边缘，网络交换结点和交换结点以及链路称为网络核心，将网络边缘接入网络核心的链路称为接入网络。</li><li>划分方式二：接入ISP汇集到区域ISP，区域ISP再汇集到一级ISP。</li></ul></li></ul><h4 id="4-6-数据交换"><a href="#4-6-数据交换" class="headerlink" title="4.6 数据交换"></a>4.6 数据交换</h4><ul><li><p>网络核心是为了解决将源主机发送的数据通过网络核心成功地传递给目的主机        –通过数据交换实现。</p></li><li><p>数据交换的类型：<br>电路交换      报文交换     分组交换</p></li></ul><h5 id="4-6-1-电路交换"><a href="#4-6-1-电路交换" class="headerlink" title="4.6.1 电路交换"></a>4.6.1 电路交换</h5><ul><li>最典型的电路交换网络：电话网络</li><li>电路交换的三个阶段：<br>建立连接（呼叫/电路建立）      通信       释放连接（拆除电路）</li><li>电路交换是独占资源的</li><li>电路交换网络如何共享中继线？    多路复用</li></ul><h5 id="4-6-2-多路复用"><a href="#4-6-2-多路复用" class="headerlink" title="4.6.2 多路复用"></a>4.6.2 多路复用</h5><ul><li><p>多路复用(multiplexing)，简称复用，是通信技术 中的基本概念。</p></li><li><p>多路复用(Multiplexing): 链路/网络资源（如带宽）划分为“资源片” 。<br>将资源片分配给各路“呼 叫”（calls）<br>每路呼叫独占分配到的资源片进行通信<br>资源片可能“闲置”(idle)  (无共享)</p></li><li><p>典型多路复用方法:<br>频分多路复用( frequency  division multiplexing-FDM )<br>时分多路复用( time division  multiplexing-TDM )<br>波分多路复用(Wavelength  division multiplexing-WDM)<br>码分多路复用( Code  division multiplexing-CDM )</p></li><li><p>频分多路复用FDM<br><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324203913089.png" alt="image-20210324203913089"><br>频分多路复用的各用户占用不同的带宽资源（请注意，这里的“带宽 ”是频率带宽（单位：Hz）而不是数据的发送速率）。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<br><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324204022544.png" alt="image-20210324204022544"></p></li><li><p>时分多路复用TDM<br>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧），每个用户在每个 TDM 帧中占用固定序号的时隙。<br>每用户所占用的时隙是周期性出现（其周期就是 TDM 帧的长度）。</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324204152398.png" alt="image-20210324204152398"></p><p>时分复用的所有用户是在不同的时间占用相同的频带宽度</p></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324204209123.png" alt="image-20210324204209123"></p><ul><li>波分多路复用WDM<br>波分复用就是光的频分复用</li><li>码分多路复用CDM<img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324204526439-1618041462218.png" alt="image-20210324204537250"></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324204537250-1618041480074.png" alt="image-20210324204537250"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324204607434.png" alt="image-20210324204607434"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324204619871.png" alt="image-20210324204619871"></p><h5 id="4-6-3-报文交换"><a href="#4-6-3-报文交换" class="headerlink" title="4.6.3 报文交换"></a>4.6.3 报文交换</h5><ul><li><p>报文：源（应用）发送信息整体，比如：一个文件。</p></li><li><p>报文交换（message switching)</p></li></ul><h5 id="4-6-4-分组交换"><a href="#4-6-4-分组交换" class="headerlink" title="4.6.4 分组交换"></a>4.6.4 分组交换</h5><ul><li><p>分组：报文拆分出来的一系列相对较小的数据包。<br><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324205156713.png" alt="image-20210324205156713"></p></li><li><p>分组交换需要报文的拆分和重组，会产生额外的开销。</p></li><li><p>分组交换中是按需共享链路（statistical multiplexing）的，不同设备的分组序列不确定，所以分组交换又称：统计多路复用。</p></li><li><p>报文交换和分组交换均采用存储-转发（store-and-forward）交换方式。<br>区别：报文交换是以完整报文进行“存储-转发”，而分组交换是以较小的分组进行“存储-转发”。</p></li><li><p>传输延迟：<br>分组传输延迟（delay）=分组（packets）/链路传输速率</p></li><li><p>报文交换 vs 分组交换<br>分组交换总传输延迟更小，所需要路由器的带宽更小。</p></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324211945460.png" alt="image-20210324211945460"></p><ul><li><p>例：<br><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324212548450.png" alt="image-20210324212548450"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210324212606781.png" alt="image-20210324212606781"></p></li><li><p>电路交换 vs 分组交换<br>分组交换资源共享率更高，让更多用户共享网络资源。<br>分组交换适用于突发数据传输网络，可以资源充分共享，同时简单、无需呼叫建立。///////////////////////////TCP三次握手？<br>分组交换可能产生拥塞（congestion）：分组延迟和丢失。（需要用协议处理可靠数据传输和拥塞控制）</p></li><li><p>问题：分组交换如何提供电路级性能保障？</p></li></ul><ul><li>分组丢失</li></ul><h4 id="4-7-计算机网络性能"><a href="#4-7-计算机网络性能" class="headerlink" title="4.7 计算机网络性能"></a>4.7 计算机网络性能</h4><ul><li><p>速率<br>速率即数据率（data rate）、数据传输速率、比特率（bit rate）</p><ul><li><p>单位时间（秒）传输信息（比特）量</p></li><li><p>计算机网络中最重要的一个性能指标</p></li><li><p>单位：b/s（或bps） kb/s、Mb/s、Gb/s</p></li><li><p>k=10^3        M=10^6      G=10^9</p></li><li><p>速率往往是指额定速率或者标称速率，实际很难达到。</p></li></ul></li><li><p>带宽</p><ul><li><p>带宽（bandwidth）原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</p></li><li><p>网络中的带宽通常是指数字信道所能传送的“最高数据率”，单位：b/s（bps）</p></li><li><p>常用单位：kb/s、Mb/s、Gb/s、Tb/s</p></li><li><p>k=10^3        M=10^6      G=10^9    T=10^12</p></li></ul></li><li><p>延迟/时延（delay或latency）</p></li></ul><p>分组交换为什么会发生丢包？</p><p>分组在路由器缓存中排队，分组到达速率超过输出链路容量时/路由器缓存不足以存储分组，就会发生丢包。</p><p>时延：分组排队，等待输出链路可用</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331170923229.png" alt="image-20210331170923229"></p><ul><li><p>四种分组延迟</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331172225453.png" alt="image-20210331172225453"></p><ul><li><p>d<sub>proc</sub>：结点处理延迟（nodal processing delay）</p><p>处理时延是因为节点需要解析分组的必要信息然后决定其出链路（索引转发表等操作）而产生的，通常在微秒或者更低数量级；</p></li><li><p>d<sub>queue</sub>：排队延迟（queueing delay）</p><p>排队时延是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的；一般来说，排队时延是到达该队列的流量强度和性质的函数，通常可以达到毫秒级到微秒级；</p></li><li><p>d<sub>trans</sub>：传输延迟（transmission delay）</p><p>传输时延是将所有分组的比特推向链路所有需要的时间，实际的传输时延通常在毫秒到微秒数量级。</p><ul><li>L：分组长度（bits）</li><li>R：从路由器A到B的链路传输速率/链路带宽（bps）</li><li>d<sub>trans</sub>=L/R</li></ul></li><li><p>d<sub>prop</sub>：传播延迟（propagation delay）</p><p>传播时延是指比特进入链路后，从该链路的起点到下一个结点所用的时间；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。</p><ul><li>d：物理链路长度</li></ul></li><li><p>s：信号传播速度（铜缆中电信号速度0.7倍光速~2×10<sup>8</sup>m/sec）</p><ul><li>d<sub>prop</sub>=d/s</li></ul><blockquote><p><strong>传输时延和传播时延的对比</strong></p><p>传输时延是传输一个分组的时间，传播时延是分组从一个结点到另一个结点的时间。如果打个比方的话，传输时延就是大卡车经过收费站的时间而传播时间就是车在高速公路上行驶的时间。</p></blockquote><p>一跳的时间延迟（某一分组从到达一个结点到传播到下一个结点的时间）d<sub>nodal</sub>=d<sub>proc</sub>+d<sub>queue</sub>+d<sub>trans</sub>+d<sub>prop</sub></p></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331172851542.png" alt="image-20210331172851542"></p></li><li><p>排队延迟和丢包</p></li></ul><p>丢包：到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失</p><p>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；如果分组到达的速度高于结点的处理速度，那么分组就会在缓冲队列里排队等待。当缓冲空间用完后，如果还有到的分组，那么该分组将被迫丢弃。</p><p>为了描述网络状体，我们引入了流量强度这一概念：流量强度=分组到达的速度/结点的处理速度；流量工程里一个金科玉律就是：设计系统时流量强度不能大于1；</p><p>当流量强度持续大于1时，就将出现丢包现象。</p><blockquote><p>R：链路带宽（bps）   L：分组长度（bits）   a：平均分组到达速率</p><p>流量强度（traffic intensity）= La/R</p></blockquote><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331173545650.png" alt="image-20210331173545650"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331173454963.png" alt="image-20210331173454963"></p><ul><li><p>时延带宽积/带宽时延积</p><p>时延带宽积 = 传播时延 × 带宽 = d<sub>prop</sub> × R （bits）</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331173859612.png" alt="image-20210331173859612"></p><blockquote><p>时延带宽积表示链路能够容纳的比特位</p><p>链路的时延带宽积又称为以比特为单位的链路长度</p></blockquote></li><li><p>分组丢失（丢包）</p><ul><li>队列缓存有限，分组到达已满队列将被丢弃（丢失），丢弃分组可能由前序结点或者源重发（也可能不重发）</li><li>丢包率 = 丢包数 / 已发分组总数</li></ul></li><li><p>吞吐量/率（Troughput）</p><ul><li><p>表示在发送<strong>端</strong>与接受<strong>端</strong>之间传送数据速率（b/s）</p><ul><li>即时吞吐率：给定时刻的速率</li><li>平均吞吐量：一段时间的平均速率</li></ul><blockquote><p>吞吐量可以近似为源和目的地之间路径的最小传输速率。最小传输速率的链路为<strong>瓶颈链路</strong>。吞吐量取决于瓶颈链路（bottleneck link），瓶颈链路：端到端路径上，限制端到端吞吐量的链路</p></blockquote></li></ul></li></ul><h3 id="5-计算机网络体系结构概述"><a href="#5-计算机网络体系结构概述" class="headerlink" title="5. 计算机网络体系结构概述"></a>5. 计算机网络体系结构概述</h3><h4 id="5-1-分层结构"><a href="#5-1-分层结构" class="headerlink" title="5.1 分层结构"></a>5.1 分层结构</h4><ul><li><p>采用分层结构来研究计算机网络体系结构，每层完成一类特定功能/服务，每层依赖底层提供的服务，通过层内动作完成相应功能</p></li><li><p>网络体系结构是从功能上描述计算机网络结构</p></li><li><p>计算机网络体系结构简称网络体系结构是分层结构，每层遵循某个/些网络协议完成本层功能。计算机网络体系结构是计算机网络的各层以及其协议的集合，是计算机网络的功能层次以及关系的定义，是抽象的。</p></li><li><p>分层结构<br>优点</p><ul><li>结构清晰，有利于识别复杂系统的部件以及关系</li><li>模块化的分层易于系统更新、维护</li><li>有利于标准化</li></ul><p>缺点</p><ul><li>分层过多可能导致效率较低，例：某层的功能可能需要仅在其它层才出现的信息</li></ul></li><li><p>功能上的冗余，比如许多协议栈针对链路和端到端两种情况都提供了差错恢复功能</p></li><li><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331182052218.png" alt="image-20210331182052218"></p><ul><li>实体（entity）表示任何可发送或者接受信息的硬件或者软件进程</li><li>协议是控制两个对等实体进行通信的规则的集合，协议是“水平的”</li><li>任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是“垂直的”</li><li>下层协议的实现对上层的服务用户是透明的</li><li>同系统的相邻层实体间通过接口进行交互，通过服务访问点SAP（Service Access Point），交换原语，指定请求的特定服务</li></ul></li></ul><h4 id="5-2-OSI参考模型"><a href="#5-2-OSI参考模型" class="headerlink" title="5.2 OSI参考模型"></a>5.2 OSI参考模型</h4><ul><li><p>OSI参考模型</p><ul><li><p>开放系统互联（OSI）参考模型是由国际标准化组织(ISO)于1984年提出的分层网络体系结构模型<br>目的是支持异构网络系统的互联互通<br>异构网络系统互连的国际标准理解网络通信的最佳学习工具(理论模型)</p><blockquote><p>理论成功，市场失败</p></blockquote><p>7层(功能）,每层完成特定的网络功能</p></li></ul></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331182931687.png" alt="image-20210331182931687"></p><ul><li>OSI通信过程</li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331183505710.png" alt="image-20210331183505710"></p><blockquote><p>前四层称为“端到端层（end-end）”</p></blockquote><ul><li><p>数据封装与解封装</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331183955509.png" alt="image-20210331183955509"></p><ul><li>为什么需要数据封装？<ul><li>增加控制信息<ul><li>构造协议数据单元（PDU）</li></ul></li><li>控制信息主要包括<ul><li>地址（Address）：标识发送端/接受端</li><li>差错检测编码（Error-detecting code）：用于差错检测或者纠正（有的协议有，有的协议没有）</li><li>协议控制（Protocol control）：实现协议功能的附加信息，如：优先级（priority）、服务质量（Qos）和安全控制等</li></ul></li></ul></li></ul></li><li><p>物理层功能</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331184757076.png" alt="image-20210331184757076"></p><ul><li>接口特性<ul><li>机械特性、电气特性、功能特性、规程特性</li></ul></li><li>比特编码</li><li>数据率</li><li>比特同步<ul><li>时钟同步</li></ul></li><li>传输模式<ul><li>单工（Simplex）：只能单向传输</li><li>半双工（half-duplex）：可以双向进行，但是同一时刻只能一个方向进行</li><li>全双工（full-duplex）：可以同时进行双向传输</li></ul></li></ul></li><li><p>数据链路层功能</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331185211807.png" alt="image-20210331185211807"></p><ul><li>负责结点-结点（node-to-node）数据传输</li><li>组帧（Framing），加头加尾，为了接收端物理层可以切分数据流成帧</li><li>物理寻址（Physical addressing）<ul><li>在帧头中增加发送结点和/或接受结点的物理地址标识数据帧的发送和/接收端</li></ul></li><li>流量控制（Flow control）<ul><li>避免淹没接受端</li></ul></li><li>差错控制（Error control）<ul><li>检测并重传损坏或丢失帧，并避免重复帧</li></ul></li><li>访问（接入）控制（Access control）<ul><li>在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权</li></ul></li></ul></li><li><p>网络层功能</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331190332672.png" alt="image-20210331190332672"></p><ul><li>负责源主机到目的主机数据分组（packet）交付<ul><li>可能穿越多个网络–逻辑寻址</li></ul></li><li>逻辑寻址（Logical addressing）<ul><li>全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址</li></ul></li><li>路由（Routing）<ul><li>路由器（或网关）互连网络，并路由分组至最终目的主机</li><li>路径选择</li></ul></li><li>分组转发</li></ul></li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331190643191.png" alt="image-20210331190643191"></p><blockquote><p>红色S、A等表示网络层地址（逻辑地址）不变，绿色02、27等表示数据链路层地址（物理地址）会改变</p></blockquote><ul><li><p>传输层功能</p><p>负责源-目的（端-端）（进程间）完整报文传输</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331191041188.png" alt="image-20210331191041188"></p><ul><li><p>分段与重组</p></li><li><p>SAP寻址</p><ul><li>确保将完整报文提交给正确的进程，如端口号</li></ul><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331191406873.png" alt="image-20210331191406873"></p></li><li><p>连接控制  （逻辑连接，不是电路连接）</p></li><li><p>流量控制（端到端）</p></li><li><p>差错控制</p></li></ul></li><li><p>会话层功能</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331191850256.png" alt="image-20210331191850256"></p><ul><li>对话控制（dialog controlling）<ul><li>建立、维护</li></ul></li><li>同步（synchronization）<ul><li>在数据流中插入“同步点”（syn），可以在对话出现差错时就近恢复</li></ul></li></ul></li><li><p>表示层功能</p><p>处理两个系统间交换信息的语法与语义（syntax and semantics）问题</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331191950105.png" alt="image-20210331191950105"></p><ul><li>数据表示转换<ul><li>发送端将信息转化为一种独立的不依赖于主机的编码，接收端接收到后将这种编码再转换为自身的编码信息</li></ul></li><li>加密/解密</li><li>压缩/解压缩</li></ul></li><li><p>应用层功能</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331192404895.png" alt="image-20210331192404895"></p><ul><li>支持用户通过用户代理（如浏览器）或网络接口使用网络（服务）</li></ul></li></ul><h4 id="5-3-TCP-IP参考模型"><a href="#5-3-TCP-IP参考模型" class="headerlink" title="5.3 TCP/IP参考模型"></a>5.3 TCP/IP参考模型</h4><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331192847062.png" alt="image-20210331192847062"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331192902759.png" alt="image-20210331192902759"></p><blockquote><p>网络接口层无具体协议，是链路层的简化</p></blockquote><h4 id="5-4-五层参考模型"><a href="#5-4-五层参考模型" class="headerlink" title="5.4 五层参考模型"></a>5.4 五层参考模型</h4><blockquote><p>综合OSI（理论清晰）和TCP/IP（实用，如今的Internet就是这样的结构）的优点</p></blockquote><p>各层的所有协议组合起来，称为<strong>协议栈</strong>。因特网的协议栈有5个层次组成：物理层、链路层、网络成、传输层、应用层</p><p><strong>应用层</strong>：应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为报文；<br><strong>传输层</strong>：传输层在应用程序端点之间传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为报文段。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。<br><strong>网络层</strong>：网络层将称为数据报的网络层分组从一台主机移动到另一台主机。网络层协议包含著名的IP协议以及其他一些路由选择协议。数据报<br><strong>链路层</strong>：链路层将称为帧的链路层分组从一个结点移动到路径上的另一个端点。一个帧可能被沿途不同链路上的不同链路层协议处理。帧<br><strong>物理层</strong>：物理层的任务是将帧中的比特从一个结点移动到下一个节点，它提供了传输信息的实际物理通道；<br><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331193222684.png" alt="五层参考模型"></p><ul><li><p>五层模型的数据封装</p><p>​    <strong>封装</strong>：一个分组，在不同的层次有不同的称谓，是因为它们经过每一层的时候就被该层封装上了属于该层的相关信息，也就是前面提到的必要信息；于是，每一分层的分组有两种类型的字段：首部字段和有效负载；其中有效负载即为来自上一层的分组数据，而首部字段就是该层加上的必要信息；分组不断被封装以实现各层协议规定的相关功能。</p><p>​    对等层协议之间交换的信息单元统称为协议数据单元(PDU,Protocol Data Unit)</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331193541952.png" alt="封装/解封装"></p></li><li><p>应用层—— 报文       传输层——报文段（Segment） 　　网络层——分组（数据包）（Packet） 　　数据链路层——数据帧（Frame） 　　物理层——比特（Bit）</p><blockquote><p><font color="red">这几个数据之间的关系，是越来越小，还是越来越大？</font></p><p>首先数据在应用层加头变成报文；报文在传输层可能会被分组，然后加头变成报文段；网络层每个报文段也可能被分段，然后每段加上原报文段的头部，再加上网络层的头变成数据报；数据链路层每个数据报加头加尾变成数据帧；物理层通过数据链路层的mac知道往哪里发，就通过物理链路传输。</p><p><strong>数据的整条发送链是：</strong></p><p>1、某进程(也就是在应用层)准备好待传输数据，若目的地址是域名则要先通过DNS解析成IP地址</p><p>2、交付到运输层(TCP/UDP层)，运输层对数据进行适当的分组等操作，后对每一个分组数组加上首部形成报文段(或用户数据报)首部包括源地址、源端口、目的地址、目的端口和一些其他的诸如校验和等数据</p><p>3、交付到网际层(IP层)，对分组数据加上首部形成IP数据报，首部包括源地址、目的地址(跟运输层的目的地址不同，运输层的目的地址是数据要传送的最终地址，而该目的地址是通过路由表信息得出，是该数据下一步该转移的目的计算机)和校验和等数据</p><p>4、交付到数据链路层(mac层)，先是对把数据封装成帧(也就是添加首部[SOH]和尾部[EOT])，然后进行透明传输(也就是封装的数据里面，如果出现首部SOH和尾部EOT这样的数据，对其进行转义，也就是加上ESC转义字符，这种方法称为字节/字符填充)</p><p>5、交付到物理层，根据数据链路层的mac知道要传输到目的计算机，通过特定的传输介质传送到下一个地址</p><p>6、若源主机与最终目的主机在同一个网段，则该地址是最终的目的主机，开始接收数据，进入第7步骤，若源主机和最终目的主机不在同一个网段，进入第11步骤</p><p>7、交付到数据链路层，对数据进行卸装，该层会对接收的数据进行差错检测，有差错的数据都会被丢弃</p><p>8、交付到IP层，解帧校验</p><p>9、交付到运输层，在该主机上，根据端口找到对应的应用，当使用的TCP协议时，提供一种面向连接的可靠的传输服务，可以说是建立了一个虚拟通道，源主机的数据通过该虚拟通道进行传输；若是使用的UDP协议时，提供一种面向的非连接的尽最大努力的不可靠的传输服务，数据传输快，但是无法保证数据100%传输。</p><p>10、建立了传输连接后，应用开始接收数据，发送方数据和接收方都必须满足相同的标准应用层协议，如http、ftp、smtp等，通过标准协议应用即可正确的接收源主机发送过来的数据。</p><p>11、该计算机不是最终主机，那该计算机就是路由器也就是用于转发分组数据的中转站，首先接收数据的处理同步骤7和8一样，然后接下来的流程又是如同步骤3路由器通过IP找下一个主机</p><p>12、如此循环直至找到最终主机，将数据传送到目的应用</p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/20150704155319778" alt="主机之间数据传输过程"></p></blockquote></li></ul><h3 id="6-计算机网络与Internet发展历史"><a href="#6-计算机网络与Internet发展历史" class="headerlink" title="6.计算机网络与Internet发展历史"></a>6.计算机网络与Internet发展历史</h3><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331193804005.png" alt="image-20210331193804005"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331194018327.png" alt="image-20210331194018327"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331194416382.png" alt="image-20210331194416382"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331194554759.png" alt="image-20210331194554759"></p><p><img src="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/image-20210331194816888.png" alt="image-20210331194816888"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
