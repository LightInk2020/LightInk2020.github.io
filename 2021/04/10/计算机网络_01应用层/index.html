<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Zhi Mang Xing:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lightink2020.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机网络-应用层 学习目标：  网络应用的原理：网络应用协议的概念和实现方面  网络应用的体系结构： 客户-服务器模式     对等模式（peer-to-peer）     混合结构   网络应用的服务需求： 可靠性     带宽     时延">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-应用层">
<meta property="og:url" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/index.html">
<meta property="og:site_name" content="落纸浅墨">
<meta property="og:description" content="计算机网络-应用层 学习目标：  网络应用的原理：网络应用协议的概念和实现方面  网络应用的体系结构： 客户-服务器模式     对等模式（peer-to-peer）     混合结构   网络应用的服务需求： 可靠性     带宽     时延">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/20190324183705231.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165338821.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165429573.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210401180447699.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165453140.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210331234531220.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410172627902.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411094526831.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411100319390.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411100617644.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102836028.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411103950494.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411132650541.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411112003845.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411131620123.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411134148359.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411140316400.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411140846744.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411143216745.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411144156506.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411145603153.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411161744290.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163153908.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163746751.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163945732.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163959897.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411164018449.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411165916546.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411194534840.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411202825985.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411205241273.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210412145320300.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210412145541524.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413165837322.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413183435963.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413183541230.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413185005911.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413195554207.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413211302361.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413234354328.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413234546250.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413235044154.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413235107155.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414082756872.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414083126229.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414085223889.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414085509474.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414091248820.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414114834512.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414203646040.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414205526041.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414210256736.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414225432242.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414210942114.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415125750098.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415125951929.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210329092824673.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210329094838806.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415191855698.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/TCPsocket.png">
<meta property="og:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415232630215.png">
<meta property="article:published_time" content="2021-04-10T07:40:56.000Z">
<meta property="article:modified_time" content="2022-03-16T02:41:17.724Z">
<meta property="article:author" content="浅墨">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/20190324183705231.png">

<link rel="canonical" href="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络-应用层 | 落纸浅墨</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <!-- 右上github跳转-->
    <a target="_blank" rel="noopener" href="https://github.com/LightInk2020" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
      </svg>
    </a>
    <style>
      .github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
    </style>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">落纸浅墨</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">笔落生墨，纸上留痕</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">64</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <!-- 设置首页头部图片 暂时做成这样，之后改成halo主题的 一行三个推荐页-->
          <div class="post-block" style="opacity: 1;display: block; padding:0px">
            <img src="/images/bg.png" alt="头部图片" style="border-radius:5px; height:300px;width:100%;opacity:0.65;">
          </div>

          

          <div class="content post posts-expand" style="padding-top: 10px;">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="浅墨">
      <meta itemprop="description" content="点点滴滴，汇聚人生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="落纸浅墨">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络-应用层
        </h1>

        <div class="post-meta">
          <!-- 置顶 -->
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 15:40:56" itemprop="dateCreated datePublished" datetime="2021-04-10T15:40:56+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-16 10:41:17" itemprop="dateModified" datetime="2022-03-16T10:41:17+08:00">2022-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="计算机网络-应用层"><a href="#计算机网络-应用层" class="headerlink" title="计算机网络-应用层"></a>计算机网络-应用层</h2><ul>
<li><p>学习目标：</p>
<ul>
<li><p>网络应用的原理：网络应用协议的概念和实现方面</p>
<ul>
<li>网络应用的体系结构：<ul>
<li>客户-服务器模式     对等模式（peer-to-peer）     混合结构</li>
</ul>
</li>
<li>网络应用的服务需求：<ul>
<li>可靠性     带宽     时延</li>
</ul>
</li>
</ul>
<span id="more"></span></li>
<li><p>传输层提供的服务模型</p>
<ul>
<li>TCP、UDP 如何为应用层提供的支持？</li>
</ul>
</li>
<li><p>内容分发网络</p>
</li>
<li><p>网络应用的实例：互联网流行的应用层协议</p>
<ul>
<li>web应用–HTTP协议</li>
<li>文件传输应用–FTP协议</li>
<li>email应用–SMTP、POP3、IMAP协议</li>
<li>实现网络核心应用功能的DNS</li>
</ul>
</li>
<li><p>编程：如何开发网络应用程序？</p>
<ul>
<li>Socket API</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/20190324183705231.png" alt="应用层知识点框图"></p>
<h3 id="1-网络应用体系结构"><a href="#1-网络应用体系结构" class="headerlink" title="1 网络应用体系结构"></a>1 网络应用体系结构</h3><p>​    网络应用在不同的端系统上运行。网络应用通过网络基础设施提供的服务，应用进程彼此之间通信。例如web应用，web服务器软件和浏览器软件通信。</p>
<p>​    在网络核心中没有应用层软件，网络核心中没有应用层功能，网络应用只在端系统上存在，更方便网络应用的开发和部署。</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165338821.png" alt="网络应用开发和部署"></p>
<h4 id="1-1-客户机-服务器结构（Client-Server，C-S）"><a href="#1-1-客户机-服务器结构（Client-Server，C-S）" class="headerlink" title="1.1 客户机/服务器结构（Client-Server，C/S）"></a>1.1 客户机/服务器结构（Client-Server，C/S）</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165429573.png" alt="C/S"></p>
<ul>
<li><p>服务器</p>
<ul>
<li>一直运行</li>
<li>永久性访问地址/域名</li>
<li>利用大量服务器实现可拓展性，服务器场，数据中心进行扩展</li>
</ul>
</li>
<li><p>客户机</p>
<ul>
<li>主动与服务器通信，使用服务器提供的服务</li>
<li>间接性接入网络</li>
<li>可能是动态IP地址</li>
<li>不会与其他客户机直接通信</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>可拓展性差，服务器有限的服务能力，链路带宽限制；</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210401180447699.png" alt="C/S拓展性差"></p>
<ul>
<li>可靠性差，依赖于服务器</li>
</ul>
</li>
</ul>
<blockquote>
<p>通常，如果仅有一台服务器处理所有的请求，那么服务器系统将很快变得不堪重负，为此，配备大量主机的数据中心常被用于创建强大的虚拟的服务器，一个数据中心可以有数十万台服务器，它们需要供电和维护，同时服务提供商还需要支付不断出现的互联和带宽费用，以及发送和接收到达/来自数据中心的数据。</p>
</blockquote>
<ul>
<li>应用例子：Web、FTP、Telnet和电子邮件</li>
</ul>
<h4 id="1-2-P2P结构"><a href="#1-2-P2P结构" class="headerlink" title="1.2 P2P结构"></a>1.2 P2P结构</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410165453140.png" alt="P2P"></p>
<ul>
<li><p>（几乎）无永远在线的服务器</p>
</li>
<li><p>任意端系统/节点之间可以直接通讯</p>
</li>
<li><p>每一节点既是客户端又是服务器</p>
<ul>
<li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li>
</ul>
<blockquote>
<p>比如在文件共享应用中，对等方可能通过向文件的原始拥有者发出请求而产生工作量，但是对等方也有可能通过为其他对等方传送文件而为原始拥有者分担压力。</p>
</blockquote>
</li>
<li><p>节点间接性接入网络且可能改变IP地址</p>
</li>
<li><p>优点：高度可拓展性</p>
</li>
<li><p>缺点：</p>
<ul>
<li>ISP友好。大多数住宅ISP受制于非对称带宽应用，也就是下载比上传要多得多。但是P2P视频和文件分发应用改变了从服务器到住宅ISP的上传流量，因而给ISP带来压力；</li>
<li>安全性。因为其高度的分布和开放式，P2P应用也可能给安全带来挑战；</li>
<li>激励。如何说服用户资源向应用提供带宽、存储和计算资源？这是一个问题；</li>
</ul>
</li>
<li><p>应用例子：目前，流量密集型应用都是P2P体系结构的。这些应用包括文件共享（例如BitTorrent）、协助下载（例如迅雷）、因特网电话（例如Skype）和IPTV(例如迅雷看看)。</p>
</li>
</ul>
<h4 id="1-3-混合结构"><a href="#1-3-混合结构" class="headerlink" title="1.3 混合结构"></a>1.3 混合结构</h4><ul>
<li><p>Napster</p>
<ul>
<li><p>文件传输使用P2P结构</p>
<ul>
<li>任意Peer节点之间</li>
</ul>
</li>
<li><p>文件的搜索采用C/S结构–集中式</p>
<ul>
<li>每个结点向中央服务器登记自己的资源信息</li>
<li>每个结点向中央服务器提交查询请求，查找相应资源</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210331234531220.png" alt="Napster"></p>
</li>
</ul>
</li>
<li><p>例：即时通信</p>
<ul>
<li>在线检测：集中<ul>
<li>当用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
</ul>
</li>
<li>两个用户之间聊天：P2P</li>
</ul>
</li>
</ul>
<h3 id="2-网络应用的进程间通信"><a href="#2-网络应用的进程间通信" class="headerlink" title="2 网络应用的进程间通信"></a>2 网络应用的进程间通信</h3><p>在操作系统中，实际进行通信的是进程而不是应用程序。<br>当进程运行在同一个端系统上时，它们使用进程间通信机制相互通信；而进程间通信的规则是由端系统上的操作系统确定的。<br>当进程运行在不同的端系统上时，它们通过跨越计算机网络的报文相互通信；发送进程产生报文并且向网络中发送，接收进程接收报文并对此作出响应（不响应也是一种响应）。</p>
<h4 id="2-1-进程间通信基本概念"><a href="#2-1-进程间通信基本概念" class="headerlink" title="2.1 进程间通信基本概念"></a>2.1 进程间通信基本概念</h4><ul>
<li><p>网络应用的基础：进程间通信</p>
</li>
<li><p>进程：主机上运行的程序</p>
</li>
<li><p>同一主机上运行的进程之间如何通信？</p>
<ul>
<li>进程间通信控制（由操作系统提供）</li>
</ul>
</li>
<li><p>不同主机上运行的进程间如何通信？</p>
<ul>
<li><p>按照网络应用协议进行消息交换（例如报文交换）</p>
<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
<li><p>同时使用OS提供的通信服务</p>
</li>
</ul>
</li>
<li><p>客户机进程/服务器进程</p>
<ul>
<li>客户机进程：发起通信的进程</li>
<li>服务器进程：等待通信请求的进程</li>
</ul>
<blockquote>
<p> 在P2P架构的应用中也存在客户机进程、服务器进程这样进程关系。在某些P2P应用中，一个进程可能既是客户也是服务器，因为在一个文件共享应用中，一个进程的确既能请求文件也能发送文件。所以从进程所扮演的角色来区分是客户进程还是服务器进程不够精确，所以我们从发起通信的顺序来定义它们：<strong>在给定的一对进程之间，首先发起通信的进程被标记为客户进程，在会话开始时等待联系的进程被称为服务器进程。</strong></p>
</blockquote>
</li>
</ul>
<h4 id="2-2-分布式进程间通信实现机制"><a href="#2-2-分布式进程间通信实现机制" class="headerlink" title="2.2 分布式进程间通信实现机制"></a>2.2 分布式进程间通信实现机制</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210410172627902.png" alt="分布式进程间通信"></p>
<ul>
<li><p>分布式进程间通信需要解决的问题：</p>
<ul>
<li><p>问题1：进程标示和寻址问题（服务用户） </p>
<ul>
<li>对进程进行编址：进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）<ul>
<li>主机：唯一的32位IP地址<ul>
<li>仅仅有IP地址不能够唯一标识一个进程：在一台端系统上有很多进程在运行</li>
</ul>
</li>
<li>端口号（Port Numbers）（16bit）：确定是哪一个进程</li>
<li>所采用的传输层协议：TCP or UDP<ul>
<li>常见端口号例子：<ul>
<li>HTTP：TCP 80</li>
<li>Mail：TCP 25</li>
<li>FTP：TCP 2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>一个进程：用IP+port标示 端节点(end-point)</li>
<li>本质上，一对主机进程之间的通信由2个端结点构成</li>
</ul>
</li>
<li><p>问题2：传输层-应用层提供服务是如何（服务） </p>
<ul>
<li>传输层提供的服务-应用层与传输层层间接口必须要传递的信息：<ul>
<li>要传输的报文（对本层来说：SDU）</li>
<li>谁传的：对方的应用进程的标示：IP+TCP（UDP）端口号</li>
<li>传给谁：对方的应用进程的标示：对方的IP+TCP（UDP）端口号</li>
</ul>
</li>
<li>传输层实体（TCP或者UDP实体）根据应用层传输的信息进行TCP报文段（或者UDP报文段）的封装<ul>
<li>源端口号，目标端口号等封装为报文段头部，数据等封装到报文段负载</li>
<li>并将IP地址（源IP，目标IP）往下交给IP实体，用于封装IP数据报</li>
</ul>
</li>
</ul>
<p>​    如果每次两个主机的两个特定应用程序一段时间内多次进行信息传递或者进行信息传递比较频繁，每次传递信息都需要传递自己的和对方的IP+端口号，都携带如此多信息，太繁琐易错，不便于管理。</p>
<p>​    所以在应用层和传输层之间引入了Socket，用一个本地代号来标识通信的双方（TCP）或者单方（UDP）。就像是OS打开文件返回的句柄一样，对句柄的操作，就是对文件的操作，而不用再使用这个文件的目录名、文件名。</p>
<ul>
<li><p><strong>TCP socket：</strong></p>
<p>TCP服务，两个进程之间的通信需要通信之前就建立连接<font color="#A9A9A9">(两个进程通信会持续一端时间，通信关系稳定)</font>。可以用一个整数即Socket（类似句柄）来在本地对两个应用实体之间的通信关系进行标示。这样两个应用实体之间通信时，穿过层间接口的信息就只需要包含所需传递的消息数据。</p>
<p>对于使用面向连接服务（TCP）的应用而言，TCP socket是4元组的一个具有<strong>本地意义</strong><font color="#A9A9A9">(只有本地的应用层和传输层知道)</font>的标示。4元组：源IP，源端口，目标IP，目标端口</p>
<blockquote>
<p>TCP socket唯一的指定了一个会话（两个进程之间的会话关系）</p>
<p>应用使用这个标示与远程的应用进程进行通信，不必在每个报文的发送都指定这4元组。</p>
<p>简单，便于管理；同时减少穿过层间的数据</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411094526831.png" alt="TCP socket"></p>
<ul>
<li><strong>UDP socket：</strong></li>
</ul>
<p>UDP服务，两个进程之间的通信之前无需建立连接<font color="#A9A9A9">（每个报文都是独立传输的，前后报文可能给不同的分布式进程）</font>。因此只能用一个整数表示本应用实体的标示。</p>
<p>UDP socket是2元组（源IP，源端口）的一个具有本地意义的标示。UDP套接字指定了应用所在的一个端结点（end-point）。</p>
<p>在发送数据报时，采用创建好的本地套接字（标示ID），就不必再发送每个报文中自己的ip和port。但是传输报文时，必须提供目的IP和目的端口号。接受报文的时候，传输层同样需要上传对方的IP和端口号。</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411100319390.png" alt="UDP socket"></p>
<ul>
<li><p>套接字（Socket）</p>
<ul>
<li>进程向套接字发送报文或者从套接字接受报文</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411100617644.png" alt="套接字"></p>
</li>
<li><p>传输层-应用层提供服务的：</p>
<p>位置：层间界面的SAP （TCP/IP ：socket） </p>
<p>形式：应用程序接口API （TCP/IP ：socket API）</p>
</li>
</ul>
</li>
<li><p>问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）</p>
<ul>
<li><p>定义应用层协议，协议定义了运行在不同端系统上的应用进程如何相互交换报文</p>
<ul>
<li>交换报文类型：请求和应答报文</li>
<li>各种报文类型的语法：报文中的各字段及其描述</li>
<li>字段的语义：即字段取值的含义</li>
<li>进程何时、如何发送报文及对报文进行响应的规则</li>
</ul>
<blockquote>
<p>应用协议仅是应用的一个组成部分。例如：web应用包含了HTTP协议，web客户端，web服务器，HTML等</p>
</blockquote>
<blockquote>
<p>实体：仅仅和网络交互有关的、遵守协议的且是运行中的软件模块和硬件模块被称为实体。</p>
</blockquote>
<blockquote>
<p>公开协议：</p>
<p>​    由RFC文档定义</p>
<p>​    允许互操作</p>
<p>​    如HTTP，SMTP</p>
<p>专用（私有）协议：</p>
<p>​    协议不公开，如：Skype</p>
</blockquote>
</li>
<li><p>编制程序，使用OS提供的API ，调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等；</p>
<ul>
<li>传输基础设施向进程提供API<ul>
<li>传输协议的选择</li>
<li>参数的设置<h3 id="3-Internet传输层服务模型"><a href="#3-Internet传输层服务模型" class="headerlink" title="3 Internet传输层服务模型"></a>3 Internet传输层服务模型</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>问题4：应用需要传输层提供什么样的服务？如何描述传输层的服务？</p>
<h4 id="3-1-描述传输层指标"><a href="#3-1-描述传输层指标" class="headerlink" title="3.1 描述传输层指标"></a>3.1 描述传输层指标</h4><ul>
<li>数据丢失率<ul>
<li>有些应用（如音频）能容忍一定比例以下的数据丢失</li>
<li>有些应用则要求100%的可靠数据传输（如文件）</li>
</ul>
</li>
<li>延迟<ul>
<li>一些应用出于有效性的考虑，对数据传输有严格的时间限制<ul>
<li>Internet电话、交互式游戏</li>
</ul>
</li>
</ul>
</li>
<li>吞吐<ul>
<li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li>
</ul>
</li>
<li>一些应用能充分利用可供使用的吞吐（弹性应用）</li>
<li>安全性</li>
<li>机密性   完整性   可认证性（鉴别）</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411102836028.png" alt="常见应用对传输服务的要求"></p>
<h4 id="3-2-Internet传输层提供什么样的服务？"><a href="#3-2-Internet传输层提供什么样的服务？" class="headerlink" title="3.2 Internet传输层提供什么样的服务？"></a>3.2 Internet传输层提供什么样的服务？</h4><ul>
<li>TCP服务：<ul>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接收方</li>
<li>拥塞控制：当网络出现拥塞时，能抑制发送方</li>
<li>不能提供的服务：时间保证、最小吞吐保证和安全保证</li>
<li>面向连接：要求通信前在客户端进程和服务器进程之间建立连接。（仅在端系统实现连接，而不对网络核心提供服务和维护）</li>
</ul>
</li>
<li>UDP服务<ul>
<li>不可靠数据传输</li>
<li><strong>不</strong>提供的服务：可靠，流量控制，拥塞控制，时间，带宽保障，建立连接</li>
<li>为什么要有UDP？（UDP存在的必要性）<ul>
<li>能够区分不同的进程，而IP服务不能</li>
<li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li>
<li>无需建立连接，省去了建立连接时间，适合事务性的应用</li>
<li>不做可靠性的工作，例如检错重发，适合那些对实时 性要求比较高而对正确性要求不高的应用<ul>
<li> 因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发等）</li>
</ul>
</li>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据 <ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411103950494.png" alt="Internet应用及其应用层协议和传输协议"></li>
<li>安全TCP<blockquote>
<p>TCP和UDP都没有加密，明文通过互联网传输信息，甚至密码，安全性很低</p>
</blockquote>
<ul>
<li>SSL<pre><code>在TCP之上实现，提供加密的TCP连接。保证私密性。数据完整性以及端到端的鉴别。
SSL在应用层中：应用采用SSL库形式与应用一起运行，然后SSL库使用TCP通信
SSL socket API：应用通过API将明文交给socket，SSL将其加密后在互联网传输
</code></pre>
<blockquote>
<p>例如https，HTTP协议运行在SSL之上，SSL运行在TCP协议之上，实现了web应用的安全可靠传输。</p>
</blockquote>
</li>
</ul>
<img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411132650541.png" alt="进程、SSL与TCP关系"></li>
</ul>
</li>
</ul>
<h3 id="4-特定网络应用以及协议"><a href="#4-特定网络应用以及协议" class="headerlink" title="4 特定网络应用以及协议"></a>4 特定网络应用以及协议</h3><h4 id="4-1-Web与HTTP"><a href="#4-1-Web与HTTP" class="headerlink" title="4.1 Web与HTTP"></a>4.1 Web与HTTP</h4><ul>
<li><p>一些术语：</p>
<ul>
<li>web页：由一些对象组成</li>
</ul>
<blockquote>
<p>web页含有一个基本的HTML文件，该基本HTML文件本身就是一个对象，其中还包含其他对象的引用（以链接URL的形式）</p>
</blockquote>
<ul>
<li><p>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</p>
</li>
<li><p>通过URL对每个对象进行引用</p>
<ul>
<li><p>每个对象都有唯一的URL进行标识</p>
</li>
<li><p>访问协议：用户名、口令字、端口等</p>
</li>
<li><p>URL格式：<img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411112003845.png" alt="URL格式"></p>
<ul>
<li><p>协议名：以什么协议来访问对象（HTTP/FTP等）</p>
</li>
<li><p>用户:口令：访问对象用什么用户:口令访问</p>
<blockquote>
<p>有的网站支持匿名访问，无需提供用户:口令</p>
</blockquote>
</li>
<li><p>端口：如果未指定端口，会采用协议的默认端口号（如HTTP的默认端口80）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-1-HTTP概况"><a href="#4-1-1-HTTP概况" class="headerlink" title="4.1.1 HTTP概况"></a>4.1.1 HTTP概况</h5><ul>
<li><p>HTTP ：超文本传输协议</p>
<ul>
<li>Web的应用层协议</li>
<li>客户/服务器模式<ul>
<li>客户：请求、接受和显示Web对象的浏览器</li>
<li>服务器：对请求进行响应，发送对象的Web服务器</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411131620123.png" alt="HTTP协议"></p>
<ul>
<li><p>HTTP 1.0 ：RFC 1945</p>
<p>HTTP 1.1 ：RFC 2068</p>
</li>
<li><p>使用TCP</p>
<ol>
<li>客户发起一个与服务器的TCP连接（建立socket），端口号为80</li>
<li>服务器接受客户的TCP连接</li>
<li>在浏览器（HTTP客户端）与Web服务器（HTTP服务器server）交换HTTP报文（应用层协议报文）</li>
<li>TCP连接关闭</li>
</ol>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411134148359.png" alt="HTTP建立连接示意图"></p>
</li>
<li><p>HTTP是无状态的</p>
<ul>
<li>服务器并不维护关于客户的任何信息，即交换过HTTP报文以后就断开TCP连接，不会存储客户信息，客户之后对报文更改与服务器无关</li>
<li>优点：简单；无状态的服务器能够支持更多的客户端</li>
</ul>
<blockquote>
<p>维护状态的协议很复杂！</p>
<ul>
<li>必须维护历史信息（状态）</li>
<li>如果服务器/客户端死机，它们的状态信息可能不一致，而必须维护成信息一致的</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-2-HTTP连接"><a href="#4-1-2-HTTP连接" class="headerlink" title="4.1.2 HTTP连接"></a>4.1.2 HTTP连接</h5><ul>
<li><p>非持久HTTP</p>
<ul>
<li>每个TCP连接在服务器最多发送一个对象后就会关闭，也就是每个TCP只传送一个请求报文和响应报文</li>
<li>下载多个对象需要多个TCP连接</li>
<li>HTTP/1.0使用非持久连接</li>
</ul>
<p>假设用户输入URL:<a target="_blank" rel="noopener" href="http://www.someschool.edu/someDept/home.index">www.someSchool.edu/someDept/home.index</a>  (假设这个web中包含文本和10个jpeg图像的引用)</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411140316400.png" alt="非持久HTTP"></p>
<ul>
<li><p>响应时间模型</p>
<ul>
<li>往返时间RTT（round-trip-time）</li>
</ul>
<p>一个小的分组从客户端到服务器，再回到客户端的时间（RTT包括分组的传播时延、排队时延、处理时延（因为是短分组，所以其传输时延可不计））</p>
<ul>
<li>响应时间：<ul>
<li>一个RTT用来发起TCP连接</li>
<li>一个RTT用来HTTP请求并等待HTTP响应</li>
<li>文件传输时间</li>
<li>共2RTT+传输时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411140846744.png" alt="响应时间模型"></p>
<ul>
<li>非持久HTTP的缺点：<ul>
<li>每个对象传输要2个RTT+传输时间</li>
<li>操作系统必须为每个TCP连接分配资源</li>
<li>但浏览器通常打开并行TCP连接，以获取引用对象</li>
</ul>
</li>
</ul>
</li>
<li><p>持久HTTP</p>
<ul>
<li>服务器在发送响应后，仍保持TCP连接；在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li>
<li>多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</li>
<li>HTTP/1.1默认使用持久连接</li>
<li>持久HTTP分为非流水方式的持久HTTP和流水方式的持久HTTP<ul>
<li>非流水方式（no-pipeline）的持久HTTP<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求</li>
<li>每个引用对象花费一个RTT</li>
</ul>
</li>
<li>流水方式（pipeline）的持久HTTP、<ul>
<li>HTTP/1.1的默认方式</li>
<li>客户端遇到一个引用对象就立即产生一个请求</li>
<li>所以引用（小）对象只花费一个RTT是可能的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-3-HTTP报文格式：请求报文和响应报文"><a href="#4-1-3-HTTP报文格式：请求报文和响应报文" class="headerlink" title="4.1.3 HTTP报文格式：请求报文和响应报文"></a>4.1.3 HTTP报文格式：请求报文和响应报文</h5><ul>
<li><p>两种类型的HTTP报文：请求、响应</p>
</li>
<li><p>HTTP请求报文：</p>
<ul>
<li><p>ASCII    -具有可读性</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411143216745.png" alt="HTTP请求报文"></p>
<ul>
<li><p>一个请求报文具有至少一行的内容。请求报文的第一行称为请求行，其后继的各行被称为首部行。</p>
</li>
<li><p>请求行包含三个内容：方法字段、URL字段、HTTP版本；其中方法字段可为：GET、POST、PUT、DELETE、HEAD等。URL字段里可以传递请求对象的标志。</p>
</li>
<li><p>首部行包含是否在发送完响应报文后关闭TCP连接的Connection、请求的主机地址（该头部信息被Web高速缓存所要求）Host、客户端用户代理（浏览器）版本User-agent、可接受的语言Accept-language等头部信息；</p>
</li>
<li><p>在首部行之后一个空行，之后便是请求的“实体体”。</p>
<blockquote>
<p>该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等。</p>
<p>值得注意的是，表单也不一定必须使用POST方法。</p>
<ul>
<li>方法类型：</li>
</ul>
<p>HTTP/1.0 : GET、POST、HEAD</p>
<p>HTTP/1.1 : GET、POST、HEAD、PUT、DELETE</p>
<p>get，实体主体为空，上载内容会显示在URL的参数中。服务器将会用一个HTTP响应报文进行响应，报文中包含请求的对象。</p>
<p>Head类似于get方法，服务器将会用一个HTTP报文进行响应，但是不返回请求对象，经常用作调试跟踪。</p>
<p>put方法允许用户上传对象到URL指定的Web服务器上指定的路径。</p>
<p>Delete方法允许用户或应用程序删除URL指定的Web服务器上的对象。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411144156506.png" alt="请求报文格式"></p>
<ul>
<li>HTTP请求报文也可向服务器提交内容，提交表单输入有如下两种方式：<ul>
<li>Post方式<ul>
<li>网页通常包括表单输入</li>
<li>提交的内容包含在实体体（entity body）中，然后被提交到服务器</li>
</ul>
</li>
<li>URL方式<ul>
<li>方法：GET</li>
<li>表单输入通过请求行的URL字段上载</li>
<li>例如：<a target="_blank" rel="noopener" href="http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3%E9%80%9A%E8%BF%87URL%E4%B8%AD%E7%9A%84">http://www.baidu.com/s?wd=xx+yy+zzz&amp;cl=3通过URL中的</a> 参数：wd，cl 参数值：XX+YY+zzz，3 形式信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP响应报文</p>
<ul>
<li><p>ASCII    -具有可读性</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411145603153.png" alt="HTTP响应报文"></p>
<ul>
<li><p>响应报文总体上也分三个部分，第一部分是状态行，包含HTTP版本、状态以及状态信息等内容；第二部分是首部行，包含发送日期、服务器类型、上一次修改请求资源的时间、内容的长度和内容的类型等内容。第三部分是实体主体。实体主体包含请求对象本身。</p>
</li>
<li><p>首部行中的内容的长度是用于描述HTTP消息实体的传输长度，为了让应用层区分报文的边界</p>
<blockquote>
<p>因为TCP向上层应用层传递的是字节流，是不区分边界的，因此应用层要通过Content-Length来维护报文的界限</p>
</blockquote>
</li>
<li><p>首部行的Date是从文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。</p>
</li>
<li><p>HTTP响应状态码：位于服务器→客户端的响应报文中的首行</p>
</li>
</ul>
<blockquote>
<p>一些状态码的例子：</p>
<p>200 OK </p>
<p>&emsp;请求成功，请求对象包含在响应报文的后续部分 </p>
<p>301 Moved Permanently </p>
<p>&emsp;请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定</p>
<p>&emsp;客户端软件自动用新的URL去获取对象 </p>
<p>400 Bad Request </p>
<p>&emsp;一个通用的差错代码，表示该请求不能被服务器解读 </p>
<p>404 Not Found</p>
<p>&emsp;请求的文档在该服务上没有找到 </p>
<p>505 HTTP Version Not Supported</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-4-用户与服务器的交互：Cookie"><a href="#4-1-4-用户与服务器的交互：Cookie" class="headerlink" title="4.1.4 用户与服务器的交互：Cookie"></a>4.1.4 用户与服务器的交互：Cookie</h5><ul>
<li><p>HTTP是无状态协议，但是Web站点为了识别用户身份或者限制用户访问的时间或者将用户访问的内容同用户身份相关联，Web站点可以使用Cookie技术实现用户信息存储。</p>
</li>
<li><p>Cookie技术包含4个组成部分</p>
<ol>
<li>HTTP响应报文里增加一个关于Cookie的首部行；</li>
<li>HTTP请求报文里增加一个关于Cookie的首部行；</li>
<li>用户端系统中保留一个Cookie文件，由用户的浏览器维护和管理；</li>
<li>在Web站点后端数据库建立Cookie和用户身份的关联；</li>
</ol>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411161744290.png" alt="Cookies:维护状态"></p>
<blockquote>
<p>用户首次访问web服务器时，HTTP请求报文中无Cookie，在访问时，服务器会为用户建立Cookie，然后响应报文中首部行会有Cookie标示内容，用户收到响应报文后，用户浏览器会将cookie保存在本地cookies文件中，然后之后用户再次HTTP请求报文都会携带有cookie。</p>
</blockquote>
</li>
<li><p>Cookies能带来功能：</p>
<ul>
<li>用户验证</li>
<li>购物车</li>
<li>推荐</li>
<li>用户状态（Web e-mail）等</li>
</ul>
</li>
<li><p>如何维护状态：</p>
<ul>
<li>协议端节点：在多个事物上，发送端和接收端维持状态</li>
<li>cookies：HTTP报文携带状态信息</li>
</ul>
</li>
<li><p>Cookies的隐私泄露问题：</p>
<ul>
<li>Cookies允许站点知道许多关于用户的信息，站点可能将它知道的东西卖给第三方</li>
<li>使用重定向和cookie的搜索引擎还能知道用户更多的信息<ul>
<li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li>
</ul>
</li>
<li>广告公司从站点获得信息</li>
</ul>
</li>
</ul>
<h5 id="4-1-5-Web缓存（代理服务器）"><a href="#4-1-5-Web缓存（代理服务器）" class="headerlink" title="4.1.5 Web缓存（代理服务器）"></a>4.1.5 Web缓存（代理服务器）</h5><p>Web缓存器也被称为代理服务器，它代表初始web服务器来满足HTTP请求。它具有自己的存储空间，并在存储空间里保持有最近请求过的对象的副本；可以通过配置浏览器，将所有指向初始服务器的请求首先指向代理服务器。</p>
<p>当代理服务器收到一个HTTP请求后，它将检查本地是否缓存过该对象，如果缓存过该对象，将检查是否过期，如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p>
<ul>
<li>目标：不访问原始服务器，就满足客户的请求</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163153908.png" alt="代理服务器示意图"></p>
<ul>
<li><p>Web缓存既是客户端又是服务器</p>
</li>
<li><p>通常缓存是由ISP安装（大学、公司、居民区ISP）</p>
</li>
<li><p>Web缓存优点：</p>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internet接入链路上的流量，减少原始服务器负担</li>
<li>互联网大量使用了缓存，可以使较弱的ICP也能够有效提供内容</li>
</ul>
</li>
<li><p>缓存示例：</p>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163746751.png" alt="正常情况"></p>
<blockquote>
<p>接入链路流量强度接近于1，所以排队延迟（d<sub>queue</sub> = (I/(1-I))*(L/R)）将会很大，用户访问的时间因此而很大。</p>
</blockquote>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163945732.png" alt="更快的接入链路"></p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411163959897.png" alt="安装本地缓存1"></p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411164018449.png" alt="安装本地缓存2"></p>
<h5 id="4-1-6-条件GET方法"><a href="#4-1-6-条件GET方法" class="headerlink" title="4.1.6 条件GET方法"></a>4.1.6 条件GET方法</h5><p>高速缓存器的使用，带来很多好处，但是有一个问题就是代理服务器对缓存对象的管理：如何确保所请求的对象是最新的？</p>
<p>其实HTTP提供了一种机制，允许缓存器证实其使用的对象是最新的，这种机制就是条件GET方法。</p>
<p>使用条件GET方法只需在使用GET方法的时候，增加一个If-Modified-Since首部行，其对应的内容是一个时间，如果所请求的资源在指定日期后(与Last-Modified比较)被修改了，那么服务器将返回新的对象，否则服务器将返回一个包含空实体主体的报文。这样代理服务器就可以确认缓存是否过期了。</p>
<ul>
<li>目标：即时更新缓存中的对象拷贝。<ul>
<li>如果缓存拷贝需要更新，返回 HTTP/1.0  200  OK，实体主体中包含对象</li>
<li>如果缓存拷贝不需要更新，则返回HTTP/1.0  304  Not Modified，且实体主体中不包含对象</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411165916546.png" alt="条件Get方法"></p>
<h4 id="4-2-FTP：文件传输协议"><a href="#4-2-FTP：文件传输协议" class="headerlink" title="4.2 FTP：文件传输协议"></a>4.2 FTP：文件传输协议</h4><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411194534840.png" alt="FTP"></p>
<ul>
<li>FTP应用包括FTP用户接口、FTP客户端、本地文件系统、界面等。而FTP服务器有服务器的文件系统，守候在21号端口，等待连接。</li>
<li>FTP协议中，用户通过FTP客户端可以向远程主机上传输文件或从远程主机接受文件</li>
<li>客户/服务器模式<ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>FTP：RFC 959</li>
<li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议<ul>
<li>客户端通过控制连接获得身份确认</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
</ul>
</li>
<li>但是，当服务器收到一个文件传输命令时，服务器打开第二个TCP数据连接（服务器20号端口到客户端的数据连接）来传输文件。</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411202825985.png" alt="FTP端口连接"></p>
<ul>
<li><p>控制连接：带外（out of band）传送</p>
</li>
<li><p>FTP带内是传输数据的（20号端口），带外是传送控制信号（21号端口）</p>
</li>
<li><p>FTP是有状态的协议</p>
<ul>
<li>FTP服务器维护用户的状态信息：当前路径、用户账户与控制连接对应</li>
</ul>
</li>
<li><p>FTP命令、响应都是ASCII文本形式</p>
<ul>
<li>FTP命令：在控制连接上以ASCII文本方式传送</li>
</ul>
<blockquote>
<p>USER username</p>
<p>PASS password </p>
<p>LIST：请服务器返回远程主机当前目录的文件列表 </p>
<p>RETR filename：从远程主机的当前目录检索文件 (gets) </p>
<p>STOR filename：向远程主机的当前目录存放文件(puts)</p>
</blockquote>
<blockquote>
<p>注：</p>
<p>上载：客户端向服务器发数据</p>
<p>下载：服务器向客户端发数据</p>
</blockquote>
<ul>
<li>返回码：</li>
</ul>
<blockquote>
<p>状态码和状态信息（同HTTP）</p>
<p>331 Username OK,  password required </p>
<p>125 data connection  already open;  transfer starting </p>
<p>425 Can’t open data  connection </p>
<p>452 Error writing  file</p>
</blockquote>
</li>
</ul>
<h4 id="4-3-EMail"><a href="#4-3-EMail" class="headerlink" title="4.3 EMail"></a>4.3 EMail</h4><ul>
<li><p>email的3个主要组成部分：</p>
<ul>
<li><p>用户代理</p>
<ul>
<li>又名“邮件阅读器”</li>
<li>撰写、编辑和阅读邮件，如Outlook、Foxmail等</li>
<li>输出和输入邮件保存在服务器上</li>
</ul>
</li>
<li><p>邮件服务器</p>
<ul>
<li>邮件服务器中输出报文队列保存并依此发送待发送邮件报文</li>
<li>邮箱中管理和维护发送给用户的邮件</li>
<li>邮件服务器之间的SMTP协议：发送Email报文<ul>
<li>客户端：发送方邮件服务器</li>
<li>服务器：接受方邮件服务器</li>
</ul>
</li>
</ul>
<blockquote>
<p>一封邮件发送过程：<br>用户通过用户代理撰写邮件，然后通过用户代理经SMTP协议发送邮件到邮件服务器中的输出邮件队列中。该服务器作为发送方邮件服务器，通过SMTP协议找到并将邮件接收方邮件服务器。接受方服务器将接受到的邮件放到服务器中相应用户邮箱中，目标用户再经用户代理通过拉取邮件的协议（POP3等）拉取邮箱中自己收到的邮件。</p>
</blockquote>
<blockquote>
<p>用户代理向服务器发邮件，用户是client，邮件服务器是sever。</p>
<p>发送方邮件服务器向接收方邮件服务器发邮件，发送方邮件服务器是client，接收方邮件服务器是sever。</p>
</blockquote>
<blockquote>
<p>发送方的邮件服务器必须能处理接收方服务器的故障，如果发送方的服务器不能将邮件交付给接收方的服务器，发送方将在一个报文队列中保持该邮件并之后再尝试发送报文，如果一直失败，服务器就会删除该邮件，并以邮件方式通知发送用户。</p>
</blockquote>
</li>
<li><p>简单邮件传输协议：SMTP</p>
<ul>
<li><p>SMTP使用TCP在客户端和服务器之间传送报文，端口号为25</p>
</li>
<li><p>SMTP为直接传输：从发送方服务器到接收方服务器，邮件并不在中间的某个服务器停留</p>
</li>
<li><p>传输的3个阶段：</p>
<ul>
<li>握手</li>
<li>持续传输报文</li>
<li>关闭</li>
</ul>
<blockquote>
<p>SMTP是持续连接：如果发送邮件服务器有多个邮件，它可以通过同一TCP连接连续发送这些邮件。</p>
</blockquote>
<blockquote>
<p>所以邮件有时是先存储在发送队列的，等到多个邮件一起传递，以此来减少服务器耗能等。</p>
</blockquote>
</li>
<li><p>命令/响应交互</p>
</li>
<li><p>命令：ASCII文本</p>
</li>
</ul>
</li>
<li><p>响应：ASCII   状态码和状态信息</p>
</li>
<li><p>SMTP要求报文（首部和主体）必须为7位ASCII码</p>
<blockquote>
<p>命令、响应和邮件本身的内容的组成字符必须是在7位ASCII码字符集描述的范围之内的。超过7位ASCII码字符集表示的范围的数据不能通过SMTP传输。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>这将限制SMTP的数据传输，即在SMTP传输邮件之前，需要将二进制多媒体数据编码为ASCII码，并且在使用SMTP传输后要求将相应ASCII码邮件解码还原成多媒体数据。HTTP传输不需要将多媒体数据编码成ASCII码。</p>
</blockquote>
<ul>
<li>SMTP服务器使用CRLF.CRLF决定报文的尾部<img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210411205241273.png" alt="EMail原理"></li>
<li>SMTP与HTTP比较：<ul>
<li>HTTP：拉（pull） SMTP：推（push）</li>
<li>两者都是ASCII形式的命令、响应交互、状态码</li>
</ul>
<blockquote>
<p>但是传输的内容，HTTP可以不一定是用ASCII码，而SMTP只能用ASCII码字符。</p>
</blockquote>
<ul>
<li>HTTP：每个对象封装在各自的响应报文中，一个响应报文只能有一个对象</li>
<li>SMTP：多个对象包含在一个报文中</li>
</ul>
<blockquote>
<p>解释：</p>
<p>例如一个web页面对象，其中有多个对象（图片等）的引用，HTTP的一个响应报文中只有这一个web页面对象的数据，其他对象需要通过引用再去经过各自的响应报文传递过来。</p>
<p>而如果是一个邮件，其中有图片、音频等多个对象，SMTP将会将这个邮件的所有内容包含到同一个报文中，一次传递过来。</p>
</blockquote>
<ul>
<li><p>SMTP：交换Email报文的协议     </p>
</li>
<li><p>RFC 822：邮件内容文本报文的标准：</p>
<ul>
<li><p>首部行：包含</p>
<ul>
<li>To:           发送给谁<ul>
<li>From:      来自谁</li>
</ul>
</li>
<li>Subject:   主题</li>
<li>还有 cc  （抄送）等</li>
</ul>
</li>
<li><p>主体</p>
<ul>
<li>报文，只能是ASCII码字符<blockquote>
<p>这个是邮件报文内容的格式，与SMTP命令格式不同</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多媒体拓展的报文格式</p>
<ul>
<li><p>MIME：多媒体邮件扩展（multimedia mail extension）   RFC  2045，2056</p>
<blockquote>
<p>用来拓展SMTP传输内容，使得SMTP能够传输ASCII码字符之外的字符。</p>
</blockquote>
<ul>
<li>在报文首部用额外的行声明MIME内容类型</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210412145320300.png" alt="MIME"></p>
<blockquote>
<p>将不在ASCII码值的内容用规定的格式（如base64）编码为较长的7位ASCII码值，然后通过SMTP传送。接受端受到该数据后再经过解码，获得原来的数据，以此实现拓展ASCII码传输内容。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>EMail协议</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210412145541524.png" alt="Email协议"></p>
<ul>
<li><p>发送的协议：简单邮件传输协议：SMTP</p>
<blockquote>
<p>用户代理到发送方邮件服务器</p>
<p>发送方邮件服务器传送到接受方的邮件服务器</p>
</blockquote>
</li>
<li><p>拉取的协议：POP3，IMAP，HTTP   </p>
<blockquote>
<p>用于邮件访问</p>
</blockquote>
</li>
</ul>
</li>
<li><p>邮件访问协议</p>
<ul>
<li>邮件访问协议：从服务器访问邮件<ul>
<li>POP：邮局访问协议（Post Office Protocol）[RFC 1939]<ul>
<li>用户身份确认 (代理&lt;–&gt;服务器) 并下载</li>
</ul>
<blockquote>
<p>POP3是一个非常简单的协议，因为简单，所以功能有限；POP3使用端口110来建立TCP连接（SMTP使用端口25）；POP3按照三个阶段进行工作：特许、事务处理和更新；在特许阶段，用户代理发送密码和用户名，进行身份鉴别；第二阶段，用户代理取回报文，同时还可以做删除、取消删除等标记或者统计邮件信息；第三个阶段是在用户退出后，POP3结束会话，删除被标记的邮件。</p>
</blockquote>
</li>
<li>IMAP：Internet邮件访问协议（Internet Mail Access  Protocol）[RFC 1730] <ul>
<li><p>与POP3类似作用，但是多了更多特性 (更复杂) </p>
<blockquote>
<p>POP3协议无法为用户提供邮件分类管理的功能，虽然用户可以通过将邮件下载到本地，然后由用户代理程序做分类管理，但是处理的结果是无法同步到其他查看设备上的。为了解决这一问题，IMAP诞生了。IMAP是一个邮件访问协议，比POP3要复杂的多。</p>
<p>（远程）IMAP将每一份邮件和一个一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX相关联。收件人可以将邮件移到新创建的文件夹，阅读邮件，删除邮件等。IMAP允许用户在不同文件夹里移动邮件并且查询邮件。</p>
<p>值得注意的是，IMAP服务器维护了IMAP会话的用户状态信息（目录名、报文ID与目录名之间映射等状态信息），但是POP3并不在会话时维护状态信息。</p>
<p>IMAP协议还允许用户代理获取报文组件而不是报文整体。</p>
</blockquote>
</li>
<li><p>在服务器上处理存储的报文</p>
</li>
</ul>
</li>
<li>HTTP：Hotmail , Yahoo! Mail等 <ul>
<li>方便</li>
</ul>
<blockquote>
<p>这种方式主要是指，用户使用HTTP协议和邮件服务器通信。用户代理就是普通的浏览器，但是，邮件服务器之间还是使用SMTP协议的</p>
</blockquote>
</li>
</ul>
</li>
<li>POP3协议<ul>
<li><p>用户确认阶段 </p>
<ul>
<li>客户端可发出命令： <ul>
<li>user: 申明用户名</li>
<li>pass: 口令 </li>
</ul>
</li>
<li>服务器响应 <ul>
<li>+OK</li>
<li>-ERR </li>
</ul>
</li>
</ul>
</li>
<li><p>事物处理阶段, </p>
<ul>
<li>客户端可以发送以下命令： <ul>
<li><p>list: 报文号列表 </p>
</li>
<li><p>retr: 根据报文号检索报文 </p>
</li>
<li><p>dele: 删除 </p>
<blockquote>
<p>一个需要注意的是，POP3用户代理可以使用两种事务处理模式：一种是下载并删除，另一种是下载保留；POP3代理发出的命令和其工作模式相关；下载并删除的方法存在的问题是，如果用户在一台设备上查看了邮件（下载了邮件）后，邮件将被删除，那么在其他设备上将无法查看邮件；这给用户带来一定的不便。使用下载保存方式，则用户下载邮件后，邮件还在服务器上。</p>
</blockquote>
</li>
<li><p>quit</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>POP3在会话中是无状态的</p>
<blockquote>
<p>POP3只是维护用户谁登录了，需要获取哪些邮件，而不会维护用户对邮件目录等操作的状态。</p>
</blockquote>
<blockquote>
<p>在用户代理与邮箱服务器之间的POP3会话期间，该POP3服务器保留了一些状态信息，特别是标记了哪些用户报文被标记为删除了。但是POP3服务器并不在POP3会话过程中去携带和实现状态信息，大大简化了POP3的服务。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-4-DNS（Domain-Name-System）"><a href="#4-4-DNS（Domain-Name-System）" class="headerlink" title="4.4 DNS（Domain Name System）"></a>4.4 DNS（Domain Name System）</h4><ul>
<li><p>提供给应用使用的应用</p>
</li>
<li><p>DNS的必要性 </p>
<ul>
<li><p>IP地址标识某一时刻网络中唯一的主机、路由器，但IP地址不好记忆，不便人类使用(没有意义)，人类一般倾向于使用一些有意义的字符串来标识 Internet上的设备。 </p>
<blockquote>
<p>例如：<a href="mailto:&#113;&#122;&#x68;&#101;&#x6e;&#x67;&#x40;&#117;&#115;&#116;&#99;&#x2e;&#x65;&#100;&#117;&#x2e;&#99;&#x6e;">&#113;&#122;&#x68;&#101;&#x6e;&#x67;&#x40;&#117;&#115;&#116;&#99;&#x2e;&#x65;&#100;&#117;&#x2e;&#99;&#x6e;</a> 所在的邮件服务器<br> <a target="_blank" rel="noopener" href="http://www.ustc.edu.cn/">www.ustc.edu.cn</a> 所在的web服务器 </p>
</blockquote>
</li>
<li><p>存在着“字符串”—IP地址的转换的必要性</p>
</li>
<li><p>DNS提供的主要服务：人类用户提供要访问机器的“字符串”名称，然后由DNS负责转换成为二进制的网络地址</p>
</li>
</ul>
<blockquote>
<p>DNS通常被其他应用层协议使用，比如：HTTP、SMTP和FTP等。这些协议在正式工作以前，首先利用DNS提供的服务，将主机名转换为IP地址，可以发现的是，DNS为用户带来方便的同时，也为网络应用带来额外的时延——查询DNS服务器的时延。</p>
</blockquote>
</li>
<li><p>DNS系统需要解决的问题 </p>
<ul>
<li><p>问题1：如何命名设备？</p>
<ul>
<li>用有意义的字符串：好记，便于人类使用</li>
<li>解决一个平面命名的重名问题：采用层次化命名方式</li>
</ul>
<blockquote>
<p>一个平面进行命名会出现问题：设备越来越多，不重复的命名越来越难实现</p>
</blockquote>
</li>
<li><p>问题2：如何完成名字到IP地址的转换？ </p>
<ul>
<li>一台设备集中解决域名到IP地址转换实际上难以实现，因为服务器负载有限，易出现错误。所以采用分布式的数据库维护和响应名字查询。</li>
</ul>
</li>
<li><p>问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作？</p>
</li>
</ul>
</li>
<li><p>DNS 的历史</p>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413165837322.png" alt="ARP ANET"></p>
<ul>
<li><p>DNS的主要思路</p>
<ul>
<li><p>分层的、基于域的命名机制</p>
</li>
<li><p>若干分层的DNS服务器组成的分布式数据库完成名字到IP地址的转换</p>
</li>
<li><p>运行在UDP之上端口号为53的应用服务</p>
<blockquote>
<p>采用UDP原因：DNS只是需要通过域名查询相应的IP地址，采用TCP需要耗费很长时间进行建立联系。</p>
</blockquote>
</li>
<li><p>DNS属于Internet的核心功能，但以端系统的应用层协议实现的</p>
<ul>
<li>Internet在网络边缘处理互联网的复杂功能</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS主要目的：</p>
<ul>
<li><p>实现主机域名-IP地址的转换(name/IP translate) </p>
</li>
<li><p>其它目的 </p>
<ul>
<li>主机别名到规范名字的转换：Host aliasing </li>
</ul>
<blockquote>
<p>应用服务（例如某一域名<a href="http://www.xxx.com）往往是大量的服务器进行提供维护，对于每一台服务器都有一个规范的主机名来标识，例如：某一地点的某一机房的某一机柜的某一刀片服务器+该域名，为了便于使用，这大量的服务器都被称为www.xxx.com，这个就是主机别名。">www.xxx.com）往往是大量的服务器进行提供维护，对于每一台服务器都有一个规范的主机名来标识，例如：某一地点的某一机房的某一机柜的某一刀片服务器+该域名，为了便于使用，这大量的服务器都被称为www.xxx.com，这个就是主机别名。</a></p>
<p>规范主机名为了便于管理，而主机别名是为了便于访问。</p>
</blockquote>
<blockquote>
<p>所以DNS往往是实现：主机别名转换为规范主机名再到IP地址的转换</p>
</blockquote>
<ul>
<li>邮件服务器别名到邮件服务器的正规名字的转换：Mail server  aliasing </li>
</ul>
<blockquote>
<p>DNS同样也提供邮件服务器主机名和别名的转换服务，实际上，公司的邮件服务器和Web服务器（如<a target="_blank" rel="noopener" href="http://www.xxx.com)可以使用相同的主机别名,就可以使用该公司域名来作为邮件服务器地址(www.xxx.com);mx记录允许一个公司的邮件服务器和web服务器使用相同的主机名./">www.xxx.com）可以使用相同的主机别名，就可以使用该公司域名来作为邮件服务器地址（www.xxx.com）；MX记录允许一个公司的邮件服务器和Web服务器使用相同的主机名。</a></p>
</blockquote>
<ul>
<li>负载均衡：Load Distributio</li>
</ul>
<blockquote>
<p>应用服务（例如某一域名<a target="_blank" rel="noopener" href="http://www.xxx.com)往往是大量的服务器进行提供维护,这些服务器都使用同一个主机别名(www.xxx.com),然后该域名收到请求以后,dns将会按照一定原则和依据将任务分配给这些服务器中的一台服务器来提供服务,从而达到负载均衡./">www.xxx.com）往往是大量的服务器进行提供维护，这些服务器都使用同一个主机别名（www.xxx.com），然后该域名收到请求以后，DNS将会按照一定原则和依据将任务分配给这些服务器中的一台服务器来提供服务，从而达到负载均衡。</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>问题1：DNS名字空间</p>
<ul>
<li><p>DNS域名结构</p>
<ul>
<li><p>一个层面命名设备会有很多重名</p>
</li>
<li><p>NDS采用层次树状结构的命名方法实现DNS域名命名</p>
</li>
<li><p>Internet 根被划为几百个顶级域(top lever domains) </p>
<ul>
<li><p>通用的(generic)</p>
<p> .com; .edu ; .gov ; .int ; .mil ; .net ; .org .firm ; .hsop ; .web ; .arts ; .rec ; </p>
</li>
<li><p>国家的(countries) </p>
</li>
</ul>
<p>.cn ; .us ; .nl ; .jp </p>
</li>
<li><p>每个(子)域下面可划分为若干子域(subdomains) </p>
</li>
<li><p>树叶是主机</p>
</li>
<li><p>根名字服务器有13个</p>
</li>
</ul>
<blockquote>
<p>如果只有一个，可能出现一个宕机，整个DNS不能使用</p>
</blockquote>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413183435963.png" alt="DNS根名字服务器"></p>
<ul>
<li>DNS域名结构</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413183541230.png" alt="DNS名字空间"></p>
<ul>
<li><p>域名(Domain Name)</p>
<ul>
<li><p>从本域往上，直到树根</p>
</li>
<li><p>中间使用“.”间隔不同的级别</p>
<blockquote>
<p>例如: ustc.edu.cn   auto.ustc.edu.cn        <a target="_blank" rel="noopener" href="http://www.auto.ustc.edu.cn/">www.auto.ustc.edu.cn</a></p>
</blockquote>
</li>
<li><p>域的域名:可以用于表示一个域  </p>
<blockquote>
<p>从树枝往上找</p>
</blockquote>
</li>
<li><p>主机的域名:一个域上的一个主机</p>
<blockquote>
<p>从树叶往上找</p>
</blockquote>
</li>
</ul>
</li>
<li><p>域名的管理</p>
<ul>
<li>一个域管理其下的子域<ul>
<li>.jp被划分为ac.jp    co.jp</li>
<li>.cn被划分为edu.cn   com.cn</li>
</ul>
</li>
<li>创建一个新的域，必须征得它所属域的同意</li>
</ul>
</li>
<li><p>域与物理网络无关</p>
<ul>
<li>域遵从组织界限，而不是物理网络<ul>
<li>一个域的主机可以不在一个网络</li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>问题2：如何解析域名为IP地址问题-名字服务器(Name Server)</p>
<ul>
<li><p>只采用一个服务器作为名字服务器的问题</p>
<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离的集中式数据库 </li>
</ul>
</li>
<li><p>所以采用分布式服务器来解决域名解析为IP地址的问题，大致来说，存在三种DNS服务器：根DNS服务器、顶级域DNS服务器和权威DNS服务器</p>
</li>
<li><p>顶级域(TLD)服务器：</p>
<ul>
<li>负责顶级域名（如com, org, net,  edu和gov）和国家级的顶级域名（如cn, uk, fr, ca,  jp ）<ul>
<li>Network solutions 公司维护com TLD服务器 </li>
<li>Educause公司维护edu TLD服务器</li>
</ul>
</li>
</ul>
</li>
<li><p>将名字空间划分为若干互不相交的区域(zone) </p>
<ul>
<li>区域的划分有区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li>
<li>名字服务器：<ul>
<li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record) ，组织机构的DNS服务器，提供组织机构服务器可以访问的主机和IP之间的映射</li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413185005911.png" alt="Zone"></p>
<ul>
<li><p>区域名字服务器通过维护资源记录来维护区域内各域名和主机之间的信息数据</p>
<ul>
<li><p>资源记录(resource records) </p>
<ul>
<li><p>作用：维护 域名-IP地址(其它)的映射关系</p>
</li>
<li><p>位置：Name Server的分布式数据库中 </p>
</li>
<li><p>RR格式: (domain_name, ttl, type,class,Value) </p>
<ul>
<li><p>Domain_name: 域名 </p>
</li>
<li><p>Ttl: time to live : 生存时间</p>
<blockquote>
<p>某一域名的RR在它的权威服务器中是无限大的，而在其他服务器中缓冲记录是有限的，一段时间后会将该域名RR删除。</p>
<p>缓冲目的是为了提高效率<br>删除缓存目的是为了维护一致性</p>
</blockquote>
</li>
<li><p>Class 类别 ：对于Internet，值为IN </p>
</li>
<li><p>Value 值：可以是数字，域名或ASCII串等，存的是域名对应的IP地址</p>
</li>
<li><p>Type 类别：资源记录的类型</p>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413195554207.png" alt="Type类型举例"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS大致工作过程</p>
<ul>
<li>应用调用解析器（resolver）</li>
<li>解析器作为客户向Local Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文（name/ip）</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413211302361.png" alt="DNS大致工作过程"></p>
</li>
<li><p>本地名字服务器（Local Name Server）</p>
<ul>
<li>并不严格属于DNS服务器的层次结构<ul>
<li>一般是距离主机最近的名字服务器</li>
</ul>
</li>
<li>每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器<ul>
<li>也称为“默认名字服务器”</li>
</ul>
</li>
<li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器 <ul>
<li>起着代理的作用，将查询转发到层次结构中去解析主机名</li>
<li>名字解析过程：<ul>
<li>目标名字在Local Name Server中<ul>
<li><p>情况1：查询的名字在Local Name Server区域内部</p>
</li>
<li><p>情况2：Local Name Server中有对应主机的缓存(cashing)</p>
<blockquote>
<p>缓冲是为了效率，一段时间后会删除缓冲，是为了保持一致性</p>
</blockquote>
</li>
</ul>
</li>
<li>当与本地名字服务器不能解析名字时，联系根名字服务器顺着根-TLD 一直找到权威名字服务器<ul>
<li><p>递归查询</p>
<ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器的负担太重</li>
<li>解决： 迭代查询 （iterated  queries）</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413234354328.png" alt="递归查询"></p>
</li>
<li><p>迭代查询</p>
<p>主机cis.poly.edu 想知道主机 gaia.cs.umass.edu 的IP地址</p>
<ul>
<li>根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</li>
<li>最后由权威名字服务器给出解析结果</li>
<li>当前联络的服务器给出可以联系的服务器的名字“我不知道这个名字，但 可以向这个服务器请求”</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413234546250.png" alt="迭代查询"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DNS协议报文</p>
<ul>
<li><p>DNS协议的查询和响应报文的报文格式相同，靠标识位flags来判断查询/应答</p>
<ul>
<li><p>报文首部：</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413235044154.png" alt="DNS报文"></p>
<blockquote>
<p>ID是为了实现流水线并行查询DNS</p>
</blockquote>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210413235107155.png" alt="DNS报文内容"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>提高性能：缓存 </p>
<ul>
<li>一旦名字服务器学到了一个映射，就将该映射缓存起来 </li>
<li>根服务器通常都在本地服务器中缓存着 <ul>
<li>使得根服务器不用经常被访问 </li>
</ul>
</li>
<li>目的：提高效率 </li>
<li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</li>
<li>解决方案：TTL（默认2天）</li>
</ul>
<blockquote>
<p>TTL结束后，删除缓存的内容</p>
</blockquote>
</li>
</ul>
</li>
<li><p>问题3：维护问题：新增一个域怎么维护？</p>
<ul>
<li><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名 和 域名服务器的地址</p>
</li>
<li><p>在新增子域 的名字服务器上运行名字服务器，负责本域 的名字解析： 名字-&gt;IP地址 </p>
<blockquote>
<p>例子：在com域中建立一个“Network Utopia” </p>
<ul>
<li>到注册登记机构注册域名networkutopia.com <ul>
<li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字 和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录: (networkutopia.com, dns1.networkutopia.com, NS) (dns1.networkutopia.com, 212.212.212.1, A) </li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有<ul>
<li>用于Web服务器的<a target="_blank" rel="noopener" href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a></li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>攻击DNS，DNS总的来说比较健壮</p>
<ul>
<li><p>DDoS 攻击</p>
<ul>
<li><p>对根服务器进行流量轰炸攻击：发送大量ping </p>
<ul>
<li>没有成功 </li>
<li>原因１：根目录服务器配置了流量过滤器，防火墙 </li>
<li>原因２：Local DNS 服务器缓存了TLD服务器的IP地址,  因此无需查询根服务器</li>
</ul>
</li>
<li><p>向TLD服务器流量轰炸攻击 ：发送大量查询 </p>
<ul>
<li>可能更危险 </li>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
<blockquote>
<p><font color="red">这里不是很明白，为什么缓存了顶级域名就不会访问根域名了？迭代、递归不都是先访问根域名服务器吗？然后才知道访问哪个顶级域名吗？本地域名服务器可以知道应该访问哪个顶级域名服务器吗？</font></p>
<p>先访问根域名服务器是为了获得顶级域名服务器的IP地址，本地域名服务器中有相应的缓存即对应IP地址，就可以直接去访问顶级域名，而不用再去访问根域名服务器。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>重定向攻击</p>
<ul>
<li>中间人攻击 <ul>
<li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li>
</ul>
</li>
<li>DNS中毒<ul>
<li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li>
</ul>
</li>
<li>技术上较困难：分布式截获和伪造</li>
</ul>
</li>
<li><p>利用DNS基础设施进行DDoS</p>
<ul>
<li>伪造某个IP进行查询， 攻击这个目标IP</li>
<li>查询放大，响应报文比查询报文大 </li>
<li>效果有限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-5-P2P应用"><a href="#4-5-P2P应用" class="headerlink" title="4.5 P2P应用"></a>4.5 P2P应用</h4><ul>
<li><p>纯P2P架构</p>
<ul>
<li>没有（或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>Peer节点间歇上网，每次IP地址都有可能变化</li>
<li>例子：<ul>
<li>文件分发（BitTorrent）</li>
<li>流媒体（KanKan）</li>
<li>VoIP（Skype）</li>
</ul>
</li>
</ul>
</li>
<li><p>文件分发：C/S vs P2P</p>
<p>问题：从一台服务器分发文件（大小F）到N个peer需要多少时间？</p>
<blockquote>
<p>Peer节点上下载能力是有限的资源</p>
</blockquote>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414082756872.png" alt="文件分发"></p>
<ul>
<li><p>C/S模式的文件分发时间</p>
<ul>
<li><p>服务器传输： 都是由服务器发送给peer，服务器必须顺序 传输（上载）N个文件拷贝: </p>
<ul>
<li>发送一个copy: F/u<sub>s</sub></li>
<li>发送N个copy： NF/u<sub>s</sub> </li>
</ul>
</li>
<li><p>客户端: 每个客户端必须下载一个文件拷贝 </p>
<ul>
<li><p>d<sub>min</sub> = 客户端最小的下载速率 </p>
</li>
<li><p>下载带宽最小的客户端下载的时间：F/d<sub>min</sub></p>
<blockquote>
<p>下载带宽最小的客户端是所有客户端中下载所耗费时间最长的</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414083126229.png" alt="C/S模型文件分发时间"></p>
<blockquote>
<p>客户端较少的时候，下载带宽最小的客户端下载时间是瓶颈；客户端较大时，服务器上载能力是瓶颈。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>P2P模式文件分发时间</p>
<ul>
<li><p>服务器传输：最少需要上载一份拷贝</p>
<ul>
<li>发送一个拷贝的时间：F/u<sub>s</sub> </li>
</ul>
</li>
<li><p>客户端: 所有客户端最终都需要下载一个拷贝 </p>
<ul>
<li>最小下载带宽客户单耗时：F/d<sub>min</sub></li>
</ul>
</li>
<li><p>NF文件上载时间：所有客户端总体下载量为NF，而服务器和其他所有Peer节点的总的最大上载带宽是：<br>$$<br>u_s + \Sigma u_i<br>$$</p>
<blockquote>
<p>除了服务器可以上载，其他所有的peer节点都可以上载</p>
</blockquote>
<p>所以NF文件上载时间：<br>$$<br>\frac {NF}{u_s+\Sigma u_i}<br>$$</p>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414085223889.png" alt="P2P文件分发"></p>
<blockquote>
<p>每个Peer节点的加入，请求资源的节点在增加，同时服务能力也在增加</p>
</blockquote>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414085509474.png" alt="C/S  vs  P2P"></p>
</li>
</ul>
</li>
<li><p>P2P文件共享两大问题：</p>
<ul>
<li><p>如何定位所需资源</p>
</li>
<li><p>如何处理对等方的加入与离开</p>
</li>
<li><p>可能的方案：P2P系统的管理模式</p>
<ul>
<li><p>非结构化P2P</p>
<ul>
<li>Peer节点邻居之间有协作关系则有边，然后各个Peer和他们的协作关系构成了应用层逻辑上的网络Overlay（覆盖网）</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414091248820.png" alt="非结构化覆盖网"></p>
<blockquote>
<p>Peer节点之间构成的协作关系（即边）是随机的</p>
</blockquote>
<ul>
<li><p>非结构化的P2P可以分为：</p>
<ul>
<li><p>集中式目录</p>
<p>将每个Peer节点有什么资源和节点上下线等信息作为目录存储在一个服务器上，用户需要什么资源，然后向服务器请求，服务器告知哪个Peer有这个资源，然后用户再与该Peer节点建立联系下载文件，此时用户是客户端，而拥有资源的服Peer节点是服务器。下载完成后，该用户也成为拥有该资源的服务器。</p>
<blockquote>
<p>例：Alice在其笔记本电脑上运行P2P客户端程序，间歇性地连接到 Internet，每次从其 ISP得到新的IP地址，假设Alice请求“双截棍.MP3” ，应用程序显示其他有“ 双截棍.MP3” 拷贝的对等方。Alice选择其中一个对等方，如Bob。文件就会从Bob’s PC传送到 Alice的笔记本上：HTTP 。当Alice下载后，其他用户也可以从Alice处下载“ 双截棍.MP3”。</p>
<p>此外，Alice在下载Bob的内容时，他也可以同时作为其他人的服务器上载自己拥有的其他文件。</p>
</blockquote>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414114834512.png" alt="集中式目录"></p>
<blockquote>
<p>文件传输是分散的，但是目录定位内容是高度集中在目录服务器的</p>
</blockquote>
<ul>
<li>集中式目录中存在的问题：<ul>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
</li>
</ul>
</li>
<li><p>完全分布式</p>
<ul>
<li><p>目录查询、文件传输都采用P2P形式</p>
</li>
<li><p>例子：Gnutella</p>
<ul>
<li><p>全分布式，没有中心服务器</p>
<p>开放文件共享协议</p>
<p>许多Gnutella客户端实现了Gnutella协议</p>
<p>​    类似HTTP有许多的浏览器</p>
</li>
<li><p>覆盖网络：图 </p>
<p>如果X和Y之间有一个 TCP连接，则二者之间存在一条边</p>
<p>所有活动的对等方和边就是覆盖网络</p>
<p>边并不是物理链路，而是传输连接</p>
<p>给定一个对等方，通常所连接的节点少于10个</p>
</li>
<li><p>协议</p>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414203646040.png" alt="Gnutella协议"></p>
<blockquote>
<p>查询文件方式：洪泛（flooding），A向它的所有邻居B、C、D进行查询，然后B、C、D在向自己的所有邻居进行查询，一直向下延续</p>
</blockquote>
<ul>
<li>Gnutella的Peer节点的加入</li>
</ul>
<ol>
<li>新加入的对等方X的Gnutella客户端应用必须首先携带某些已经在覆盖网络中的其他对等方的IP地址：使用可用对等方列表</li>
</ol>
<blockquote>
<p>自己维持一张对等方列表（经常开机的对等方的IP） 联系维持列表的Gnutella站点 </p>
</blockquote>
<ol start="2">
<li><p>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</p>
</li>
<li><p>X向Y发送一个Ping报文，Y向自己连接的节点转发该Ping报文</p>
</li>
<li><p>所有收到Ping报文的对等方以Pong报文响应X，回复自己的IP地址、共享文件的数量及总字节数等信息</p>
</li>
<li><p>X收到许多Pong报文，然后它能建立起与其他节点的TCP连接</p>
</li>
</ol>
<ul>
<li>Gnutella的Peer节点的离开</li>
</ul>
<p>该节点向邻居发送离开的报文，然后它的邻居会将该节点的信息删除，然后选择一个覆盖网络其他的节点补充为新的邻居，从而维持覆盖网络的服务能力</p>
</li>
</ul>
</li>
<li><p>混合式</p>
<ul>
<li>例子：KaZaA</li>
<li>每个对等方要么是一个组长，要么隶属于一个组长 <ul>
<li>对等方与其组长之间有 TCP连接 </li>
<li>组长对之间有TCP连接</li>
</ul>
</li>
<li>组长跟踪其所有的孩子的内容</li>
<li>组长与其他组长联系<ul>
<li>转发查询到其他组长</li>
<li>获得其他组的数据拷贝</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414205526041.png" alt="混合式"></p>
<ul>
<li><p>查询方式</p>
<ul>
<li>每个文件有一个散列标识码和一个描述符 </li>
</ul>
<blockquote>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414210256736.png" alt="组长记录组内目录"></p>
</blockquote>
<ul>
<li>客户端向其组长发送关键字查询</li>
</ul>
<blockquote>
<p>通过关键字与描述匹配查询相应文件</p>
</blockquote>
<ul>
<li><p>组长用匹配进行响应：</p>
<ul>
<li>对每个匹配：元数据、散列标识码和IP地址</li>
</ul>
</li>
<li><p>如果组长将查询转发给其他组长，其他组长也以匹配进行响应</p>
</li>
<li><p>客户端选择要下载的文件</p>
<ul>
<li>向拥有文件的对等方发送一个带散列标识码的HTTP请求</li>
</ul>
<blockquote>
<p>通过唯一的散列标识码进行确定需要下载的文件</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>结构化的P2P（DHT 基于分布式散列表的结构化管理）</p>
<blockquote>
<p>Overlay是结构化的，例如环、树等，可以进一步深入拓展等</p>
</blockquote>
<ul>
<li>例如：环状结构化P2P</li>
</ul>
<p>每个节点映射成唯一的16位的哈希值作为标识，按照哈希值大小有序地首尾相接构成环状有序拓扑。文件同样映射成唯一16位的哈希值，然后按照0-88标识的文件由88节点管理、89-100文件由100节点管理等形式来有序管理文件，查询时只需按照文件标识即可实现快速查询。</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414225432242.png" alt="环状结构化P2P"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>非结构化P2P应用实例：BitTorrent</p>
<ul>
<li>文件被分为一个个块256KB，然后每个客户端有各自的bitmap，bitmap用来标识文件的有无（有为“1”，无为“0”）</li>
<li>网络中这些Peers发送接受文件块，相互服务</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210414210942114.png" alt="BitTorrent"></p>
<blockquote>
<p>tracker记录了洪流中节点的IP地址等信息。新的Peer进来，需要向tracker登记自己信息，同时获得洪流中其他节点的IP信息。</p>
</blockquote>
<ul>
<li><p>新Peer加入torrent：  </p>
<ul>
<li><p>新Peer一开始没有块，但是将会通过向其他节点请求来累积文件块 </p>
<blockquote>
<p>前几次请求是随机请求，后面几次优先请求稀缺的块，为了保证稀缺的块不会由于其拥有者的下线而丢失，同时，稀缺的块被其他Peer节点所需要，通过提高上载速率来获得更好的下载速率（由下面的tit-for-tat机制决定）</p>
</blockquote>
</li>
<li><p>向跟踪服务器注册，获得peer节点列表，和部分peer 节点构成邻居关系 (“连接 ”) </p>
</li>
</ul>
</li>
<li><p>当peer下载时，该peer可以同时向其他节点提供上载服务</p>
</li>
<li><p>扰动churn: peer节点可能会上线或者下线，但是整体来说维持着文件内容的充分性，P2P服务能力稳定</p>
</li>
<li><p>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</p>
</li>
<li><p>请求块： </p>
<ul>
<li>在任何给定时间，不同 peer节点拥有一个文件块的子集</li>
<li>周期性的，各个Peer节点向邻居询问他们拥有哪些块的信息 ，即交换bitmap，然后各个Peer向邻居请求它希望的块，稀缺的块</li>
</ul>
</li>
<li><p>发送块：一报还一报 tit-for-tat</p>
<ul>
<li><p>每个节点同时只能向4个peer发送块提供服务，来保证提供的带宽较大，而其他peer将被该节点阻塞 (将不会从Alice处获得服务)</p>
<ul>
<li><p>所以节点会选择给自己提供带宽较大的、服务较多的4个Peer邻居作为自己服务对象，并且每10秒重新评估一次前4位来优先服务</p>
<blockquote>
<p>这种机制有利于激励其他节点提高自己的上载速率，从而提高整个洪流的服务能力</p>
</blockquote>
</li>
<li><p>同时每隔30秒：将随机选择其他peer节点，向这个节点发送块，来 “优化疏通” 这个节点。</p>
<blockquote>
<p>原因是新选择的节点所包含的资源有可能是自己需要的，尝试提高给他的服务，有可能有利于之后自己收到它的服务质量的提高</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-6-CDN"><a href="#4-6-CDN" class="headerlink" title="4.6 CDN"></a>4.6 CDN</h4><ul>
<li><p>视频流量：占据着互联网大部分的带宽。</p>
<p>Netflix，Youlube:占据37%，16%的ISP下行流量<br><del>1B YouTube用户，</del>75M Netflix用户</p>
<p>挑战:规模性-如何服务者~1B 用户？</p>
<p>​    单个超级服务器无法提供服务</p>
<p>挑战:异构性</p>
<pre><code>不同用户拥有不同的能力（例如:有线接入和移动用户；带宽丰富和受限用户)
</code></pre>
<p>解决方案:分布式的，应用层面的基础设施</p>
</li>
<li><p>多媒体：视频</p>
<ul>
<li><p>视频：固定速度显示的图像序列，e.g. 24 images/sec</p>
</li>
<li><p>网络视频特点：</p>
<ul>
<li>高码率：&gt;10x于音频，高的网络带宽需求</li>
<li>可以被压缩</li>
<li>90%以上的网络流量是视频 </li>
</ul>
</li>
<li><p>数字化图像：像素的阵列</p>
</li>
<li><p>每个像素被若干bits表示</p>
</li>
<li><p>编码：使用图像内和图像间的冗余来降低编码的比特数 </p>
<ul>
<li>空间冗余（图像内） </li>
<li>时间冗余（相邻的图像间）</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415125750098.png" alt="编码方式示例"></p>
<ul>
<li><p>编码标准：</p>
<p>CBR: (constant bit  rate): 以固定速率编码 </p>
<p>VBR: (variable bit  rate): 视频编码速率随时间的变化而变化</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>存储视频的流化服务</p>
<p>对于视频文件，并不是将文件全部下载完成以后才进行播放，而是边下载边播放</p>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415125951929.png" alt="场景示例"></p>
<ul>
<li><p>多媒体流化服务示例：DASH</p>
<ul>
<li>DASH: Dynamic, Adaptive Streaming over HTTP</li>
</ul>
<blockquote>
<p>通过HTTP协议传送数据</p>
</blockquote>
<ul>
<li><p>可以解决不同客户端、不同网络情况、不同需求的问题</p>
</li>
<li><p>服务器: </p>
<ul>
<li>将视频文件分割成多个块</li>
<li>每个块独立存储，编码于不同码率（8-10种）</li>
</ul>
<blockquote>
<p>对于每一个块都可以有不同版本，可以是不同清晰度的、不同编码方式的、不同码率的</p>
</blockquote>
<ul>
<li>告示文件（manifest file）: 提供不同块的URL </li>
</ul>
<blockquote>
<p>告示文件提供块的数量、格式、版本以及相应的URL等信息</p>
</blockquote>
</li>
<li><p>客户端: </p>
<ul>
<li><p>先获取告示文件</p>
<blockquote>
<p>客户端会周期性地测量服务器到客户端的带宽</p>
</blockquote>
</li>
<li><p>查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围</p>
<ul>
<li>会根据带宽、客户端需求等信息选择下载块的什么版本等，使得播放流畅质量相对高</li>
<li>如果带宽足够，选择最大码率的视频块</li>
<li>会话中的不同时刻，可以切换请求不同的编码块（取决于当时的可用带宽等）</li>
</ul>
</li>
</ul>
</li>
<li><p>“智能”客户端：客户端自适应决定</p>
<ul>
<li>什么时候去请求块 (不至于缓存挨饿，或者溢出)</li>
<li>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块) </li>
<li>哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求) </li>
</ul>
</li>
</ul>
</li>
<li><p>挑战：服务器如何通过网络向上百万用户同时流化视频内容 (上百万视频内容)？</p>
<ul>
<li><p>选择1：单个的、大的超级服务中心“mega-server” </p>
<ul>
<li>服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿 </li>
<li>“二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差） </li>
<li>单点故障点，性能瓶颈</li>
</ul>
<blockquote>
<p>一个服务器的服务能力有限</p>
</blockquote>
<ul>
<li>周边网络的拥塞</li>
</ul>
<blockquote>
<p>对于网络拥塞问题，服务器难以解决</p>
</blockquote>
<ul>
<li>评价：相当简单，但是这个方法不可扩展</li>
</ul>
</li>
<li><p>选项2：通过CDN（Content distribution networks），全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p>
<ul>
<li><p>CDN部署节点方式：</p>
<ul>
<li>enter deep：将CDN服务器深入到许多接入网，将缓存节点部署到local ISP<ul>
<li>更接近用户，服务质量高，但是数量多，离用户近所以管理困难</li>
<li>例子：Akamai, 1700个位置</li>
</ul>
</li>
<li>bring home：部署在少数(10个左右)关键位置，如将服务器簇安装于POP附近（离若干1<sup>st</sup> ISP POP较近）<ul>
<li>采用租用线路将服务器簇连接起来，部署节点少还保证质量较高，但是跳数较多</li>
<li>例子：Limelight</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN实现内容加速示例：</p>
<ul>
<li>提供内容服务者首先将内容的备份通过专用链路拷贝到CDN服务商部署的缓存节点中，然后用户申请资源时，先向内容提供者的源服务器请求，然后源服务器提供给他一个告示文件（manifest file），告示文件中有用户所需内容在各缓存节点中的版本信息、URL存储位置等信息，然后用户客户端可以根据网络情况、距离、用户需求等就近从CDN缓存中获取文件块。</li>
<li>用户从CDN中请求内容<ul>
<li>重定向到最近的拷贝，请求内容 </li>
<li>如果网络路径拥塞，可能选择不同的拷贝</li>
</ul>
</li>
</ul>
</li>
<li><p>CDN是应用层协议，是在网络边缘来加速网络运营服务、来提供服务的     over the top</p>
</li>
<li><p>OTT （over the top）面临的挑战：在拥塞的互联网上复制 </p>
<ul>
<li>从哪个CDN节点中获取内容？</li>
<li>用户在网络拥塞时的行为？</li>
<li>在哪些CDN节点中存储什么内容？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-Socket（套接字）编程"><a href="#5-Socket（套接字）编程" class="headerlink" title="5 Socket（套接字）编程"></a>5 Socket（套接字）编程</h3><p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210329092824673.png" alt="网络程序设计接口"></p>
<ul>
<li><p>网络应用是在应用层中运行的应用进程之间的通信。应用进程使用<strong>传输层提供的服务</strong>才能够交换报文，实现<strong>应用层协议</strong>，实现应用</p>
</li>
<li><p>应用进程与底层协议之间的桥梁：应用编程接口API</p>
<p>API就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。应用进程通过API将控制权交给操作系统，操作系统调用相应过程，然后将结果传输回应用进程。</p>
<blockquote>
<p>传输层以及以下的四层往往由操作系统控制。</p>
</blockquote>
</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210329094838806.png" alt="五层结构"></p>
<ul>
<li><p>典型的应用编程接口：</p>
<ul>
<li>Berkeley UNIX操作系统   套接字接口（socket interface），简称套接字（socket）</li>
<li>Windows 上     基于socket的稍不同的API：  WINSOCK</li>
<li>AT&amp;T为其UNIX系统V定义的一种API：TLI（Transport Layer Interface）</li>
</ul>
</li>
<li><p>TCP/IP  应用进程使用Socket API访问传输服务</p>
<p>地点：界面上的SAP（socket）方式： Socket API  </p>
<p>socket: 分布式应用进程之间的门，传输层协议提供的端到端 服务接口</p>
</li>
<li><p>传输层服务的协议，决定了socket也是两种类型</p>
<ul>
<li>TCP：可靠的、字节流的服务</li>
</ul>
<blockquote>
<p>字节流不提供报文的边界区分</p>
</blockquote>
<ul>
<li>UDP：不可靠的（数据UDP数据报）服务</li>
</ul>
</li>
<li><p>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户</p>
</li>
</ul>
<h4 id="5-1-TCP-Socket"><a href="#5-1-TCP-Socket" class="headerlink" title="5.1 TCP Socket"></a>5.1 TCP Socket</h4><ul>
<li><p>TCP套接字编程</p>
<ul>
<li><p>服务器首先运行，等待连接建立 </p>
</li>
<li><p>服务器进程必须先处于运行状态：</p>
<ul>
<li>创建欢迎socket和对应的一个套接字整数</li>
<li>和本地端口捆绑</li>
<li>在欢迎socket上阻塞式等待接收用户的连接</li>
</ul>
<blockquote>
<p>阻塞式，即没有用户连接，则程序停止在该函数，不向下进行</p>
</blockquote>
</li>
<li><p>客户端需要时，将主动和服务器建立连接： </p>
<ul>
<li>创建客户端本地套接字（隐式捆绑到本地port）</li>
<li>然后指定服务器进程的IP地址和端口号，与服务器进程连接</li>
</ul>
<blockquote>
<p>向服务器请求连接时，服务器的响应未到达时，客户端的socket函数也是阻塞状态</p>
</blockquote>
</li>
<li><p>当客户端的连接请求到达服务器时：</p>
<p>服务器接受来自用户端的请求 ，解除阻塞式等待，返回一个 新的socket（与欢迎socket不 一样），与客户端通信</p>
<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源IP和源端口来区分不同的客户端</li>
</ul>
</li>
<li><p>连接API调用有效时，客户端与服务器建立了TCP连接</p>
</li>
</ul>
</li>
<li><p>TCP socket应用示例</p>
<p>C/S模式的应用样例: </p>
<ol>
<li>客户端从标准输入装置读取一行字符，发送给服务器</li>
<li>服务器从socket读取字符</li>
<li>服务器将字符转换成大写 ，然后返回给客户端</li>
<li>客户端从socket中读取一行字符，然后打印出来</li>
</ol>
<p>实际上，这里描述了C-S之间交互的动作次序</p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415191855698.png" alt="TCP socket 示例"></p>
<ul>
<li><p>socket中涉及的数据结构介绍</p>
<ol>
<li>数据结构 sockaddr_in</li>
</ol>
<p>IP地址和port捆绑关系的数据结构（标示进程的端节点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  	<span class="keyword">short</span> sin_family; <span class="comment">//AF_INET</span></span><br><span class="line">      <span class="comment">/*地址族 简单来说就是底层是使用的哪种通信协议来递交数据的，如 AF_INET 用的是 TCP/IPv4；AF_INET6使用的是 TCP/IPv6；而 AF_LOCAL 或者 AF_UNIX 则指的是本地通信（即本次通信是在当前主机上的进程间的通信），一般用绝对路径的形式来指明*/</span></span><br><span class="line">  	u_short sin_port; <span class="comment">//port  端口号</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span> ;</span><span class="comment">/*IP address, unsigned long*/</span></span><br><span class="line">  	<span class="keyword">char</span> sin_zero[<span class="number">8</span>];  <span class="comment">//align  </span></span><br><span class="line">      <span class="comment">/*起对齐作用，为了让其他格式的不同长度IP地址和TCP/IP格式中的IP地址对齐*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据结构 hostent</li>
</ol>
<p>域名和IP地址的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *h_name;<span class="comment">//主机域名</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;<span class="comment">//主机的一系列别名</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype;</span><br><span class="line">	<span class="keyword">int</span> h_length;<span class="comment">/*地址的长度*/</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list; <span class="comment">//存储一系列IP地址</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作为调用域名解析函数时的参数返回后，将IP地址拷贝到 sockaddr_in的IP地址部分</p>
</li>
<li><p>C/S socket 交互：TCP </p>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/TCPsocket.png" alt="TCPsocket交互过程"></p>
</li>
</ul>
<blockquote>
<p>黑色箭头是TCP的建立连接过程，红色箭头是TCP Socket传输数据</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">//argv[]</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server   服务器的信息sockaddr_in结构*/</span> </span><br><span class="line">	<span class="keyword">int</span> clientSocket; <span class="comment">/* socket descriptor 客户端socket整数*/</span> 	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry 指针指向hostent的结构体*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];  </span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];  </span><br><span class="line">    <span class="comment">//argv[0]存应用程序本身名字</span></span><br><span class="line">    host = argv[<span class="number">1</span>]; <span class="comment">//argv[1]存服务器域名 字符串</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]); <span class="comment">//argv[2]存服务器端口号 字符串   //atoi()  字符串转为整形</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Create client socket, connect to server</span></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//建立TCP socket</span></span><br><span class="line">    	<span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure 清零sad*/</span>  </span><br><span class="line">    	sad.sin_family = AF_INET; <span class="comment">/* set family to Internet 地址族*/</span>  </span><br><span class="line">    	sad.sin_port = htons((u_short)port); <span class="comment">//(u_short)  port先转为无符号短整型   然后htons再变成网络次序（大端/小端）</span></span><br><span class="line">    	ptrh = gethostbyname(host);  <span class="comment">/* Convert host name to IP address 由域名得到有效IP地址*/</span> </span><br><span class="line">    	<span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length);  <span class="comment">//将IP地址拷贝到sad.sin_addr </span></span><br><span class="line">    	connect(clientSocket,(struct sockaddr*)&amp;sad,<span class="keyword">sizeof</span>(sad));<span class="comment">//将客户端与服务器建立连接</span></span><br><span class="line">    </span><br><span class="line">    gets(Sentence);<span class="comment">//Get input stream from user 标准input获得用户输入</span></span><br><span class="line">    n=write(clientSocket, Sentence,<span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>); <span class="comment">//Send line to server</span></span><br><span class="line">	n=read(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence)); <span class="comment">//Read line from server</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n”,modifiedSentence);</span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string">	close(clientSocket); //Close connection</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address of server服务器本地的sockaddr_in*/</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span> <span class="comment">/*client的sockaddr_in */</span></span><br><span class="line">	<span class="keyword">int</span> welcomeSocket, connectionSocket; <span class="comment">/* socket descriptor 套接字*/</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span> clientSentence[<span class="number">128</span>]; </span><br><span class="line">	<span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>]; </span><br><span class="line">    </span><br><span class="line">	port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//Create welcoming socket at port &amp; Bind a local address</span></span><br><span class="line">	welcomeSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">		<span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">		sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">		sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span> </span><br><span class="line">		sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span> </span><br><span class="line">	bind(welcomeSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));<span class="comment">//和自己的IP、端口绑定</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* Specify the maximum number of clients that can be queued 可以并行10个进程，超过将会拒绝其他连接*/</span></span><br><span class="line">	listen(welcomeSocket, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">		connectionSocket=accept(welcomeSocket, (struct sockaddr *)&amp;cad, &amp;alen);<span class="comment">//Wait, on welcoming socket for contact by a client</span></span><br><span class="line">		n=read(connectionSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line">		<span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span> 		</span><br><span class="line">    	n=write(connectionSocket, capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>); <span class="comment">//Write out the result to socket</span></span><br><span class="line">		close(connectionSocket); <span class="comment">//End of while loop,loop back and wait for another client connection</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-UDP-Socket"><a href="#5-2-UDP-Socket" class="headerlink" title="5.2 UDP Socket"></a>5.2 UDP Socket</h4><ul>
<li>UDP：在客户端和服务器之间没有连接 <ul>
<li>没有握手</li>
<li>发送端必须在每一个报文中明确地指定目标的IP地址和端口号</li>
<li>服务器必须从收到的分组中提取出发送端的IP地址和端口号 </li>
</ul>
</li>
<li>UDP：传送的数据可能乱序，也可能丢失。UDP为客户端和服务器提供不可靠的字节组的传送服务。</li>
<li>UDP交互过程：</li>
</ul>
<p><img src="/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/image-20210415232630215.png" alt="UDP socket 交互"></p>
<blockquote>
<p>UDP的socket包括socket套接字整数值、自己的IP、自己的端口号，而无对方的IP和端口号</p>
</blockquote>
<blockquote>
<p><font color="red">疑问：是不是UDP不能并行？只有一个Socket</font></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span> </span><br><span class="line">	<span class="keyword">int</span> clientSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>]; </span><br><span class="line">	<span class="keyword">char</span> modifiedSentence[<span class="number">128</span>]; </span><br><span class="line"></span><br><span class="line">    host = argv[<span class="number">1</span>]; port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);<span class="comment">//创建客户端 socket</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">/* determine the server&#x27;s address */</span></span><br><span class="line">		<span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">		sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">		sad.sin_port = htons((u_short)port); </span><br><span class="line">		ptrh = gethostbyname(host);</span><br><span class="line">	<span class="comment">/* Convert host name to IP address */</span></span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length); </span><br><span class="line">    	<span class="comment">//无connect  客户端socket没有连接到服务器</span></span><br><span class="line">    </span><br><span class="line">	gets(Sentence);<span class="comment">//Get input stream from user</span></span><br><span class="line">	addr_len =<span class="keyword">sizeof</span>(struct sockaddr); </span><br><span class="line">	n=sendto(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>,(struct sockaddr *) &amp;sad, addr_len); <span class="comment">//Send line to server  要指明服务器IP和端口号</span></span><br><span class="line">    </span><br><span class="line">	n=recvfrom(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence),(struct sockaddr *) &amp;sad, &amp;addr_len);<span class="comment">//Read line from server 要指明服务器IP和端口号</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FROM SERVER: %s\n”,modifiedSentence); </span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	close(clientSocket); //Close connection</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span> <span class="comment">/* structure to hold an IP address */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">	<span class="keyword">int</span> serverSocket; <span class="comment">/* socket descriptor */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span> <span class="comment">/* pointer to a host table entry */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>]; </span><br><span class="line">	<span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>]; </span><br><span class="line"></span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//Create welcoming socket at port &amp; Bind a local address</span></span><br><span class="line"></span><br><span class="line">    serverSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>); </span><br><span class="line">		<span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad)); <span class="comment">/* clear sockaddr structure */</span> </span><br><span class="line">		sad.sin_family = AF_INET; <span class="comment">/* set family to Internet */</span> </span><br><span class="line">		sad.sin_addr.s_addr = INADDR_ANY; <span class="comment">/* set the local IP address */</span> </span><br><span class="line">		sad.sin_port = htons((u_short)port);<span class="comment">/* set the port number */</span> </span><br><span class="line">	bind(serverSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));<span class="comment">//和自己的IP、端口绑定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line"></span><br><span class="line">        n=recvfrom(serverSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence), <span class="number">0</span> (struct sockaddr *) &amp;cad, &amp;addr_len );<span class="comment">//Receive messages from clients</span></span><br><span class="line">	<span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span></span><br><span class="line"></span><br><span class="line">        n=sendto(serverSocket , capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>,(struct sockaddr *) &amp;cad, &amp;addr_len); <span class="comment">//Write out the result to socket</span></span><br><span class="line">	&#125; <span class="comment">//End of while loop,loop back and wait for another client connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h3><h4 id="6-1-章节整体框架"><a href="#6-1-章节整体框架" class="headerlink" title="6.1 章节整体框架"></a>6.1 章节整体框架</h4><ul>
<li>应用程序体系结构<ul>
<li>客户-服务器</li>
<li>P2P </li>
<li>混合</li>
</ul>
</li>
<li>应用程序需要的服务品质描述：<ul>
<li>可靠性、带宽、延时、安全</li>
</ul>
</li>
<li>Internet传输层服务模式 <ul>
<li>可靠的、面向连接的服务： TCP</li>
<li>不可靠的数据报：UDP</li>
</ul>
</li>
<li>流行的应用层协议：<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP, POP, IMAP </li>
<li>DNS </li>
</ul>
</li>
<li>Socket编程</li>
</ul>
<h4 id="6-2-复习部分协议内容"><a href="#6-2-复习部分协议内容" class="headerlink" title="6.2 复习部分协议内容"></a>6.2 复习部分协议内容</h4><ul>
<li>应用层协议报文类型：请求/响应报文：<ul>
<li>客户端请求信息或服务</li>
<li>服务器以数据、状态码进行响应 </li>
</ul>
</li>
<li>报文格式： <ul>
<li>首部：关于数据信息的字段</li>
<li>数据：被交换的信息</li>
</ul>
</li>
<li>控制报文 vs. 数据报文<ul>
<li>带内（控制与数据报文一起传输）、带外（控制报文与数据报文不在同一端口传输）</li>
</ul>
</li>
<li>集中式 vs. 分散式</li>
<li>无状态 vs. 维护状态</li>
<li>可靠的 vs. 不可靠的报文传输 </li>
<li>在网络边缘处理复杂性</li>
<li>一个协议定义了在两个或多个通信实体之间交换报文的格式和次序、以及就一条报文传输和接收或其他事件采取的动作</li>
</ul>
<hr>
<p>终于肝完了，然而我们老师已经讲到了链路层，泪目…  </p>
<p>之后会加快学习进度 /汗  求支持</p>

    </div>

    
    
    
    <!-- 结尾文字-->
    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:18px;">-------------本文结束 <i class="fa fa-heart"></i> 感谢阅读-------------</div>
    
</div>
      </div>
    
        <div class="reward-container">
  <div>你的打赏会让我的钱包不那么孤单~</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="浅墨 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="浅墨 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>浅墨
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lightink2020.github.io/2021/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_01%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络-应用层">https://lightink2020.github.io/2021/04/10/计算机网络_01应用层/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_00%E7%BB%AA%E8%AE%BA/" rel="prev" title="计算机网络-00绪论">
      <i class="fa fa-chevron-left"></i> 计算机网络-00绪论
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_01%E7%BB%AA%E8%AE%BA/" rel="next" title="操作系统-01绪论">
      操作系统-01绪论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  




          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-text">计算机网络-应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">1 网络应用体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84%EF%BC%88Client-Server%EF%BC%8CC-S%EF%BC%89"><span class="nav-text">1.1 客户机&#x2F;服务器结构（Client-Server，C&#x2F;S）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-P2P%E7%BB%93%E6%9E%84"><span class="nav-text">1.2 P2P结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E6%B7%B7%E5%90%88%E7%BB%93%E6%9E%84"><span class="nav-text">1.3 混合结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-text">2 网络应用的进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 进程间通信基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">2.2 分布式进程间通信实现机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Internet%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-text">3 Internet传输层服务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E6%8F%8F%E8%BF%B0%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8C%87%E6%A0%87"><span class="nav-text">3.1 描述传输层指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Internet%E4%BC%A0%E8%BE%93%E5%B1%82%E6%8F%90%E4%BE%9B%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-text">3.2 Internet传输层提供什么样的服务？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%89%B9%E5%AE%9A%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8D%8F%E8%AE%AE"><span class="nav-text">4 特定网络应用以及协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-Web%E4%B8%8EHTTP"><span class="nav-text">4.1 Web与HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-HTTP%E6%A6%82%E5%86%B5"><span class="nav-text">4.1.1 HTTP概况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-2-HTTP%E8%BF%9E%E6%8E%A5"><span class="nav-text">4.1.2 HTTP连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-3-HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9A%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-text">4.1.3 HTTP报文格式：请求报文和响应报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-4-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%9ACookie"><span class="nav-text">4.1.4 用户与服务器的交互：Cookie</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-5-Web%E7%BC%93%E5%AD%98%EF%BC%88%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="nav-text">4.1.5 Web缓存（代理服务器）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-6-%E6%9D%A1%E4%BB%B6GET%E6%96%B9%E6%B3%95"><span class="nav-text">4.1.6 条件GET方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-FTP%EF%BC%9A%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-text">4.2 FTP：文件传输协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-EMail"><span class="nav-text">4.3 EMail</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-DNS%EF%BC%88Domain-Name-System%EF%BC%89"><span class="nav-text">4.4 DNS（Domain Name System）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-P2P%E5%BA%94%E7%94%A8"><span class="nav-text">4.5 P2P应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-CDN"><span class="nav-text">4.6 CDN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Socket%EF%BC%88%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%89%E7%BC%96%E7%A8%8B"><span class="nav-text">5 Socket（套接字）编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-TCP-Socket"><span class="nav-text">5.1 TCP Socket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-UDP-Socket"><span class="nav-text">5.2 UDP Socket</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%B0%8F%E7%BB%93"><span class="nav-text">6 小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E7%AB%A0%E8%8A%82%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="nav-text">6.1 章节整体框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%A4%8D%E4%B9%A0%E9%83%A8%E5%88%86%E5%8D%8F%E8%AE%AE%E5%86%85%E5%AE%B9"><span class="nav-text">6.2 复习部分协议内容</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="浅墨"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">浅墨</p>
  <div class="site-description" itemprop="description">点点滴滴，汇聚人生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LightInk2020" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LightInk2020" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-04 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">浅墨</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">255k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:52</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

<!-- 不蒜子计算浏览量 -->

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv"><span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>与你擦肩而过<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv"><span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>你是我的第<span id="busuanzi_value_site_uv"></span>个朋友</span>
    
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 



<!--浏览器搞笑标题-->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/hititle.js"></script>
<!-- 🌸飘落 -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/sakura.js"></script>
<!-- 雪花飘落 -->
<!-- <script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/snow1.js"></script> -->
<!-- 样式一 连线 -->
<!-- <script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js"></script>
<script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script> -->
<!-- 样式二（飘动的彩带） -->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/piao.js" type="text/javascript"></script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'K46o2NCWKcdduRzLxsjdmu9E-gzGzoHsz',
      appKey     : 'ilTccl33w3v2Fvw5swGISSju',
      placeholder: "如果有任何建议、想法和问题，欢迎您的留言！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
